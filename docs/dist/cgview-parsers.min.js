var CGVParse=function(){"use strict";return class{static seqToJSON(t,e={}){return this.parseSeqRecords(t,e)}static parseSeqRecords(t,e={}){const s=[];return t.split(/^\/\//m).filter(this.isSeqRecord).forEach((t=>{const e={inputType:"UNKNOWN"};/^\s*LOCUS|^\s*FEATURES/m.test(t)?e.inputType="genbank":/^\s*ID|^\s*SQ/m.test(t)&&(e.inputType="embl"),e.name=this.getSeqName(t),e.length=this.getSeqLength(t),e.sequence=this.getSequence(t),e.features=this.getFeatures(t),s.push(e)})),s}static isSeqRecord(t){return!/^\s*\/\/\s*$/.test(t)&&!/^\s*$/.test(t)}static getSeqName(t){const e=t.match(/^\s*(?:LOCUS|ID)\s*(\S+)/);if(e){let t=e[1];return t=t.replace(/;$/,""),t}return""}static getSeqLength(t){const e=t.match(/^\s*(?:LOCUS|ID).*?(\d+)\s[Bb][Pp]/);if(e)return parseInt(e[1])}static getSequence(t){const e=t.match(/^(?:ORIGIN|SQ\s{3}).*?$([^\/]*)(^\s*$|^\s*LOCUS)?/ms);return e?this.removeDigits(this.removeWhiteSpace(e[1])):""}static getFeatures(t){console.log("Parsing features...");const e=[],s=t.match(/^(?:FEATURES.*?$|FH.*?^FH.*?$)(.*)^(?:ORIGIN|SQ\s{3}).*?$/ms);if(s){let t=s[1];t=t.replace(/^FT/m,"  "),t.split(/(?=^\s{5}\S+)/m).filter(this.isFeatureRecord).forEach((t=>{const s={};s.type=this.getFeatureType(t),s.strand=this.getFeatureStrand(t),s.locationText=this.getFeatureLocationText(t),s.locations=this.getFeatureLocations(s.locationText),s.qualifiers=this.getFeatureQualifiers(t),s.type&&e.push(s)}))}return e}static isFeatureRecord(t){return!/^\s*\/\s*$/.test(t)&&!/^\s*$/.test(t)}static getFeatureType(t){const e=t.match(/^\s{5}(\S+)/);return e?e[1]:null}static getFeatureStrand(t){return t.match(/^\s{5}\S+\s+complement/)?-1:1}static getFeatureLocationText(t){const e=t.match(/^\s{5}\S+\s+([^\/]+)/s);return e?this.removeWhiteSpace(e[1]):""}static isParsableFeatureRange(t){return!/\d\.\d/.test(t)&&(!/\^/.test(t)&&(!/:/.test(t)&&!/^\s*$/.test(t)))}static getFeatureLocations(t){const e=[],s=t.split(/(?=,)/).filter(this.isParsableFeatureRange);for(const t of s){let s=t.match(/(\d+)\D*\.\.\D*(\d+)/);if(s){const t=parseInt(s[1]),r=parseInt(s[2]);e.push([t,r])}else if(s=t.match(/(\d+)/),s){const t=parseInt(s[1]),r=t;e.push([t,r])}}return e}static isFeatureQualifier(t){return!/^\s*\/\s*$/.test(t)&&!/^\s*$/.test(t)}static formatFeatureQualifier(t){return/\S\s\S/.test(t)?t.replace(/[\s]+/g," "):t.replace(/[\s]+/g,"")}static getFeatureQualifiers(t){const e={};let s=t.match(/(\/.*)/s);if(s){s[1].split(/(?=^\s*\/)/m).filter(this.isFeatureQualifier).forEach((t=>{let r,a;s=t.match(/\/([^\"\s]+)\s*=\s*\"?([^\"]*)\"?(?=^\s*\/|$)/ms),s?(r=s[1],a=this.formatFeatureQualifier(s[2])):(r=this.removeWhiteSpace(t),a=""),e[r]?e[r].push(a):e[r]=[a]}))}return e}static removeWhiteSpace(t){return t.replace(/\s+/g,"")}static removeDigits(t){return t.replace(/\d+/g,"")}static removeNewlines(t){return t.replace(/[\n\r]+/g,"")}}}();
