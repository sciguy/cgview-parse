var CGVParse = (function () {
  'use strict';

  // OPTIONS:
  // - logToConsole [Default: true]: log to console
  // - showTimestamps [Default: true]: Add time stamps
  // - howLevelIcons: Add level as icon: warn, info, etc (not implemented yet)
  // NOTE:
  // - logToConsole and showTimestamps can be overridden in each log call
  //   as well as the history
  // TODO:
  // - add groups to group logs together for formatting and filtering
  class Logger {

    constructor(options={}) {
      this.options = options;
      this.logToConsole = (options.logToConsole === undefined) ? true : options.logToConsole;
      this.showTimestamps = (options.showTimestamps === undefined) ? true : options.showTimestamps;
      this.showIcons = (options.showIcons === undefined) ? false : options.showIcons;
      this.logs = [];
    }

    get count() {
      return this.logs.length;
    }

    log(message, options={}) {
      this._log(message, 'log', options);
    }

    info(message, options={}) {
      this._log(message, 'info', options);
    }

    warn(message, options={}) {
      this._log(message, 'warn', options);
    }

    error(message, options={}) {
      this._log(message, 'error', options);
    }

    break(divider="\n") {
      const logItem = { type: 'break', break: divider };
      this.logs.push(logItem);
    }

    history(options={}) {
      let text = '';
      for (const logItem of this.logs) {
        if (logItem.type === 'message') {
          text += `${this._formatMessage(logItem, options)}\n`;
        } else if (logItem.type === 'break') {
          text += logItem.break;
        }
      }
      return text;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Private methods
    ///////////////////////////////////////////////////////////////////////////

    // level: warn, error, info, log
    _log(message, level, options={}) {
      const timestamp = this._formatTime(new Date());
      const logItem = { type: 'message', message, level, timestamp, icon: options.icon };
      this.logs.push(logItem);
      this._consoleMessage(logItem, options);
    }

    _consoleMessage(logItem, options={} ) {
      if (this._optionFor('logToConsole', options)) {
        console[logItem.level](this._formatMessage(logItem, options));
      }
    }

    _formatMessage(logItem, options={}) {
      let message = "";
      if (this._optionFor('showIcons', options)) {
        const icon = logItem.icon || logItem.level;
        message += this._icon(icon) + "";
      }
      if (this._optionFor('showTimestamps', options)) {
        message += `[${logItem.timestamp}] `;
      }
      message += logItem.message;
      return message
    }

    // e.g. 15:30:00
    _formatTime(date) {
      return date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZone: 'UTC',
        hour12: false
      });
    }

    // Return an icon for the name which may be a level or a custom icon
    // - name can be a level (e.g. log, info, warn, error), one of the other
    //   icons names (e.g. success, fail), or a custom icon (e.g. name = 'ðŸŽ')
    _icon(name) {
        const icons = {
          log: 'ðŸ“', info: 'â„¹ï¸', warn: 'âš ï¸', error: 'ðŸ›‘',
          success: 'âœ…', fail: 'ðŸ›‘', none: ' ',
       };
       if (name) {
          return icons[name] || name;
        } else {
          return icons.none;
        }
    }

    // Return the value for the option name from the default options (provided in Logger constructor)
    // Options passed here will override the default options
    _optionFor(name, options={}) {
      if (options[name] !== undefined) {
        return options[name];
      } else {
        return this[name];
      }
    }

  }

  function removeWhiteSpace(string) {
    return string.replace(/\s+/g, "");
  }

  function removeDigits(string) {
    return string.replace(/\d+/g, "");
  }

  /**
   * Returns a string id using the _name_ and _start_ while
   * making sure the id is not in _currentIds_.
   * ```javascript
   * JSV.uniqueName('CDS', ['RNA', 'CDS']);
   * //=> 'CDS-2'
   * ```
   * @param {String} name - Name to check
   * @param {Array} allNames - Array of all names to compare against
   * @return {String}
   */
  function uniqueName(name, allNames) {
    if (allNames.includes(name)) {
      return uniqueId(`${name}-`, 2, allNames);
    } else {
      return name;
    }
  }
  /**
   * Returns a string id using the _idBase_ and _start_ while
   * making sure the id is not in _currentIds_.
   * ```javascript
   * JSV.uniqueId('spectra_', 1, ['spectra_1', 'spectra_2']);
   * //=> 'spectra_3'
   * ```
   * @param {String} idBase - Base of ids
   * @param {Integer} start - Integer to start trying to creat ids with
   * @param {Array} currentIds - Array of current ids
   * @return {String}
   */
  function uniqueId(idBase, start, currentIds) {
    let id;
    do {
      id = idBase + start;
      start++;
    } while (currentIds.indexOf(id) > -1);
    return id;
  }
  // Basic testing shows that Method #2 is faster
  // Using E.Coli PA2 as a test case:
  // Times are for full parsing of the file
  // Method #1: ~500ms
  // Method #2: ~420ms
  function reverse(string) {
    // Method #1
    // return string.split("").reverse().join("");
    // Method #2
    let reversed = '';
    for (let i = string.length - 1; i >= 0; i--) {
      reversed += string[i];
    }
    return reversed;
  }

  function isASCII(text) {
    return /^[\x00-\x7F]*$/.test(text);
  }

  // May not be very fast
  // https://medium.com/@marco.amato/playing-with-javascript-performances-and-dna-cb0270ad37c1
  function complement(dna) {
    const table = {
        'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'U': 'A', 'R': 'Y', 'Y': 'R', 'S': 'S', 'W': 'W',
        'K': 'M', 'M': 'K', 'B': 'V', 'D': 'H', 'H': 'D', 'V': 'B', 'N': 'N', 
        'a': 't', 'c': 'g', 'g': 'c', 't': 'a', 'u': 'a', 'r': 'y', 'y': 'r', 's': 's', 'w': 'w',
        'k': 'm', 'm': 'k', 'b': 'v', 'd': 'h', 'h': 'd', 'v': 'b', 'n': 'n'
    };

    return dna.split('').map(char => table[char] || char).join('');
  }


    // OLD PROKSEE METHOD
    // _seqMolType(seq) {
    //   const nonDNASeq = seq.replace(/[AGCTN\-]/gi, '');
    //   return ( (nonDNASeq.length / seq.length) > 0.25 ) ? 'protein' : 'dna';
    // }
    // NOTE we may need to be less stringent with dna check (like above)
    // - allow n's and -'s
    function determineSeqMolType(sequence) {
      let type;
      const commonDNAChars = "ATGC";
      const commonProteinChars = "ACDEFGHIKLMNPQRSTVWY";
      const seqLength = sequence.length;
      const numCommonDNAChars = countCharactersInSequence(sequence, commonDNAChars);
      if ( (numCommonDNAChars / seqLength) > 0.9) {
        type = 'dna';
      } else {
        const numCommonProteinChars = countCharactersInSequence(sequence, commonProteinChars);
        if ( (numCommonProteinChars / seqLength) > 0.9) {
          type = 'protein';
        } else {
          type = 'unknown';
        }
      }
      return type;
    }

    function findNonIUPACCharacters(seq, type) {
      const seqType = type.toLowerCase();
      let chars;
      if (seqType === 'dna') {
        const nonIUPAC = seq.replace(/[AGCTURYSWKMBDHVN\-\.]/gi, '');
        if (nonIUPAC.length > 0) {
          chars = Array.from(new Set([...nonIUPAC])).join(',');
        }
      } else if (seqType === 'protein') {
        const nonIUPAC = seq.replace(/[ARNDCQEGHILKMFPOSUTWYVBZJ\-\.\*]/gi, '');
        if (nonIUPAC.length > 0) {
          chars = Array.from(new Set([...nonIUPAC])).join(',');
        }
      }
      return chars;
    }

  // Args:
  // - sequence (upper or lower case) is a string of the sequence to count characters in
  // - characters (upper case) is a string of the individual characters (not pattern) to count
  //   (e.g. "A", "AT", "ATGC", "ATGCN", "ATCG.-")
  // Note about speed.
  // - I've tested sevaral methods and this one is the fastest.
  // - The other methods are below for reference (ranked by speed)
  // - Speed is based on the parse test page for E.Coli PA2
  // - The speed is the total parse time (in orange on the test page)
  // Speeds
  // - base speed (no countCharactersInSequence): ~190ms
  // - selected method (using Set and for loop): ~330ms (~140ms slower than base speed)
  // - regex: ~700ms (~510ms slower than base speed)
  // - split(regex): ~840ms (~650ms slower than base speed)
  // - includes: ~930ms (~740ms slower than base speed)
  function countCharactersInSequence(sequence, characters) {
    const seq = sequence.toUpperCase();
    const charsSet = new Set(characters.split(""));
    let count = 0;
    for (let i=0, len=seq.length; i < len; i++) {
      if (charsSet.has(seq[i])) {
        count++;
      }
    }
    return count;
  }
  // - regex is pretty damn slow: ~700ms (adds ~500ms to Ecoli PA2 parsing time from 190ms to 700ms)
  // export function countCharactersInSequence(sequence, characters) {
  //   const regString = `[${characters}]`
  //   const regex = new RegExp(regString, "gi");
  //   return (sequence.match(regex) || []).length;
  //   // const regex = new RegExp(regString, "g");
  //   // const seq = sequence.toUpperCase();
  //   // return (seq.match(regex) || []).length;
  // }
  // This one is still slow: ~840ms
  // export function countCharactersInSequence(sequence, characters) {
  //   const regString = `[${characters}]`
  //   const regex = new RegExp(regString, "gi");
  //   return (sequence.split(regex).length - 1);
  // }
  // This one is even slower: ~930ms
  // export function countCharactersInSequence(sequence, characters) {
  //   const seq = sequence.toUpperCase();
  //   const chars = characters.toUpperCase().split("");
  //   let count = 0;
  //   for (let i=0, len=seq.length; i < len; i++) {
  //     if (chars.includes(seq[i])) {
  //       count++;
  //     }
  //   }
  //   return count;
  // }

  // OPTIONS:
  // - config: jsonConfig
  // - skipTypes: boolean (TEST) [Default: ['gene', 'source', 'exon']]
  //   - If false, include ALL feature types in the JSON
  // - includeQualifiers: boolean (not implemented yet) [Defualt: false]
  //   - If true, include ALL qualifiers in the JSON
  //   - If array of strings, include only those qualifiers
  //   - ADD TEST FOR THIS
  // - skipComplexLocations: boolean (not implemented yet) [Defualt: true]

  // LOGGING (including from sequence file)
  // - start with date and version (and options: skipTypes, includeQualifiers, skipComplexLocations)
  // - provide summary of CGView JSON (contigs, features, tracks, legends)
  // - total number of features skipped

  // TODO:
  // - FAIL if sequence type is protein
  // - better binary check see example proksee5.txt
  // - add name to CGView JSON summary
  // - Read over cgview_builder.rb script
  // - genetic code, codon_start

  class SeqRecordsToCGVJSON {

    constructor(seqRecords, options = {}) {
      this.version = "1.6.0";
      this.options = options;
      this.logger = options.logger || new Logger();
      this.seqRecords = seqRecords;
      this.inputType = seqRecords && seqRecords[0]?.inputType;
      this.defaultTypesToSkip = ['gene', 'source', 'exon'];

      this.json = this._convert(seqRecords);
    }

    _convert(seqRecords) {
      // this.logger.info(`Converting ${seqRecord.length} sequence record(s) to CGView JSON (version ${this.version})`);
      this._skippedFeaturesByType = {};
      this._skippedComplexFeatures = [];
      this.logger.info(`Date: ${new Date().toUTCString()}`);
      this.logger.info(`Converting to CGView JSON...`);
      this.logger.info(`- CGView JSON version ${this.version}`);
      this.logger.info(`- Input Sequence Count: ${seqRecords.length}`);
      // Here json refers to the CGView JSON
      let json = this._addConfigToJSON({}, this.options.config); 
      // Version: we should keep the version the same as the latest for CGView.js
      json.version = this.version;
      this._adjustContigNames(seqRecords);
      json = this._extractSequenceAndFeatures(json, seqRecords);
      this._summarizeSkippedFeatures();
      json.name = json.sequence?.contigs[0]?.name || "Untitled";
      json = this._removeUnusedLegends(json);
      // Add track for features (if there are any)
      json.tracks = this._buildTracks(json, this.inputType);
      this._convertSummary(json);
      return { cgview: json };
    }

    _convertSummary(json) {
      const contigs = json.sequence?.contigs || [];
      const contigCount = contigs.length || 0;
      const featureCount = json.features?.length || 0;
      const trackCount = json.tracks?.length || 0;
      const legendCount = json.legend?.items?.length || 0;
      const seqLength = contigs.map((contig) => contig.length).reduce((a, b) => a + b, 0);
      let skippedFeatures = Object.values(this._skippedFeaturesByType).reduce((a, b) => a + b, 0);
      skippedFeatures += this._skippedComplexFeatures.length;
      this.logger.break('------------------------------------------\n');
      this.logger.info('CGView JSON Summary:');
      this.logger.info(`- Contig Count: ${contigCount.toLocaleString().padStart(15)}`);
      this.logger.info('- Total Length (bp): ' + `${seqLength.toLocaleString()}`.padStart(10));
      this.logger.info(`- Track Count: ${trackCount.toLocaleString().padStart(16)}`);
      this.logger.info(`- Legend Count: ${legendCount.toLocaleString().padStart(15)}`);
      this.logger.info(`- Features Included: ${featureCount.toLocaleString().padStart(10)}`);
      this.logger.info(`- Features Skipped: ${skippedFeatures.toLocaleString().padStart(11)}`);
      this.logger.break('------------------------------------------\n');
    }

    _summarizeSkippedFeatures() {
      // Skipped Types
      const skippedFeatures = this._skippedFeaturesByType;
      const skippedFeatureCount = Object.values(this._skippedFeaturesByType).reduce((a, b) => a + b, 0);
      if (Object.keys(skippedFeatures).length > 0) {
        this.logger.info(`- Skipped features (${skippedFeatureCount}) by type:`);
        for (const [key, value] of Object.entries(skippedFeatures)) {
          this.logger.info(`  - ${key}: ${value.toLocaleString().padStart(15 - key.length)}`);
        }
      }
      // Complex Locations
      const complexFeatures = this._skippedComplexFeatures;
      const complexCount = complexFeatures.length;
      if (complexCount > 0) {
        const exampleCount = Math.min(5, complexFeatures.length);
        this.logger.info(`- Skipped features (${complexCount}) with complex locations:`);
        complexFeatures.slice(0, exampleCount).forEach(f => this.logger.info(`  - ${f.type} '${f.name}': ${f.locationText}`));
        if (complexCount > exampleCount) {
          this.logger.info(`  - ${complexCount - exampleCount} more not shown (${complexCount.toLocaleString()} total)`);
        }
      }

    }

    // Add config to JSON. Note that no validation of the config is done.
    _addConfigToJSON(json, config) {
      const configKeys = config ? Object.keys(config) : ['none'];
      this.logger.info(`- Config properties provided: ${configKeys.join(', ')}`);

      if (!config) { return json; }
      if (config.settings) { json.settings = config.settings; }
      if (config.backbone) { json.backbone = config.backbone; }
      if (config.ruler) { json.ruler = config.ruler; }
      if (config.dividers) { json.dividers = config.dividers; }
      if (config.annotation) { json.annotation = config.annotation; }
      if (config.sequence) { json.sequence = config.sequence; }
      if (config.legend) { json.legend = config.legend; }
      if (config.tracks) { json.tracks = config.tracks; }
      return json;
    }

    // Adjust contig names:
    // - to be unique by adding a number to the end of duplicate names
    // - replace nonstandard characters with underscores
    // - length of contig names should be less than 37 characters

    _adjustContigNames(seqRecords) {
      const names = seqRecords.map((seqRecord) => seqRecord.name);
      const adjustedNameResults = SeqRecordsToCGVJSON.adjustContigNames(names);
      const adjustedNames = adjustedNameResults.names;
      const reasons = adjustedNameResults.reasons;
      this.logger.info('- Checking contig names...');
      const changedNameIndexes = Object.keys(reasons);
      if (changedNameIndexes.length > 0) {
        // Chnage SeqRecord names
        seqRecords.forEach((seqRecord, i) => {
          seqRecord.name = adjustedNames[i];
        });
        // Log details
        this.logger.info(`The following contig names (${changedNameIndexes.length}) were adjusted:`);
        this.logger.info(`Reasons: DUP (duplicate), LONG (>34), REPLACE (nonstandard characters)`);
        changedNameIndexes.forEach((i) => {
          const reason = reasons[i];
          this.logger.warn(`- [${reason.index + 1}] ${reason.origName} -> ${reason.newName} (${reason.reason.join(', ')})`);
        });
      }
    }

    // Given an array of sequence names, returns an object with:
    // - names: an array of corrected sequence names
    // - reasons: an array of object reasons for the correction:
    //   - index: the index of the name in the original array
    //   - origName: the original name
    //   - newName: the corrected name
    //   - reason: the reason for the correction
    //     (e.g. "duplicate", "too long", "nonstandard characters")
    //     (e.g. "DUP", "LONG", "REPLACE")
    static adjustContigNames(names=[]) {
      console.log(names);
      const reasons = {};
      // Replace nonstandard characters
      let replacedNames = names.map((name) => name.replace(/[^a-zA-Z0-9\*\_\-]+/g, '_'));
      names.forEach((name, i) => {
        if (name !== replacedNames[i]) {
          reasons[i] = {index: i, origName: name, newName: replacedNames[i], reason: ["REPLACE"]};
        }
      });
      // Shorten names
      replacedNames.forEach((name, i) => {
        if (name.length > 34) {
          replacedNames[i] = name.slice(0, 34);
          if (reasons[i]) {
            reasons[i].newName = replacedNames[i];
            reasons[i].reason.push("LONG");
          } else {
            reasons[i] = {index: i, origName: name, newName: replacedNames[i], reason: ["LONG"]};
          }
        }
      });
      // Make names unique
      const finalNames = [];
      replacedNames.forEach((name, i) => {
        const newName = uniqueName(name, finalNames);
        finalNames.push(newName);
        if (newName !== name) {
          if (reasons[i]) {
            reasons[i].newName = newName;
            reasons[i].reason.push("DUP");
          } else {
            reasons[i] = {index: i, origName: name, newName: newName, reason: ["DUP"]};
          }
        }
      });

      return {names: finalNames, reasons: Object.values(reasons)};
    }

    // TODO: contig names MUST BE UNIQUE
    _extractSequenceAndFeatures(json, seqJson) {
      const contigs = [];
      const features = [];
      this._skippedTypesSetup();
      seqJson.forEach((seqRecord) => {
        contigs.push({name: seqRecord.name, length: seqRecord.sequence.length, seq: seqRecord.sequence});
        const contigFeatures = this._extractFeatures(seqRecord, seqRecord.name, seqRecord.inputType);
        features.push(...contigFeatures);
      });
      json.sequence = {contigs};
      json.features = features;
      return json;
    }

    _skippedTypesSetup() {
      const options = this.options;
      if (options.skipTypes === false) {
        this.featuresToSkip = [];
      } else if (Array.isArray(options.skipTypes)) {
        this.featuresToSkip = options.skipTypes;
      } else {
        this.featuresToSkip = this.defaultTypesToSkip;
      }
      const skipTypes = this.featuresToSkip.length === 0 ? "none" : this.featuresToSkip.join(', ');
      this.logger.info(`- Feature types to skip: ${skipTypes}`);
    }

    // Onlys adds a Features track if there are features
    // Other tracks may come from the config (in which case they are already added to the JSON)
    _buildTracks(json, inputType) {
      const tracks = json.tracks || [];
      if (json.features && json.features.length > 0) {
        tracks.push({
          name: 'Features',
          separateFeaturesBy: 'strand',
          position: 'both',
          dataType: 'feature',
          dataMethod: 'source',
          dataKeys: `${inputType}-features`,
        });
      }
      return tracks;
    }

    // TODO: Remove legends from config that are not used
    _removeUnusedLegends(json) {
      const legendItems = json.legend?.items || [];
      if (legendItems.length === 0) { return json; }
      const featureLegends = json.features?.map((f) => f.legend) || [];
      const uniqueFeatureLegends = [...new Set(featureLegends)];
      const filteredLegendItems = legendItems.filter((i) => uniqueFeatureLegends.includes(i.name));
      json.legend.items = filteredLegendItems;
      return json
    }

    _extractFeatures(seqContig, contigName, inputType) {
      const features = [];
      // const skippedFeatures = {};
      // const complexFeatures = [];
      const source = inputType ? `${inputType}-features` : "features";
      for (const f of seqContig.features) {
        if (this.featuresToSkip.includes(f.type)) {
          this._skippedFeaturesByType[f.type] = this._skippedFeaturesByType[f.type] ? this._skippedFeaturesByType[f.type] + 1 : 1;
          continue;
        }
        if (f.locations.length > 1) {
          this._skippedComplexFeatures.push(f);
          continue;
        }
        // NEED TO LOG
        const feature = {
          start: f.start,
          stop: f.stop,
          strand: f.strand,
          name: f.name,
          type: f.type,
          contig: contigName,
          source,
          legend: f.type,
        };
        if (f.qualifiers && f.qualifiers.start_codon && f.qualifiers.start_codon[0] !== 1) {
          feature.start_codon = f.qualifiers.start_codon[0];
        }
        features.push(feature);
      }    return features;
    }

  }

  // Holds a sequence and feature from a sequence file: genbank, embl, fasta, raw
  // Parses text from sequence file
  // Holds seq records from our parser
  // Array of sequence records containing array of features


  class SequenceFile {

    // Options:
    // - addFeatureSequences: boolean [Default: false]. This can increase run time ~3x.
    // - logger: logger object
    constructor(inputText, options={}) {
      this.inputText;
      this.logger = options.logger || new Logger();
      options.logger = this.logger;
      this.logger.info(`Date: ${new Date().toUTCString()}`);
      this._success = true;
      this._records = [];
      if (!inputText || inputText === '') {
        this._fail('Parsing Failed: No input text provided.');
      } else if (!isASCII(inputText)) {
        this._fail('Parsing Failed: Input contains non-text characters. Is this binary data?');
      } else {
        this._records = this._parse(inputText, options);
        if (options.addFeatureSequences) {
          this._addFeatureSequence(this._records);
        }
        this._determineSequenceTypes(this._records);
        this._determineOverallInputAndSequenceType(this._records);
        this.logger.info('- done parsing sequence file');
        this._validateRecords(this._records);
        this.parseSummary();
      }
      this.logger.break();
    }

    /////////////////////////////////////////////////////////////////////////////
    // Properties
    /////////////////////////////////////////////////////////////////////////////

    get success() {
      return this._success;
    }

    get inputType() {
      return this._inputType;
    }

    get sequenceType() {
      return this._sequenceType;
    }

    // { inputType, sequenceType, sequenceCount, featureCount, totalLength, success }
    get summary() {
      return this._summary;
    }

    /////////////////////////////////////////////////////////////////////////////
    // EXPORTERS
    /////////////////////////////////////////////////////////////////////////////

    toCGVJSON(options={}) {
      if (this.success) {
        options.logger = options.logger || this.logger;
        const parser = new SeqRecordsToCGVJSON(this.records, options);
        return parser.json;
      } else {
        this.logger.error('*** Cannot convert to CGView JSON because parsing failed ***');
      }
    }

    get records() {
      return this._records;
    }

    /////////////////////////////////////////////////////////////////////////////
    // SUMMARY
    /////////////////////////////////////////////////////////////////////////////

    parseSummary() {
      const records = this.records;
      const features = records.map((record) => record.features).flat();
      const seqLength = records.map((record) => record.length).reduce((a, b) => a + b, 0);

      this.logger.break('------------------------------------------\n');
      this.logger.info('Parsing Summary:');
      this.logger.info(`- Input file type: ${this.inputType.padStart(12)}`);
      this.logger.info(`- Sequence Type: ${this.sequenceType.padStart(14)}`);
      this.logger.info(`- Sequence Count: ${records.length.toLocaleString().padStart(13)}`);
      this.logger.info(`- Feature Count: ${features.length.toLocaleString().padStart(14)}`);
      this.logger.info('- Total Length (bp): ' + `${seqLength.toLocaleString()}`.padStart(10));
      if (this.success) {
        this.logger.info('- Status: ' + 'Success'.padStart(21), {icon: 'success'});
      } else {
        this.logger.error('- Status: ' + 'FAILED'.padStart(21), {icon: 'fail'});
      }
      this.logger.break('------------------------------------------\n');

      this._summary = {
        inputType: this.inputType,
        sequenceType: this.sequenceType,
        sequenceCount: records.length,
        featureCount: features.length,
        totalLength: seqLength,
        success: this.success
      };
    }

    /////////////////////////////////////////////////////////////////////////////
    // INITIAL PARSERS
    /////////////////////////////////////////////////////////////////////////////

    _parse(seqText, options={}) {
      this.logger.info("Parsing sequence file...");
      // Attempt to parse as genbank or embl first
      let records = this._parseGenbankOrEmbl(seqText, options);
      // If that fails, try to parse as fasta or raw
      if ((records.length === 0) ||
          (records[0].name === '' && records[0].length === 0  && records[0].sequence === '')) {
        this.logger.info("- empty results");
        if (/^\s*>/.test(seqText)) {
          this.logger.info("- attempting as FASTA...");
          records = this._parseFasta(seqText, options);
        } else {
          this.logger.info("- attempting as raw...");
          records = this._parseRaw(seqText, options);
        }
      }
      return records;
    }

    _parseGenbankOrEmbl(seqText, options={}) {
      const records = [];
      this.logger.info("- attempting as GenBank or EMBL...");
      seqText.split(/^\/\//m).filter(this._isSeqRecord).forEach((seqRecord) => {
        const record = {inputType: 'unknown'};
        if (/^\s*LOCUS|^\s*FEATURES/m.test(seqRecord)) {
          record.inputType = 'genbank';
        } else if (/^\s*ID|^\s*SQ/m.test(seqRecord)) {
          record.inputType = 'embl';
        }
        record.name = this._getSeqName(seqRecord);
        record.length = this._getSeqLength(seqRecord);
        record.sequence = this._getSequence(seqRecord);
        if (!record.length) {
          record.length = record.sequence.length;
        }
        record.features = this._getFeatures(seqRecord);
        records.push(record);
      });
      return records;
    }

    _parseFasta(seqText, options={}) {
      console.log("Parsing FASTA...");
      const records = [];
      seqText.split(/^\s*>/m).filter(this._isSeqRecord).forEach((seqRecord) => {
        const record = {inputType: 'fasta', name: '', length: 0, sequence: ''};
        const match = seqRecord.match(/^\s*([^\n\r]+)(.*)/s);
        if (match) {
          record.name = match[1];
          record.sequence = removeWhiteSpace(removeDigits(match[2]));
          record.length = record.sequence.length;
          record.features = [];
        }
        records.push(record);
      });
      return records;
    }

    _parseRaw(seqText, options={}) {
      const record = {inputType: 'raw', name: '', features: []};
      record.sequence = removeWhiteSpace(removeDigits(seqText));
      record.length = record.sequence.length;
      return [record];
    }

    /////////////////////////////////////////////////////////////////////////////
    // SEQUENCE - this could become a class
    /////////////////////////////////////////////////////////////////////////////

    // Return FALSE if sequence record appears to be empty, e.g. just // or blank line
    _isSeqRecord(seqRecord) {
      if (/^\s*\/\/\s*$/.test(seqRecord)) {
        return false;
      } else if (/^\s*$/.test(seqRecord)) {
        return false
      } else {
        return true;
      }
    }

    // Get a sequence name from a GenBank or EMBL record
    // in GenBank look for e.g.:
    // LOCUS       AF177870     3123 bp    DNA             INV       31-OCT-1999
    // in EMBL look for e.g.:
    // ID   AF177870; SV 1; linear; genomic DNA; STD; INV; 3123 BP.
    // name is AF177870
    _getSeqName(seqRecordText) {
      const match = seqRecordText.match(/^\s*(?:LOCUS|ID)\s*(\S+)/);
      if (match) {
        let name = match[1];
        // Remove trailing ';' from embl files
        name = name.replace(/;$/, "");
        return name
      } else {
        return "";
      }
    }

    // Get a sequence length from a GenBank or EMBL record
    // in GenBank look for e.g.:
    // LOCUS       AF177870     3123 bp    DNA             INV       31-OCT-1999
    // in EMBL look for e.g.:
    // ID   AF177870; SV 1; linear; genomic DNA; STD; INV; 3123 BP.
    // length is 3123
    // Returns 0 if it can't be parsed
    _getSeqLength(seqRecordText) {
      const match = seqRecordText.match(/^\s*(?:LOCUS|ID).*?(\d+)\s[Bb][Pp]/);
      if (match) {
        return parseInt(match[1]);
      } else {
        return 0;
      }
    }

    // Get the full sequence from a GenBank or EMBL record
    // in GenBank look for e.g.:
    // ORIGIN
    //        1 ttttgccctc agtccgtgac ggcgcaggct ttccgtcacg gtttttactt taaaatggta
    // in EMBL look for e.g.:
    // SQ   Sequence 3123 BP; 986 A; 605 C; 597 G; 935 T; 0 other;
    //     gaacgcgaat gcctctctct ctttcgatgg gtatgccaat tgtccacatt cactcgtgtt        60
    _getSequence(seqRecordText) {
      const match = seqRecordText.match(/^(?:ORIGIN|SQ\s{3}).*?$([^\/]*)(^\s*$|^\s*LOCUS)?/ms);
      if (match) {
        return removeDigits(removeWhiteSpace(match[1]));
      } else {
        return "" 
      }
    }


    /////////////////////////////////////////////////////////////////////////////
    // FEATURES - this could become a class
    /////////////////////////////////////////////////////////////////////////////

    // Get an array of objects containing feature information from a GenBank or EMBL record
    // in GenBank look for:
    // FEATURES             Location/Qualifiers
    // in EMBL look for:
    // FH   Key             Location/Qualifiers
    // FH
    _getFeatures(seqRecordText) {
      const features = [];
      const match = seqRecordText.match(/^(?:FEATURES.*?$|FH.*?^FH.*?$)(.*)^(?:ORIGIN|SQ\s{3}).*?$/ms);
      if (match) {
        // this.logger.info("- parsing features...")
        let featureAllText = match[1];
        // Replace FT from the start of EMBL lines with 2 spaces
        featureAllText = featureAllText.replaceAll(/^FT/mg, "  ");
        featureAllText.split(/(?=^\s{5}\S+)/m).filter(this._isFeatureRecord).forEach((featureText) => {
          const feature = {};
          feature.type = this._getFeatureType(featureText);
          feature.strand = this._getFeatureStrand(featureText);
          feature.locationText = this._getFeatureLocationText(featureText);
          feature.locations = this._getFeatureLocations(feature.locationText);
          feature.start = feature.locations.map((location) => location[0]).sort((a, b) => a - b)[0];
          feature.stop = feature.locations.map((location) => location[1]).sort((a, b) => b - a)[0];
          feature.qualifiers = this._getFeatureQualifiers(featureText);
          feature.name = this._getFeatureName(feature.qualifiers);
          if (feature.type) {
            features.push(feature);
          }
        });
      }
      return features
    }

    // Return FALSE if feature appears to be empty, e.g. just / or blank line
    _isFeatureRecord(featureText) {
      if (/^\s*\/\s*$/.test(featureText)) {
        return false;
      } else if (/^\s*$/.test(featureText)) {
        return false
      } else {
        return true;
      }
    }

    // Get type of a feature from a feature string
    // e.g.
    //      gene            complement(<1..>172)
    //                      /locus_tag="ECPA2_RS30085"
    //                      /old_locus_tag="ECPA2_5227"
    //                      /pseudo
    _getFeatureType(featureText) {
      const match = featureText.match(/^\s{5}(\S+)/);
      if (match) {
        return match[1];
      } else {
        // TODO: Probably log this
        return null;
      }
    }

    // Get strand of a feature (1 or -1) from a feature string # e.g.
    //      gene            complement(<1..>172)
    //                      /locus_tag="ECPA2_RS30085"
    //                      /old_locus_tag="ECPA2_5227"
    //                      /pseudo
    // FIXME: What about joins?
    _getFeatureStrand(featureText) {
      const match = featureText.match(/^\s{5}\S+\s+complement/);
      return match ? -1 : 1;
    }

    // Get location text of a feature (1 or -1) from a feature string
    // e.g.
    //      gene            complement(<1..>172)
    //                      /locus_tag="ECPA2_RS30085"
    //                      /old_locus_tag="ECPA2_5227"
    //                      /pseudo
    _getFeatureLocationText(featureText) {
      const match = featureText.match(/^\s{5}\S+\s+([^\/]+)/s);
      if (match) {
        return removeWhiteSpace(match[1]);
      } else {
        return "";
      }
    }

    // Return an array of locations from a location string
    // FIXME: What about > and <?
    _getFeatureLocations(locationText) {
      const locations = [];
      const ranges = locationText.split(/(?=,)/).filter(this._isParsableFeatureRange);
      for (const range of ranges) {
        let match = range.match(/(\d+)\D*\.\.\D*(\d+)/);
        if (match) {
          const start = parseInt(match[1]);
          const end = parseInt(match[2]);
          locations.push([start, end]);
        } else {
          match = range.match(/(\d+)/);
          if (match) {
            const start = parseInt(match[1]);
            const end = start;
            locations.push([start, end]);
          }
        }
      }
      return locations;
    }

    // Return FALSE if feature range is of a type that cannot be converted to a start and end
    // examples of ranges that cannot be converted to start and end:
    // 102.110
    // 123^124
    // J00194.1:100..202
    // join(1..100,J00194.1:100..202)
    _isParsableFeatureRange(range) {
      if (/\d\.\d/.test(range)) {
        return false;
      } else if (/\^/.test(range)) {
        return false;
      } else if (/:/.test(range)) {
        return false;
      } else if (/^\s*$/.test(range)) {
        return false;
      } else {
        return true;
      }
    }

    // Return FALSE if feature qualifier appears to be empty, e.g. just / or blank line
    _isFeatureQualifier(qualifierText) {
      if (/^\s*\/\s*$/.test(qualifierText)) {
        return false;
      } else if (/^\s*$/.test(qualifierText)) {
        return false
      } else {
        return true;
      }
    }

    // Format feature qualifier value by removing newlines if there are no spaces within the value
    // otherwise replace newlines with spaces
    _formatFeatureQualifier(qualifierText) {
      if (/\S\s\S/.test(qualifierText)) {
        return qualifierText.replace(/[\s]+/g, " ");
      } else {
        return qualifierText.replace(/[\s]+/g, "");
      }
    }

    // Get an array of objects containing feature qualifier names and values from a feature string
    // e.g.
    //      gene            complement(<1..>172)
    //                      /locus_tag="ECPA2_RS30085"
    //                      /old_locus_tag="ECPA2_5227"
    //                      /pseudo
    _getFeatureQualifiers(featureText) {
      const qualifiers = {};
      let match = featureText.match(/(\/.*)/s);
      if (match) {
        const allQualifierText = match[1];
        allQualifierText.split(/(?=^\s*\/)/m).filter(this._isFeatureQualifier).forEach((qualifierText) => {
          let name;
          let value;
          match = qualifierText.match(/\/([^\"\s]+)\s*=\s*\"?([^\"]*)\"?(?=^\s*\/|$)/ms);
          if (match) {
            name = match[1];
            value = this._formatFeatureQualifier(match[2]);
          } else {
            name = removeWhiteSpace(qualifierText);
            value = "";
          }
          if (qualifiers[name]) {
            qualifiers[name].push(value);
          } else {
            qualifiers[name] = [value];
          }
        });
      }
      return qualifiers;
    }

    _getFeatureName(qualifiers) {
      if (qualifiers?.gene) {
        return qualifiers.gene[0];
      } else if (qualifiers?.locus_tag) {
        return qualifiers.locus_tag[0];
      } else if (qualifiers?.product) {
        return qualifiers.product[0];
      } else if (qualifiers?.note) {
        return qualifiers.note[0];
      } else if (qualifiers?.db_xref) {
        return qualifiers.db_xref[0];
      } else {
        return "";
      }
    }

    // Optional
    _addFeatureSequence(seqRecords) {
      for (const seqRecord of seqRecords) {
        for (const feature of seqRecord.features) {
          const dna = [];
          for (const location of feature.locations) {
            const start = location[0];
            const end = location[1];
            dna.push(seqRecord.sequence.slice(start-1, end));
            // ERROR CHECK
          }
          if (feature.strand === -1) {
            feature.sequence = reverse(complement(dna.join("")));
          } else {
            feature.sequence = dna.join("");
          }
        }
      }
    }


    // Try to determine whether the sequence in each record is DNA or protein
    // and whether there are unexpected characters in sequence
    _determineSequenceTypes(seqRecords) {
      for (const seqRecord of seqRecords) {
        const sequence = seqRecord.sequence;
        seqRecord.type = determineSeqMolType(sequence);
        const nonIUPAC = findNonIUPACCharacters(sequence, seqRecord.type);
        if (nonIUPAC) {
          seqRecord.hasUnexpectedCharacters = nonIUPAC;
        }
      }
    }

    _determineOverallInputAndSequenceType(records) {
      const inputTypes = records.map((record) => record.inputType);
      const uniqueInputTypes = [...new Set(inputTypes)];
      this._inputType = (uniqueInputTypes.length > 1) ? 'multiple' : uniqueInputTypes[0];

      const seqTypes = records.map((record) => record.type);
      const uniqueSeqTypes = [...new Set(seqTypes)];
      this._sequenceType = (uniqueSeqTypes.length > 1) ? 'multiple' : uniqueSeqTypes[0];
    }

    _fail(message) {
      this.logger.error(message);
      this._success = false;
    }

    // Simple way to pluralize a phrase
    // e.g. _pluralizeHasHave(1) => 's has'
    // _pluralizeHasHave(count, singular, plural) {
    //   return count === 1 ? singular : plural;
    // }

    _validateRecords(records) {
      this.logger.info('Validating...');

      // Input Type
      if (this.inputType === 'multiple') {
        const inputTypes = records.map((record) => record.inputType);
        const uniqueInputTypes = [...new Set(inputTypes)];
        this._fail(`Input file contains multiple input types: ${uniqueInputTypes.join(', ')}`);
      }
      // Sequence Type
      if (this.sequenceType === 'multiple') {
        const seqTypes = records.map((record) => record.type);
        const uniqueSeqTypes = [...new Set(seqTypes)];
        this._fail(`Input file contains multiple sequence types: ${uniqueSeqTypes.join(', ')}`);
      }
      if (this.sequenceType === 'unknown') {
        this._fail(`Input file contains an unknown sequence type (i.e. not dna or protein).`);
      }
      // Sequence length is 0
      const recordsZeroLength = records.filter((record) => record.length === 0);
      if (recordsZeroLength.length > 0) {
        const count = recordsZeroLength.length.toLocaleString();
        this._fail(`The following sequences (${count}) have zero length:`);
        this._fail(`- ${recordsZeroLength.map((record) => record.name).join(', ')}`);
      }
      // Sequence lengths do not match length in sequence
      const recordsDiffLengths = records.filter((record) => record.length !== record.sequence.length);
      if (recordsDiffLengths.length > 0) {
        const count = recordsDiffLengths.length.toLocaleString();
        this._fail(`The following sequences (${count}) have mismatched lengths (length attribute vs sequence length):`);
        for (const record of recordsDiffLengths) {
          this.logger.error(`- ${record.name}: ${record.length.toLocaleString()} bp vs ${record.sequence.length.toLocaleString()} bp`);
        }
      }
      // Sequence contains unexpected characters
      const recordsUnexpectedChars = records.filter((record) => record.hasUnexpectedCharacters);
      if (recordsUnexpectedChars.length > 0) {
        const count = recordsUnexpectedChars.length.toLocaleString();
        this._fail(`The following sequences (${count}) contain unexpected characters:`);
        for (const record of recordsUnexpectedChars) {
          this.logger.error(`- ${record.name}: ${record.hasUnexpectedCharacters}`);
        }
      }
      // Features start or end/stop is greater than sequence length
      // Features end is less than start
      // - NOTE: we may want to allow features that wrap around the sequence
      const featureStartEndErrors = [];
      const featureStartGreaterThanEnd = [];
      for (const record of records) {
        for (const feature of record.features) {
          if (feature.start > record.length || feature.stop > record.length) {
            // featureStartEndErrors.push(`${record.name} [${record.length.toLocaleString()} bp]: ${feature.name} ${feature.start}..${feature.stop}`);
            featureStartEndErrors.push(`${record.name} [${record.length.toLocaleString()} bp]: '${feature.name}' [${feature.start}..${feature.stop}]`);
          }
          if (feature.start > feature.stop) {
            featureStartGreaterThanEnd.push(`${record.name}: '${feature.name}' [${feature.start}..${feature.stop}]`);
          }
        }
      }
      if (featureStartEndErrors.length > 0) {
        const count = featureStartEndErrors.length.toLocaleString();
        this._fail(`The following features (${count}) have start or end greater than the sequence length:`);
        featureStartEndErrors.forEach((error) => this.logger.error(`- ${error}`));
      }
      if (featureStartGreaterThanEnd.length > 0) {
        const count = featureStartGreaterThanEnd.length.toLocaleString();
        this._fail(`The following features (${count}) have a start greater than the end:`);
        featureStartGreaterThanEnd.forEach((error) => this.logger.error(`- ${error}`));
      }

      if (this.success) {
        this.logger.info('- validations passed', {icon: 'success'});
      } else {
        this.logger.error('- validations failed', {icon: 'fail'});
      }
    }

  }

  class CGVParse {

    // constructor(input) {
    //   this.input = input;
    //   // this.logger = new Logger();
    // }

    // seq: string
    // options:
    // - config: jsonConfig
    // static seqToJSON(seq, options={}) {
    //   // TODO: add logger options to logger
    //   options.logger = new Logger();
    //   const seqJSON = this.seqToSeqJSON(seq, options);
    //   const cgvJSON = CGVParse.seqJSONToCgvJSON(seqJSON, options);
    //   return cgvJSON;
    // }

    // static seqToSeqJSON(seq, options={}) {
    //   options.logger = options.logger || new Logger();
    //   const seqRecords = this.parseSeqRecords(seq, options);
    //   return seqRecords;
    // }

    // static seqJSONToCgvJSON(seqJson, options={}) {
    //   options.logger = options.logger || new Logger();
    //   // Here json refers to the CGView JSON
    //   let json = this.addConfigToJSON({}, options.config); 
    //   // Version: we should keep the version the same as the latest for CGView.js
    //   json.version = "1.6.0";
    //   json = this.extractSequenceAndFeatures(json, seqJson);
    //   json.name = json.sequence?.contigs[0]?.name || "Untitled";
    //   json = this.removeUnusedLegends(json);
    //   // Add track for features (if there are any)
    //   json.tracks = this.buildTracks(json, seqJson[0].inputType);

    //   return { cgview: json };
    // }

  }

  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var _a, _b;
  const untitledSequenceName = "Untitled Sequence";
  const gbDivisions = {
    // https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html#GenBankDivisionB
    PRI: true,
    //- primate sequences
    ROD: true,
    //- rodent sequences
    MAM: true,
    //- other mammalian sequences
    VRT: true,
    //- other vertebrate sequences
    INV: true,
    //- invertebrate sequences
    PLN: true,
    //- plant, fungal, and algal sequences
    BCT: true,
    //- bacterial sequences
    VRL: true,
    //- viral sequences
    PHG: true,
    //- bacteriophage sequences
    SYN: true,
    //- synthetic sequences
    UNA: true,
    //- unannotated sequences
    EST: true,
    //- EST sequences (expressed sequence tags)
    PAT: true,
    //- patent sequences
    STS: true,
    //- STS sequences (sequence tagged sites)
    GSS: true,
    //- GSS sequences (genome survey sequences)
    HTG: true,
    //- HTG sequences (high-throughput genomic sequences)
    HTC: true,
    //- unfinished high-throughput cDNA sequencing
    ENV: true,
    //- environmental sampling sequences
    CON: true
    //- sequence assembly instructions on how to construct contigs from multiple GenBank records.
  };
  function createInitialSequence(options) {
    options = options || {};
    return {
      messages: [],
      success: true,
      parsedSequence: {
        features: [],
        name: options.fileName && options.fileName.replace(/\.[^/.]+$/, "") || untitledSequenceName,
        sequence: ""
      }
    };
  }
  __name(createInitialSequence, "createInitialSequence");
  function extractFileExtension(name) {
    if (typeof name === "string") {
      let ext = "";
      const match = name.match(/\.(\w+)$/);
      if (match && match[1]) {
        ext = match[1];
      }
      return ext;
    } else {
      return "";
    }
  }
  __name(extractFileExtension, "extractFileExtension");
  function splitStringIntoLines(string) {
    let lines = [];
    if (string === "") {
      return lines;
    } else {
      lines = string.split(/\r?\n/);
      if (lines.length == 1) {
        lines = string.split("\\n");
      }
      return lines;
    }
  }
  __name(splitStringIntoLines, "splitStringIntoLines");
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  __name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = /* @__PURE__ */ __name(function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      }, "a");
      a.prototype = f.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  __name(getAugmentedNamespace, "getAugmentedNamespace");
  function isArray$1(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
  }
  __name(isArray$1, "isArray$1");
  var lib$5 = Array.isArray || isArray$1;
  function isNumber$1(value) {
    return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
  }
  __name(isNumber$1, "isNumber$1");
  var lib$4 = isNumber$1;
  var isNumber = lib$4;
  function isInteger$1(value) {
    return isNumber(value) && value % 1 === 0;
  }
  __name(isInteger$1, "isInteger$1");
  var lib$3 = isInteger$1;
  var isInteger = lib$3;
  function isNonNegativeInteger$1(value) {
    return isInteger(value) && value >= 0;
  }
  __name(isNonNegativeInteger$1, "isNonNegativeInteger$1");
  var lib$2 = isNonNegativeInteger$1;
  var isArray = lib$5, isNonNegativeInteger = lib$2;
  function isNonNegativeIntegerArray(value) {
    var len;
    if (!isArray(value)) {
      return false;
    }
    len = value.length;
    if (!len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      if (!isNonNegativeInteger(value[i])) {
        return false;
      }
    }
    return true;
  }
  __name(isNonNegativeIntegerArray, "isNonNegativeIntegerArray");
  var lib$1 = isNonNegativeIntegerArray;
  const areNonNegativeIntegers = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['â€™]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "Ã€": "A",
        "Ã": "A",
        "Ã‚": "A",
        "Ãƒ": "A",
        "Ã„": "A",
        "Ã…": "A",
        "Ã ": "a",
        "Ã¡": "a",
        "Ã¢": "a",
        "Ã£": "a",
        "Ã¤": "a",
        "Ã¥": "a",
        "Ã‡": "C",
        "Ã§": "c",
        "Ã": "D",
        "Ã°": "d",
        "Ãˆ": "E",
        "Ã‰": "E",
        "ÃŠ": "E",
        "Ã‹": "E",
        "Ã¨": "e",
        "Ã©": "e",
        "Ãª": "e",
        "Ã«": "e",
        "ÃŒ": "I",
        "Ã": "I",
        "ÃŽ": "I",
        "Ã": "I",
        "Ã¬": "i",
        "Ã­": "i",
        "Ã®": "i",
        "Ã¯": "i",
        "Ã‘": "N",
        "Ã±": "n",
        "Ã’": "O",
        "Ã“": "O",
        "Ã”": "O",
        "Ã•": "O",
        "Ã–": "O",
        "Ã˜": "O",
        "Ã²": "o",
        "Ã³": "o",
        "Ã´": "o",
        "Ãµ": "o",
        "Ã¶": "o",
        "Ã¸": "o",
        "Ã™": "U",
        "Ãš": "U",
        "Ã›": "U",
        "Ãœ": "U",
        "Ã¹": "u",
        "Ãº": "u",
        "Ã»": "u",
        "Ã¼": "u",
        "Ã": "Y",
        "Ã½": "y",
        "Ã¿": "y",
        "Ã†": "Ae",
        "Ã¦": "ae",
        "Ãž": "Th",
        "Ã¾": "th",
        "ÃŸ": "ss",
        // Latin Extended-A block.
        "Ä€": "A",
        "Ä‚": "A",
        "Ä„": "A",
        "Ä": "a",
        "Äƒ": "a",
        "Ä…": "a",
        "Ä†": "C",
        "Äˆ": "C",
        "ÄŠ": "C",
        "ÄŒ": "C",
        "Ä‡": "c",
        "Ä‰": "c",
        "Ä‹": "c",
        "Ä": "c",
        "ÄŽ": "D",
        "Ä": "D",
        "Ä": "d",
        "Ä‘": "d",
        "Ä’": "E",
        "Ä”": "E",
        "Ä–": "E",
        "Ä˜": "E",
        "Äš": "E",
        "Ä“": "e",
        "Ä•": "e",
        "Ä—": "e",
        "Ä™": "e",
        "Ä›": "e",
        "Äœ": "G",
        "Äž": "G",
        "Ä ": "G",
        "Ä¢": "G",
        "Ä": "g",
        "ÄŸ": "g",
        "Ä¡": "g",
        "Ä£": "g",
        "Ä¤": "H",
        "Ä¦": "H",
        "Ä¥": "h",
        "Ä§": "h",
        "Ä¨": "I",
        "Äª": "I",
        "Ä¬": "I",
        "Ä®": "I",
        "Ä°": "I",
        "Ä©": "i",
        "Ä«": "i",
        "Ä­": "i",
        "Ä¯": "i",
        "Ä±": "i",
        "Ä´": "J",
        "Äµ": "j",
        "Ä¶": "K",
        "Ä·": "k",
        "Ä¸": "k",
        "Ä¹": "L",
        "Ä»": "L",
        "Ä½": "L",
        "Ä¿": "L",
        "Å": "L",
        "Äº": "l",
        "Ä¼": "l",
        "Ä¾": "l",
        "Å€": "l",
        "Å‚": "l",
        "Åƒ": "N",
        "Å…": "N",
        "Å‡": "N",
        "ÅŠ": "N",
        "Å„": "n",
        "Å†": "n",
        "Åˆ": "n",
        "Å‹": "n",
        "ÅŒ": "O",
        "ÅŽ": "O",
        "Å": "O",
        "Å": "o",
        "Å": "o",
        "Å‘": "o",
        "Å”": "R",
        "Å–": "R",
        "Å˜": "R",
        "Å•": "r",
        "Å—": "r",
        "Å™": "r",
        "Åš": "S",
        "Åœ": "S",
        "Åž": "S",
        "Å ": "S",
        "Å›": "s",
        "Å": "s",
        "ÅŸ": "s",
        "Å¡": "s",
        "Å¢": "T",
        "Å¤": "T",
        "Å¦": "T",
        "Å£": "t",
        "Å¥": "t",
        "Å§": "t",
        "Å¨": "U",
        "Åª": "U",
        "Å¬": "U",
        "Å®": "U",
        "Å°": "U",
        "Å²": "U",
        "Å©": "u",
        "Å«": "u",
        "Å­": "u",
        "Å¯": "u",
        "Å±": "u",
        "Å³": "u",
        "Å´": "W",
        "Åµ": "w",
        "Å¶": "Y",
        "Å·": "y",
        "Å¸": "Y",
        "Å¹": "Z",
        "Å»": "Z",
        "Å½": "Z",
        "Åº": "z",
        "Å¼": "z",
        "Å¾": "z",
        "Ä²": "IJ",
        "Ä³": "ij",
        "Å’": "Oe",
        "Å“": "oe",
        "Å‰": "'n",
        "Å¿": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      __name(apply, "apply");
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      __name(arrayAggregator, "arrayAggregator");
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEach, "arrayEach");
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEachRight, "arrayEachRight");
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      __name(arrayEvery, "arrayEvery");
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      __name(arrayFilter, "arrayFilter");
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      __name(arrayIncludes, "arrayIncludes");
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      __name(arrayIncludesWith, "arrayIncludesWith");
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      __name(arrayMap, "arrayMap");
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      __name(arrayPush, "arrayPush");
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      __name(arrayReduce, "arrayReduce");
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      __name(arrayReduceRight, "arrayReduceRight");
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      __name(arraySome, "arraySome");
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      __name(asciiToArray, "asciiToArray");
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      __name(asciiWords, "asciiWords");
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      __name(baseFindKey, "baseFindKey");
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseFindIndex, "baseFindIndex");
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      __name(baseIndexOf, "baseIndexOf");
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      __name(baseIndexOfWith, "baseIndexOfWith");
      function baseIsNaN(value) {
        return value !== value;
      }
      __name(baseIsNaN, "baseIsNaN");
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      __name(baseMean, "baseMean");
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      __name(baseProperty, "baseProperty");
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      __name(basePropertyOf, "basePropertyOf");
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      __name(baseReduce, "baseReduce");
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      __name(baseSortBy, "baseSortBy");
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      __name(baseSum, "baseSum");
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      __name(baseTimes, "baseTimes");
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      __name(baseToPairs, "baseToPairs");
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      __name(baseTrim, "baseTrim");
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      __name(baseUnary, "baseUnary");
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      __name(baseValues, "baseValues");
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      __name(cacheHas, "cacheHas");
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsStartIndex, "charsStartIndex");
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      __name(charsEndIndex, "charsEndIndex");
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      __name(countHolders, "countHolders");
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      __name(escapeStringChar, "escapeStringChar");
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      __name(getValue, "getValue");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      __name(hasUnicode, "hasUnicode");
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      __name(hasUnicodeWord, "hasUnicodeWord");
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      __name(iteratorToArray, "iteratorToArray");
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      __name(mapToArray, "mapToArray");
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg, "overArg");
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      __name(replaceHolders, "replaceHolders");
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      __name(setToArray, "setToArray");
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      __name(setToPairs, "setToPairs");
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      __name(strictIndexOf, "strictIndexOf");
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      __name(strictLastIndexOf, "strictLastIndexOf");
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      __name(stringSize, "stringSize");
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      __name(stringToArray, "stringToArray");
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      __name(trimmedEndIndex, "trimmedEndIndex");
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      __name(unicodeSize, "unicodeSize");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      __name(unicodeToArray, "unicodeToArray");
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      __name(unicodeWords, "unicodeWords");
      var runInContext = /* @__PURE__ */ __name(function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        __name(lodash2, "lodash");
        var baseCreate = function() {
          function object() {
          }
          __name(object, "object");
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        __name(baseLodash, "baseLodash");
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        __name(LodashWrapper, "LodashWrapper");
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        __name(LazyWrapper, "LazyWrapper");
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        __name(lazyClone, "lazyClone");
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        __name(lazyReverse, "lazyReverse");
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        __name(lazyValue, "lazyValue");
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(Hash, "Hash");
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        __name(hashClear, "hashClear");
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(hashDelete, "hashDelete");
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        __name(hashGet, "hashGet");
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        __name(hashHas, "hashHas");
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        __name(hashSet, "hashSet");
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(ListCache, "ListCache");
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        __name(listCacheClear, "listCacheClear");
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        __name(listCacheDelete, "listCacheDelete");
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        __name(listCacheGet, "listCacheGet");
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        __name(listCacheHas, "listCacheHas");
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        __name(listCacheSet, "listCacheSet");
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        __name(MapCache, "MapCache");
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map || ListCache)(),
            "string": new Hash()
          };
        }
        __name(mapCacheClear, "mapCacheClear");
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        __name(mapCacheDelete, "mapCacheDelete");
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        __name(mapCacheGet, "mapCacheGet");
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        __name(mapCacheHas, "mapCacheHas");
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        __name(mapCacheSet, "mapCacheSet");
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        __name(SetCache, "SetCache");
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        __name(setCacheAdd, "setCacheAdd");
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        __name(setCacheHas, "setCacheHas");
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        __name(Stack, "Stack");
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        __name(stackClear, "stackClear");
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        __name(stackDelete, "stackDelete");
        function stackGet(key) {
          return this.__data__.get(key);
        }
        __name(stackGet, "stackGet");
        function stackHas(key) {
          return this.__data__.has(key);
        }
        __name(stackHas, "stackHas");
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        __name(stackSet, "stackSet");
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(arrayLikeKeys, "arrayLikeKeys");
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        __name(arraySample, "arraySample");
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        __name(arraySampleSize, "arraySampleSize");
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        __name(arrayShuffle, "arrayShuffle");
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        __name(assignMergeValue, "assignMergeValue");
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        __name(assignValue, "assignValue");
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        __name(assocIndexOf, "assocIndexOf");
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        __name(baseAggregator, "baseAggregator");
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        __name(baseAssign, "baseAssign");
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        __name(baseAssignIn, "baseAssignIn");
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        __name(baseAssignValue, "baseAssignValue");
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get2(object, paths[index]);
          }
          return result2;
        }
        __name(baseAt, "baseAt");
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        __name(baseClamp, "baseClamp");
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        __name(baseClone, "baseClone");
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        __name(baseConforms, "baseConforms");
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        __name(baseConformsTo, "baseConformsTo");
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        __name(baseDelay, "baseDelay");
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseDifference, "baseDifference");
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        __name(baseEvery, "baseEvery");
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        __name(baseExtremum, "baseExtremum");
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        __name(baseFill, "baseFill");
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        __name(baseFilter, "baseFilter");
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        __name(baseFlatten, "baseFlatten");
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        __name(baseForOwn, "baseForOwn");
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        __name(baseForOwnRight, "baseForOwnRight");
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        __name(baseFunctions, "baseFunctions");
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined$1;
        }
        __name(baseGet, "baseGet");
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        __name(baseGetAllKeys, "baseGetAllKeys");
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        __name(baseGetTag, "baseGetTag");
        function baseGt(value, other) {
          return value > other;
        }
        __name(baseGt, "baseGt");
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        __name(baseHas, "baseHas");
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        __name(baseHasIn, "baseHasIn");
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        __name(baseInRange, "baseInRange");
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseIntersection, "baseIntersection");
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        __name(baseInverter, "baseInverter");
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        __name(baseInvoke, "baseInvoke");
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        __name(baseIsArguments, "baseIsArguments");
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        __name(baseIsArrayBuffer, "baseIsArrayBuffer");
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        __name(baseIsDate, "baseIsDate");
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        __name(baseIsEqual, "baseIsEqual");
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        __name(baseIsEqualDeep, "baseIsEqualDeep");
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        __name(baseIsMap, "baseIsMap");
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        __name(baseIsMatch, "baseIsMatch");
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        __name(baseIsNative, "baseIsNative");
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        __name(baseIsRegExp, "baseIsRegExp");
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        __name(baseIsSet, "baseIsSet");
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        __name(baseIsTypedArray, "baseIsTypedArray");
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        __name(baseIteratee, "baseIteratee");
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(baseKeys, "baseKeys");
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(baseKeysIn, "baseKeysIn");
        function baseLt(value, other) {
          return value < other;
        }
        __name(baseLt, "baseLt");
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        __name(baseMap, "baseMap");
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        __name(baseMatches, "baseMatches");
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get2(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        __name(baseMatchesProperty, "baseMatchesProperty");
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        __name(baseMerge, "baseMerge");
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        __name(baseMergeDeep, "baseMergeDeep");
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }
        __name(baseNth, "baseNth");
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        __name(baseOrderBy, "baseOrderBy");
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        __name(basePick, "basePick");
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        __name(basePickBy, "basePickBy");
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        __name(basePropertyDeep, "basePropertyDeep");
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        __name(basePullAll, "basePullAll");
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        __name(basePullAt, "basePullAt");
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        __name(baseRandom, "baseRandom");
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        __name(baseRange, "baseRange");
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        __name(baseRepeat, "baseRepeat");
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        __name(baseRest, "baseRest");
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        __name(baseSample, "baseSample");
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        __name(baseSampleSize, "baseSampleSize");
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        __name(baseSet, "baseSet");
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        __name(baseShuffle, "baseShuffle");
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        __name(baseSlice, "baseSlice");
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        __name(baseSome, "baseSome");
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        __name(baseSortedIndex, "baseSortedIndex");
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        __name(baseSortedIndexBy, "baseSortedIndexBy");
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        __name(baseSortedUniq, "baseSortedUniq");
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        __name(baseToNumber, "baseToNumber");
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(baseToString, "baseToString");
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        __name(baseUniq, "baseUniq");
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        __name(baseUnset, "baseUnset");
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        __name(baseUpdate, "baseUpdate");
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        __name(baseWhile, "baseWhile");
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        __name(baseWrapperValue, "baseWrapperValue");
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        __name(baseXor, "baseXor");
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        __name(baseZipObject, "baseZipObject");
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        __name(castArrayLikeObject, "castArrayLikeObject");
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        __name(castFunction, "castFunction");
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        __name(castPath, "castPath");
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        __name(castSlice, "castSlice");
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        __name(cloneBuffer, "cloneBuffer");
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        __name(cloneArrayBuffer, "cloneArrayBuffer");
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        __name(cloneDataView, "cloneDataView");
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        __name(cloneRegExp, "cloneRegExp");
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        __name(cloneSymbol, "cloneSymbol");
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        __name(cloneTypedArray, "cloneTypedArray");
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        __name(compareAscending, "compareAscending");
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        __name(compareMultiple, "compareMultiple");
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        __name(composeArgs, "composeArgs");
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        __name(composeArgsRight, "composeArgsRight");
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        __name(copyArray, "copyArray");
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        __name(copyObject, "copyObject");
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        __name(copySymbols, "copySymbols");
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        __name(copySymbolsIn, "copySymbolsIn");
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        __name(createAggregator, "createAggregator");
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        __name(createAssigner, "createAssigner");
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        __name(createBaseEach, "createBaseEach");
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        __name(createBaseFor, "createBaseFor");
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createBind, "createBind");
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        __name(createCaseFirst, "createCaseFirst");
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        __name(createCompounder, "createCompounder");
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        __name(createCtor, "createCtor");
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createCurry, "createCurry");
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = /* @__PURE__ */ __name(function(key) {
                return iteratee2(iterable[key], key, iterable);
              }, "predicate");
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        __name(createFind, "createFind");
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        __name(createFlow, "createFlow");
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createHybrid, "createHybrid");
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        __name(createInverter, "createInverter");
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        __name(createMathOperation, "createMathOperation");
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        __name(createOver, "createOver");
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        __name(createPadding, "createPadding");
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          __name(wrapper, "wrapper");
          return wrapper;
        }
        __name(createPartial, "createPartial");
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        __name(createRange, "createRange");
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        __name(createRelationalOperation, "createRelationalOperation");
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        __name(createRecurry, "createRecurry");
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        __name(createRound, "createRound");
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        __name(createToPairs, "createToPairs");
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        __name(createWrap, "createWrap");
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        __name(customDefaultsAssignIn, "customDefaultsAssignIn");
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        __name(customDefaultsMerge, "customDefaultsMerge");
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }
        __name(customOmitClone, "customOmitClone");
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        __name(equalArrays, "equalArrays");
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        __name(equalByTag, "equalByTag");
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        __name(equalObjects, "equalObjects");
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        __name(flatRest, "flatRest");
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        __name(getAllKeys, "getAllKeys");
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        __name(getAllKeysIn, "getAllKeysIn");
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        __name(getFuncName, "getFuncName");
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        __name(getHolder, "getHolder");
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        __name(getIteratee, "getIteratee");
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        __name(getMapData, "getMapData");
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        __name(getMatchData, "getMatchData");
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        __name(getNative, "getNative");
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        __name(getRawTag, "getRawTag");
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = /* @__PURE__ */ __name(function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          }, "getTag");
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        __name(getView, "getView");
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        __name(getWrapDetails, "getWrapDetails");
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        __name(hasPath, "hasPath");
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        __name(initCloneArray, "initCloneArray");
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        __name(initCloneObject, "initCloneObject");
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        __name(initCloneByTag, "initCloneByTag");
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        __name(insertWrapDetails, "insertWrapDetails");
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        __name(isFlattenable, "isFlattenable");
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        __name(isIndex, "isIndex");
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        __name(isIterateeCall, "isIterateeCall");
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        __name(isKey, "isKey");
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        __name(isKeyable, "isKeyable");
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        __name(isLaziable, "isLaziable");
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        __name(isMasked, "isMasked");
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        __name(isPrototype, "isPrototype");
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        __name(isStrictComparable, "isStrictComparable");
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        __name(matchesStrictComparable, "matchesStrictComparable");
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        __name(memoizeCapped, "memoizeCapped");
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        __name(mergeData, "mergeData");
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        __name(nativeKeysIn, "nativeKeysIn");
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        __name(objectToString, "objectToString");
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        __name(overRest, "overRest");
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        __name(parent, "parent");
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        __name(reorder, "reorder");
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        __name(safeGet, "safeGet");
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        __name(setWrapToString, "setWrapToString");
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        __name(shortOut, "shortOut");
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        __name(shuffleSelf, "shuffleSelf");
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        __name(toKey, "toKey");
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        __name(toSource, "toSource");
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        __name(updateWrapDetails, "updateWrapDetails");
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        __name(wrapperClone, "wrapperClone");
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        __name(chunk, "chunk");
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        __name(compact, "compact");
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        __name(concat2, "concat");
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        __name(drop, "drop");
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        __name(dropRight, "dropRight");
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        __name(dropRightWhile, "dropRightWhile");
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        __name(dropWhile, "dropWhile");
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        __name(fill, "fill");
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        __name(findIndex, "findIndex");
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        __name(findLastIndex, "findLastIndex");
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        __name(flatten, "flatten");
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        __name(flattenDeep, "flattenDeep");
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        __name(flattenDepth, "flattenDepth");
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        __name(fromPairs, "fromPairs");
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        __name(head, "head");
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        __name(indexOf, "indexOf");
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        __name(initial, "initial");
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        __name(join, "join");
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        __name(last, "last");
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        __name(lastIndexOf, "lastIndexOf");
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        __name(nth, "nth");
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        __name(pullAll, "pullAll");
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        __name(pullAllBy, "pullAllBy");
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        __name(pullAllWith, "pullAllWith");
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        __name(remove, "remove");
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        __name(reverse, "reverse");
        function slice2(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        __name(slice2, "slice");
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        __name(sortedIndex, "sortedIndex");
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        __name(sortedIndexBy, "sortedIndexBy");
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedIndexOf, "sortedIndexOf");
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        __name(sortedLastIndex, "sortedLastIndex");
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        __name(sortedLastIndexBy, "sortedLastIndexBy");
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        __name(sortedLastIndexOf, "sortedLastIndexOf");
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        __name(sortedUniq, "sortedUniq");
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(sortedUniqBy, "sortedUniqBy");
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        __name(tail, "tail");
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        __name(take, "take");
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        __name(takeRight, "takeRight");
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        __name(takeRightWhile, "takeRightWhile");
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        __name(takeWhile, "takeWhile");
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        __name(uniq, "uniq");
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        __name(uniqBy, "uniqBy");
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        __name(uniqWith, "uniqWith");
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        __name(unzip, "unzip");
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        __name(unzipWith, "unzipWith");
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        __name(zipObject, "zipObject");
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        __name(zipObjectDeep, "zipObjectDeep");
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        __name(chain, "chain");
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        __name(tap, "tap");
        function thru(value, interceptor) {
          return interceptor(value);
        }
        __name(thru, "thru");
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = /* @__PURE__ */ __name(function(object) {
            return baseAt(object, paths);
          }, "interceptor");
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        __name(wrapperChain, "wrapperChain");
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        __name(wrapperCommit, "wrapperCommit");
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        __name(wrapperNext, "wrapperNext");
        function wrapperToIterator() {
          return this;
        }
        __name(wrapperToIterator, "wrapperToIterator");
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        __name(wrapperPlant, "wrapperPlant");
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        __name(wrapperReverse, "wrapperReverse");
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        __name(wrapperValue, "wrapperValue");
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(every, "every");
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        __name(filter, "filter");
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        __name(flatMap, "flatMap");
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        __name(flatMapDeep, "flatMapDeep");
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        __name(flatMapDepth, "flatMapDepth");
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEach, "forEach");
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(forEachRight, "forEachRight");
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        __name(includes, "includes");
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        __name(map, "map");
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        __name(orderBy, "orderBy");
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        __name(reduce, "reduce");
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        __name(reduceRight, "reduceRight");
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        __name(reject, "reject");
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        __name(sample, "sample");
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        __name(sampleSize, "sampleSize");
        function shuffle2(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        __name(shuffle2, "shuffle");
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        __name(size, "size");
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        __name(some, "some");
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        __name(after, "after");
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        __name(ary, "ary");
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        __name(before, "before");
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        __name(curry, "curry");
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        __name(curryRight, "curryRight");
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          __name(invokeFunc, "invokeFunc");
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          __name(leadingEdge, "leadingEdge");
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          __name(remainingWait, "remainingWait");
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          __name(shouldInvoke, "shouldInvoke");
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          __name(timerExpired, "timerExpired");
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          __name(trailingEdge, "trailingEdge");
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          __name(cancel, "cancel");
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          __name(flush, "flush");
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          __name(debounced, "debounced");
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        __name(debounce, "debounce");
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        __name(flip, "flip");
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = /* @__PURE__ */ __name(function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          }, "memoized");
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        __name(memoize, "memoize");
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        __name(negate, "negate");
        function once(func) {
          return before(2, func);
        }
        __name(once, "once");
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        __name(rest, "rest");
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        __name(spread, "spread");
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        __name(throttle, "throttle");
        function unary(func) {
          return ary(func, 1);
        }
        __name(unary, "unary");
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        __name(wrap, "wrap");
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        __name(castArray, "castArray");
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        __name(clone, "clone");
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneWith, "cloneWith");
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        __name(cloneDeep, "cloneDeep");
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        __name(cloneDeepWith, "cloneDeepWith");
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        __name(conformsTo, "conformsTo");
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        __name(eq, "eq");
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        __name(isArrayLike, "isArrayLike");
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        __name(isArrayLikeObject, "isArrayLikeObject");
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        __name(isBoolean, "isBoolean");
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement2(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        __name(isElement2, "isElement");
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        __name(isEmpty, "isEmpty");
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        __name(isEqual, "isEqual");
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        __name(isEqualWith, "isEqualWith");
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        __name(isError, "isError");
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        __name(isFinite2, "isFinite");
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        __name(isFunction, "isFunction");
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        __name(isInteger2, "isInteger");
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        __name(isLength, "isLength");
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        __name(isObject, "isObject");
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        __name(isObjectLike, "isObjectLike");
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        __name(isMatch, "isMatch");
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        __name(isMatchWith, "isMatchWith");
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        __name(isNaN2, "isNaN");
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        __name(isNative, "isNative");
        function isNull(value) {
          return value === null;
        }
        __name(isNull, "isNull");
        function isNil(value) {
          return value == null;
        }
        __name(isNil, "isNil");
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        __name(isNumber2, "isNumber");
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        __name(isPlainObject, "isPlainObject");
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        __name(isSafeInteger, "isSafeInteger");
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        __name(isString, "isString");
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        __name(isSymbol, "isSymbol");
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        __name(isUndefined, "isUndefined");
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        __name(isWeakMap, "isWeakMap");
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        __name(isWeakSet, "isWeakSet");
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        __name(toArray, "toArray");
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        __name(toFinite, "toFinite");
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        __name(toInteger, "toInteger");
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        __name(toLength, "toLength");
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        __name(toNumber2, "toNumber");
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        __name(toPlainObject, "toPlainObject");
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        __name(toSafeInteger, "toSafeInteger");
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        __name(toString, "toString");
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        __name(create, "create");
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        __name(findKey, "findKey");
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        __name(findLastKey, "findLastKey");
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forIn, "forIn");
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        __name(forInRight, "forInRight");
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        __name(forOwn, "forOwn");
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        __name(forOwnRight, "forOwnRight");
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        __name(functions, "functions");
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        __name(functionsIn, "functionsIn");
        function get2(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        __name(get2, "get");
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        __name(has, "has");
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        __name(hasIn, "hasIn");
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        __name(keys, "keys");
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        __name(keysIn, "keysIn");
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        __name(mapKeys, "mapKeys");
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        __name(mapValues, "mapValues");
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        __name(omitBy, "omitBy");
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        __name(pickBy, "pickBy");
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        __name(result, "result");
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        __name(set, "set");
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        __name(setWith, "setWith");
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        __name(transform, "transform");
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        __name(unset, "unset");
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        __name(update, "update");
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        __name(updateWith, "updateWith");
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        __name(values, "values");
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        __name(valuesIn, "valuesIn");
        function clamp2(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        __name(clamp2, "clamp");
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        __name(inRange, "inRange");
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        __name(random2, "random");
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        __name(capitalize, "capitalize");
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        __name(deburr, "deburr");
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        __name(endsWith, "endsWith");
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        __name(escape2, "escape");
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        __name(escapeRegExp, "escapeRegExp");
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        __name(pad, "pad");
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        __name(padEnd, "padEnd");
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        __name(padStart, "padStart");
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        __name(parseInt2, "parseInt");
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        __name(repeat, "repeat");
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        __name(replace, "replace");
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        __name(split, "split");
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        __name(startsWith, "startsWith");
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        __name(template, "template");
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        __name(toLower, "toLower");
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        __name(toUpper, "toUpper");
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        __name(trim, "trim");
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        __name(trimEnd, "trimEnd");
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        __name(trimStart, "trimStart");
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        __name(truncate, "truncate");
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        __name(unescape2, "unescape");
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        __name(words, "words");
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        __name(cond, "cond");
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(conforms, "conforms");
        function constant(value) {
          return function() {
            return value;
          };
        }
        __name(constant, "constant");
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        __name(defaultTo, "defaultTo");
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        __name(identity, "identity");
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        __name(iteratee, "iteratee");
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        __name(matches, "matches");
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        __name(matchesProperty, "matchesProperty");
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        __name(mixin, "mixin");
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        __name(noConflict, "noConflict");
        function noop() {
        }
        __name(noop, "noop");
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        __name(nthArg, "nthArg");
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        __name(property, "property");
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        __name(propertyOf, "propertyOf");
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        __name(stubArray, "stubArray");
        function stubFalse() {
          return false;
        }
        __name(stubFalse, "stubFalse");
        function stubObject() {
          return {};
        }
        __name(stubObject, "stubObject");
        function stubString() {
          return "";
        }
        __name(stubString, "stubString");
        function stubTrue() {
          return true;
        }
        __name(stubTrue, "stubTrue");
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        __name(times, "times");
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        __name(toPath, "toPath");
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        __name(uniqueId, "uniqueId");
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        __name(max2, "max");
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        __name(maxBy, "maxBy");
        function mean(array) {
          return baseMean(array, identity);
        }
        __name(mean, "mean");
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        __name(meanBy, "meanBy");
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        __name(min, "min");
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        __name(minBy, "minBy");
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        __name(sum, "sum");
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        __name(sumBy, "sumBy");
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat2;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle2;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement2;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger2;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max2;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random2;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = /* @__PURE__ */ __name(function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            }, "interceptor");
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      }, "runInContext");
      var _ = runInContext();
      if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  const extended_protein_letters = "ACDEFGHIKLMNPQRSTVWYBXZJUO";
  const ambiguous_dna_letters = "GATCRYWSMKHBVDN";
  const ambiguous_rna_letters = "GAUCRYWSMKHBVDN";
  const aminoAcidToDegenerateDnaMap = {
    "-": "---",
    ".": "...",
    "*": "trr",
    a: "gcn",
    b: "ray",
    // D or N => aay + gay = ray
    c: "tgy",
    d: "gay",
    e: "gar",
    f: "tty",
    g: "ggn",
    h: "cay",
    i: "ath",
    j: "htn",
    // L or I ytn + ath => htn
    k: "aar",
    l: "ytn",
    // YTRã€CTN => Y=CT, N=AGCT
    m: "atg",
    n: "aay",
    o: "tag",
    // Pyrrolysine, https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2933860/
    p: "ccn",
    q: "car",
    r: "mgn",
    // CGNã€MGR => M=AC, N=AGCT
    s: "wsn",
    // TCNã€AGY => AT = w, CG = S, N is AGCT
    t: "acn",
    u: "tga",
    // Selenocysteine, https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2933860/
    v: "gtn",
    w: "tgg",
    x: "nnn",
    // unknown aa.
    y: "tay",
    z: "sar"
    // E or Q, => gar + car = sar
  };
  function splitRangeIntoTwoPartsIfItIsCircular(range, sequenceLength) {
    if (sequenceLength !== 0) {
      sequenceLength = sequenceLength || Infinity;
    }
    const ranges = [];
    if (range.start > range.end) {
      ranges.push({
        start: 0,
        end: range.end,
        type: "end"
      });
      ranges.push({
        start: range.start,
        end: sequenceLength - 1,
        type: "beginning"
      });
    } else {
      ranges.push({
        start: range.start,
        end: range.end,
        type: "beginningAndEnd"
      });
    }
    return ranges;
  }
  __name(splitRangeIntoTwoPartsIfItIsCircular, "splitRangeIntoTwoPartsIfItIsCircular");
  function getOverlapOfNonCircularRanges(rangeA, rangeB) {
    if (rangeA.start < rangeB.start) {
      if (rangeA.end < rangeB.start)
        ;
      else {
        if (rangeA.end < rangeB.end) {
          return {
            start: rangeB.start,
            end: rangeA.end
          };
        } else {
          return {
            start: rangeB.start,
            end: rangeB.end
          };
        }
      }
    } else {
      if (rangeA.start > rangeB.end)
        ;
      else {
        if (rangeA.end < rangeB.end) {
          return {
            start: rangeA.start,
            end: rangeA.end
          };
        } else {
          return {
            start: rangeA.start,
            end: rangeB.end
          };
        }
      }
    }
  }
  __name(getOverlapOfNonCircularRanges, "getOverlapOfNonCircularRanges");
  function getOverlapsOfPotentiallyCircularRanges(rangeA, rangeB, maxRangeLength, joinIfPossible) {
    const normalizedRangeA = splitRangeIntoTwoPartsIfItIsCircular(
      rangeA,
      maxRangeLength
    );
    const normalizedRangeB = splitRangeIntoTwoPartsIfItIsCircular(
      rangeB,
      maxRangeLength
    );
    let overlaps = [];
    normalizedRangeA.forEach(function(nonCircularRangeA) {
      normalizedRangeB.forEach(function(nonCircularRangeB) {
        const overlap = getOverlapOfNonCircularRanges(
          nonCircularRangeA,
          nonCircularRangeB
        );
        if (overlap) {
          overlaps.push(overlap);
        }
      });
    });
    if (joinIfPossible && normalizedRangeA.length === 2 && normalizedRangeB.length === 2 && maxRangeLength) {
      const joinedOverlap = {};
      overlaps = lodashExports.flatMap(overlaps, (o) => {
        if (o.start === 0) {
          joinedOverlap.end = o.end;
          return [];
        } else if (o.end === maxRangeLength - 1) {
          joinedOverlap.start = o.start;
          return [];
        }
      });
      overlaps.push(joinedOverlap);
    }
    return overlaps;
  }
  __name(getOverlapsOfPotentiallyCircularRanges, "getOverlapsOfPotentiallyCircularRanges");
  function trimNonCicularRangeByAnotherNonCircularRange(rangeToBeTrimmed, trimmingRange) {
    let outputTrimmedRange;
    if (!rangeToBeTrimmed) {
      return outputTrimmedRange;
    }
    if (rangeToBeTrimmed.start < trimmingRange.start) {
      if (rangeToBeTrimmed.end < trimmingRange.start) {
        outputTrimmedRange = {
          start: rangeToBeTrimmed.start,
          end: rangeToBeTrimmed.end
        };
      } else {
        if (rangeToBeTrimmed.end > trimmingRange.end) {
          outputTrimmedRange = {
            start: rangeToBeTrimmed.start,
            end: rangeToBeTrimmed.end
          };
        } else {
          outputTrimmedRange = {
            start: rangeToBeTrimmed.start,
            end: trimmingRange.start - 1
          };
        }
      }
    } else {
      if (rangeToBeTrimmed.end <= trimmingRange.end)
        ;
      else {
        if (rangeToBeTrimmed.start > trimmingRange.end) {
          outputTrimmedRange = {
            end: rangeToBeTrimmed.end,
            start: rangeToBeTrimmed.start
          };
        } else {
          outputTrimmedRange = {
            end: rangeToBeTrimmed.end,
            start: trimmingRange.end + 1
          };
        }
      }
    }
    return outputTrimmedRange;
  }
  __name(trimNonCicularRangeByAnotherNonCircularRange, "trimNonCicularRangeByAnotherNonCircularRange");
  function trimRangeByAnotherRange(rangeToBeTrimmed, trimmingRange, sequenceLength) {
    if (!rangeToBeTrimmed || !trimmingRange) {
      console.warn("invalid range input");
      return null;
    }
    let position;
    for (position of [
      rangeToBeTrimmed.start,
      rangeToBeTrimmed.end,
      trimmingRange.start,
      trimmingRange.end
    ]) {
      if (position < 0 || !position && position !== 0) {
        console.warn("invalid range input");
        return null;
      }
    }
    const overlaps = getOverlapsOfPotentiallyCircularRanges(
      rangeToBeTrimmed,
      trimmingRange,
      sequenceLength
    );
    if (!overlaps.length) {
      return rangeToBeTrimmed;
    }
    const splitRangesToBeTrimmed = splitRangeIntoTwoPartsIfItIsCircular(
      rangeToBeTrimmed,
      sequenceLength
    );
    splitRangesToBeTrimmed.forEach(function(nonCircularRangeToBeTrimmed, index) {
      overlaps.forEach(function(overlap) {
        if (nonCircularRangeToBeTrimmed) {
          nonCircularRangeToBeTrimmed = trimNonCicularRangeByAnotherNonCircularRange(
            nonCircularRangeToBeTrimmed,
            overlap
          );
        }
      });
      splitRangesToBeTrimmed[index] = nonCircularRangeToBeTrimmed;
    });
    const outputSplitRanges = splitRangesToBeTrimmed.filter(
      function(trimmedRange) {
        if (trimmedRange) {
          return true;
        }
        return false;
      }
    );
    let outputTrimmedRange;
    if (outputSplitRanges.length < 0)
      ;
    else if (outputSplitRanges.length === 1) {
      outputTrimmedRange = outputSplitRanges[0];
    } else if (outputSplitRanges.length === 2) {
      if (outputSplitRanges[0].start < outputSplitRanges[1].start) {
        outputTrimmedRange = {
          start: outputSplitRanges[1].start,
          end: outputSplitRanges[0].end
        };
      } else {
        outputTrimmedRange = {
          start: outputSplitRanges[0].start,
          end: outputSplitRanges[1].end
        };
      }
    }
    if (outputTrimmedRange) {
      return lodashExports.extend({}, rangeToBeTrimmed, {
        start: outputTrimmedRange.start,
        end: outputTrimmedRange.end
      });
    }
  }
  __name(trimRangeByAnotherRange, "trimRangeByAnotherRange");
  function isRangeWithinRange(rangeToCheck, containingRange, maxLength) {
    const ranges = trimRangeByAnotherRange(
      rangeToCheck,
      containingRange,
      maxLength
    );
    if (ranges === null)
      return false;
    return !ranges;
  }
  __name(isRangeWithinRange, "isRangeWithinRange");
  function normalizePositionByRangeLength(pPosition, sequenceLength, isInBetweenPositions) {
    let position = pPosition;
    if (position < 0) {
      position += sequenceLength;
    } else if (position + (isInBetweenPositions ? 0 : 1) > sequenceLength) {
      position -= sequenceLength;
    }
    return position < 0 ? 0 : position > sequenceLength - (isInBetweenPositions ? 0 : 1) ? sequenceLength - (isInBetweenPositions ? 0 : 1) : position;
  }
  __name(normalizePositionByRangeLength, "normalizePositionByRangeLength");
  function translateRange(rangeToBeAdjusted, translateBy, rangeLength) {
    return lodashExports.assign({}, rangeToBeAdjusted, {
      start: normalizePositionByRangeLength(
        rangeToBeAdjusted.start + translateBy,
        rangeLength
      ),
      end: normalizePositionByRangeLength(
        rangeToBeAdjusted.end + translateBy,
        rangeLength
      )
    });
  }
  __name(translateRange, "translateRange");
  function getSequenceWithinRange(range, sequence) {
    if (range.start < 0 || range.end < 0)
      return "";
    if (range.start > range.end) {
      let subSequence = sequence.slice(range.start, sequence.length);
      if (typeof subSequence === "string") {
        subSequence += sequence.slice(0, range.end + 1);
      } else {
        subSequence = subSequence.concat(sequence.slice(0, range.end + 1));
      }
      return subSequence;
    } else {
      return sequence.slice(range.start, range.end + 1);
    }
  }
  __name(getSequenceWithinRange, "getSequenceWithinRange");
  const DNAComplementMap = {
    ".": ".",
    a: "t",
    t: "a",
    u: "a",
    c: "g",
    g: "c",
    A: "T",
    T: "A",
    U: "A",
    C: "G",
    G: "C",
    r: "y",
    R: "Y",
    y: "r",
    Y: "R",
    d: "h",
    D: "H",
    h: "d",
    H: "D",
    k: "m",
    K: "M",
    m: "k",
    M: "K",
    v: "b",
    V: "B",
    b: "v",
    B: "V"
    //tnrtodo add more letters here
  };
  function getReverseComplementSequenceString(sequence) {
    let reverseComplementSequenceString = "";
    for (let i = sequence.length - 1; i >= 0; i--) {
      let revChar = DNAComplementMap[sequence[i]];
      if (!revChar) {
        revChar = sequence[i];
      }
      reverseComplementSequenceString += revChar;
    }
    return reverseComplementSequenceString;
  }
  __name(getReverseComplementSequenceString, "getReverseComplementSequenceString");
  const genbankFeatureTypes = [
    { name: "-10_signal", color: "#4ECDC4" },
    { name: "-35_signal", color: "#F7FFF7" },
    { name: "3'clip", color: "#FF6B6B" },
    { name: "3'UTR", color: "#FFE66D" },
    { name: "5'clip", color: "#3E517A" },
    { name: "5'UTR", color: "#BBBBBB" },
    { name: "D-loop", color: "#F13C73" },
    { name: "assembly_gap", color: "#DE9151" },
    { name: "centromere", color: "#F34213" },
    { name: "Het", color: "#BC5D2E" },
    { name: "mobile_element", color: "#6DB1BF" },
    { name: "ncRNA", color: "#FFEAEC" },
    { name: "proprotein", color: "#F39A9D" },
    { name: "regulatory", color: "#3F6C51" },
    { name: "SecStr", color: "#7B4B94" },
    { name: "Site", color: "#7D82B8" },
    { name: "telomere", color: "DE9151" },
    { name: "tmRNA", color: "#B7E3CC" },
    { name: "unsure", color: "#C4FFB2" },
    { name: "V_segment", color: "#D6F7A3" },
    { name: "allele", color: "#D86D6D" },
    { name: "attenuator", color: "#6B7F9C" },
    { name: "C_region", color: "#B5D89D" },
    { name: "CAAT_signal", color: "#E9CD98" },
    { name: "CDS", color: "#EF6500" },
    { name: "conserved", color: "#A3A5F0" },
    { name: "D_segment", color: "#C060F7" },
    { name: "default", color: "#CCCCCC" },
    { name: "enhancer", color: "#38F872" },
    { name: "exon", color: "#95F844" },
    { name: "gap", color: "#F7D43C" },
    { name: "GC_signal", color: "#861F1F" },
    { name: "gene", color: "#684E27" },
    { name: "iDNA", color: "#A59B41" },
    { name: "intron", color: "#52963E" },
    { name: "J_region", color: "#369283" },
    { name: "LTR", color: "#31748F" },
    { name: "m_rna", color: "#FFFF00" },
    { name: "mat_peptide", color: "#353E8F" },
    { name: "misc_binding", color: "#006FEF" },
    { name: "misc_difference", color: "#5A368A" },
    { name: "misc_feature", color: "#006FEF" },
    { name: "misc_marker", color: "#8DCEB1" },
    { name: "misc_part", color: "#006FEF" },
    { name: "misc_recomb", color: "#DD97B4" },
    { name: "misc_RNA", color: "#BD0101" },
    { name: "misc_signal", color: "#FF9A04" },
    { name: "misc_structure", color: "#B3FF00" },
    { name: "modified_base", color: "#00F7FF" },
    { name: "mRNA", color: "#FFD900" },
    { name: "N_region", color: "#AE00FF" },
    { name: "old_sequence", color: "#F0A7FF" },
    { name: "operator", color: "#63004D" },
    { name: "operon", color: "#000653" },
    { name: "oriT", color: "#580000" },
    { name: "plasmid", color: "#00635E" },
    { name: "polyA_signal", color: "#BBBBBB" },
    { name: "polyA_site", color: "#003328" },
    { name: "precursor_RNA", color: "#443200" },
    { name: "prim_transcript", color: "#665E4C" },
    { name: "primer_bind", color: "#53d969" },
    { name: "promoter", color: "#31B440" },
    { name: "protein_bind", color: "#2E2E2E" },
    { name: "protein_domain", color: "#4D4B4B" },
    { name: "protein", color: "#696969" },
    { name: "RBS", color: "#BDFFCB" },
    { name: "rep_origin", color: "#878787" },
    { name: "repeat_region", color: "#966363" },
    { name: "repeat_unit", color: "#A16D8D" },
    { name: "rRNA", color: "#9BF0FF" },
    { name: "s_mutation", color: "#70A2FF" },
    { name: "S_region", color: "#FF74A9" },
    { name: "satellite", color: "#164E64" },
    { name: "scRNA", color: "#A057FF" },
    { name: "sig_peptide", color: "#2FFF8D" },
    { name: "snoRNA", color: "#296B14" },
    { name: "snRNA", color: "#A16249" },
    { name: "source", color: "#0B17BD" },
    { name: "start", color: "#D6A336" },
    { name: "stem_loop", color: "#67069E" },
    { name: "stop", color: "#D44FC9" },
    { name: "STS", color: "#597FE7" },
    { name: "tag", color: "#E419DA" },
    { name: "TATA_signal", color: "#EB2B2B" },
    { name: "terminator", color: "#F51600" },
    { name: "transit_peptide", color: "#24D491" },
    { name: "transposon", color: "#B6E436" },
    { name: "tRNA", color: "#D1456F" },
    { name: "V_region", color: "#7B5EE7" },
    { name: "variation", color: "#2EE455" }
  ];
  const getMergedFeatureMap = /* @__PURE__ */ __name(() => {
    const keyedGBFeats = lodashExports.keyBy(
      genbankFeatureTypes.map((f) => __spreadProps(__spreadValues({}, f), {
        isGenbankStandardType: true
      })),
      "name"
    );
    let featureOverrides = typeof window !== "undefined" && lodashExports.get(window, "tg_featureTypeOverrides") || typeof global !== "undefined" && lodashExports.get(global, "tg_featureTypeOverrides");
    featureOverrides = featureOverrides || [];
    featureOverrides = featureOverrides.map((fo) => {
      const originalGenbankFeat = keyedGBFeats[fo.name];
      return __spreadValues(__spreadValues(__spreadValues({}, originalGenbankFeat), fo), originalGenbankFeat ? { isOverridden: true } : { isCustomType: true });
    });
    featureOverrides = lodashExports.keyBy(featureOverrides, "name");
    return __spreadValues(__spreadValues({}, keyedGBFeats), featureOverrides);
  }, "getMergedFeatureMap");
  const getFeatureToColorMap = /* @__PURE__ */ __name(({ includeHidden } = {}) => {
    const toRet = {};
    lodashExports.filter(
      getMergedFeatureMap(),
      (f) => includeHidden ? true : !f.isHidden
    ).forEach((f) => {
      toRet[f.name] = f.color;
    });
    return toRet;
  }, "getFeatureToColorMap");
  const getFeatureTypes = /* @__PURE__ */ __name(({ includeHidden } = {}) => lodashExports.filter(getMergedFeatureMap(), (f) => includeHidden ? true : !f.isHidden).map(
    (f) => f.name
  ), "getFeatureTypes");
  var lib = { exports: {} };
  var seed = 1;
  function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  }
  __name(getNextValue, "getNextValue");
  function setSeed$1(_seed_) {
    seed = _seed_;
  }
  __name(setSeed$1, "setSeed$1");
  var randomFromSeed$1 = {
    nextValue: getNextValue,
    seed: setSeed$1
  };
  var randomFromSeed = randomFromSeed$1;
  var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
  var alphabet$2;
  var previousSeed;
  var shuffled;
  function reset() {
    shuffled = false;
  }
  __name(reset, "reset");
  function setCharacters(_alphabet_) {
    if (!_alphabet_) {
      if (alphabet$2 !== ORIGINAL) {
        alphabet$2 = ORIGINAL;
        reset();
      }
      return;
    }
    if (_alphabet_ === alphabet$2) {
      return;
    }
    if (_alphabet_.length !== ORIGINAL.length) {
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
    }
    var unique = _alphabet_.split("").filter(function(item, ind, arr) {
      return ind !== arr.lastIndexOf(item);
    });
    if (unique.length) {
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
    }
    alphabet$2 = _alphabet_;
    reset();
  }
  __name(setCharacters, "setCharacters");
  function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet$2;
  }
  __name(characters, "characters");
  function setSeed(seed2) {
    randomFromSeed.seed(seed2);
    if (previousSeed !== seed2) {
      reset();
      previousSeed = seed2;
    }
  }
  __name(setSeed, "setSeed");
  function shuffle() {
    if (!alphabet$2) {
      setCharacters(ORIGINAL);
    }
    var sourceArray = alphabet$2.split("");
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;
    while (sourceArray.length > 0) {
      r = randomFromSeed.nextValue();
      characterIndex = Math.floor(r * sourceArray.length);
      targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join("");
  }
  __name(shuffle, "shuffle");
  function getShuffled() {
    if (shuffled) {
      return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
  }
  __name(getShuffled, "getShuffled");
  function lookup$1(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
  }
  __name(lookup$1, "lookup$1");
  function get() {
    return alphabet$2 || ORIGINAL;
  }
  __name(get, "get");
  var alphabet_1 = {
    get,
    characters,
    seed: setSeed,
    lookup: lookup$1,
    shuffled: getShuffled
  };
  var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
  var randomByte;
  if (!crypto || !crypto.getRandomValues) {
    randomByte = /* @__PURE__ */ __name(function(size) {
      var bytes = [];
      for (var i = 0; i < size; i++) {
        bytes.push(Math.floor(Math.random() * 256));
      }
      return bytes;
    }, "randomByte");
  } else {
    randomByte = /* @__PURE__ */ __name(function(size) {
      return crypto.getRandomValues(new Uint8Array(size));
    }, "randomByte");
  }
  var randomByteBrowser = randomByte;
  var format_browser = /* @__PURE__ */ __name(function(random2, alphabet2, size) {
    var mask = (2 << Math.log(alphabet2.length - 1) / Math.LN2) - 1;
    var step = -~(1.6 * mask * size / alphabet2.length);
    var id = "";
    while (true) {
      var bytes = random2(step);
      var i = step;
      while (i--) {
        id += alphabet2[bytes[i] & mask] || "";
        if (id.length === +size)
          return id;
      }
    }
  }, "format_browser");
  var alphabet$1 = alphabet_1;
  var random = randomByteBrowser;
  var format = format_browser;
  function generate$1(number) {
    var loopCounter = 0;
    var done;
    var str = "";
    while (!done) {
      str = str + format(random, alphabet$1.get(), 1);
      done = number < Math.pow(16, loopCounter + 1);
      loopCounter++;
    }
    return str;
  }
  __name(generate$1, "generate$1");
  var generate_1 = generate$1;
  var generate = generate_1;
  var REDUCE_TIME = 1567752802062;
  var version = 7;
  var counter;
  var previousSeconds;
  function build(clusterWorkerId) {
    var str = "";
    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
    if (seconds === previousSeconds) {
      counter++;
    } else {
      counter = 0;
      previousSeconds = seconds;
    }
    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
      str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
  }
  __name(build, "build");
  var build_1 = build;
  var alphabet = alphabet_1;
  function isShortId(id) {
    if (!id || typeof id !== "string" || id.length < 6) {
      return false;
    }
    var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
    return !nonAlphabetic.test(id);
  }
  __name(isShortId, "isShortId");
  var isValid = isShortId;
  (function(module) {
    var alphabet2 = alphabet_1;
    var build2 = build_1;
    var isValid$1 = isValid;
    var clusterWorkerId = 0;
    function seed2(seedValue) {
      alphabet2.seed(seedValue);
      return module.exports;
    }
    __name(seed2, "seed");
    function worker(workerId) {
      clusterWorkerId = workerId;
      return module.exports;
    }
    __name(worker, "worker");
    function characters2(newCharacters) {
      if (newCharacters !== void 0) {
        alphabet2.characters(newCharacters);
      }
      return alphabet2.shuffled();
    }
    __name(characters2, "characters");
    function generate2() {
      return build2(clusterWorkerId);
    }
    __name(generate2, "generate");
    module.exports = generate2;
    module.exports.generate = generate2;
    module.exports.seed = seed2;
    module.exports.worker = worker;
    module.exports.characters = characters2;
    module.exports.isValid = isValid$1;
  })(lib);
  var libExports = lib.exports;
  var shortid = libExports;
  const shortid$1 = /* @__PURE__ */ getDefaultExportFromCjs(shortid);
  var jsondiffpatch_umd = { exports: {} };
  var empty = {};
  var hasRequiredEmpty;
  function requireEmpty() {
    if (hasRequiredEmpty)
      return empty;
    hasRequiredEmpty = 1;
    return empty;
  }
  __name(requireEmpty, "requireEmpty");
  (function(module, exports) {
    (function(global2, factory) {
      factory(exports, requireEmpty());
    })(commonjsGlobal, function(exports2, chalk) {
      chalk = chalk && chalk.hasOwnProperty("default") ? chalk["default"] : chalk;
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var classCallCheck = /* @__PURE__ */ __name(function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }, "classCallCheck");
      var createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        __name(defineProperties, "defineProperties");
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var get2 = /* @__PURE__ */ __name(function get3(object, property, receiver) {
        if (object === null)
          object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return void 0;
          } else {
            return get3(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      }, "get");
      var inherits2 = /* @__PURE__ */ __name(function(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }, "inherits");
      var possibleConstructorReturn = /* @__PURE__ */ __name(function(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }, "possibleConstructorReturn");
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err2) {
            _d = true;
            _e = err2;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        __name(sliceIterator, "sliceIterator");
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = /* @__PURE__ */ __name(function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      }, "toConsumableArray");
      var Processor = function() {
        function Processor2(options) {
          classCallCheck(this, Processor2);
          this.selfOptions = options || {};
          this.pipes = {};
        }
        __name(Processor2, "Processor");
        createClass(Processor2, [{
          key: "options",
          value: /* @__PURE__ */ __name(function options(_options) {
            if (_options) {
              this.selfOptions = _options;
            }
            return this.selfOptions;
          }, "options")
        }, {
          key: "pipe",
          value: /* @__PURE__ */ __name(function pipe(name, pipeArg) {
            var pipe2 = pipeArg;
            if (typeof name === "string") {
              if (typeof pipe2 === "undefined") {
                return this.pipes[name];
              } else {
                this.pipes[name] = pipe2;
              }
            }
            if (name && name.name) {
              pipe2 = name;
              if (pipe2.processor === this) {
                return pipe2;
              }
              this.pipes[pipe2.name] = pipe2;
            }
            pipe2.processor = this;
            return pipe2;
          }, "pipe")
        }, {
          key: "process",
          value: /* @__PURE__ */ __name(function process2(input, pipe) {
            var context = input;
            context.options = this.options();
            var nextPipe = pipe || input.pipe || "default";
            var lastPipe = void 0;
            var lastContext = void 0;
            while (nextPipe) {
              if (typeof context.nextAfterChildren !== "undefined") {
                context.next = context.nextAfterChildren;
                context.nextAfterChildren = null;
              }
              if (typeof nextPipe === "string") {
                nextPipe = this.pipe(nextPipe);
              }
              nextPipe.process(context);
              lastContext = context;
              lastPipe = nextPipe;
              nextPipe = null;
              if (context) {
                if (context.next) {
                  context = context.next;
                  nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
                }
              }
            }
            return context.hasResult ? context.result : void 0;
          }, "process")
        }]);
        return Processor2;
      }();
      var Pipe = function() {
        function Pipe2(name) {
          classCallCheck(this, Pipe2);
          this.name = name;
          this.filters = [];
        }
        __name(Pipe2, "Pipe");
        createClass(Pipe2, [{
          key: "process",
          value: /* @__PURE__ */ __name(function process2(input) {
            if (!this.processor) {
              throw new Error("add this pipe to a processor before using it");
            }
            var debug = this.debug;
            var length = this.filters.length;
            var context = input;
            for (var index2 = 0; index2 < length; index2++) {
              var filter = this.filters[index2];
              if (debug) {
                this.log("filter: " + filter.filterName);
              }
              filter(context);
              if ((typeof context === "undefined" ? "undefined" : _typeof(context)) === "object" && context.exiting) {
                context.exiting = false;
                break;
              }
            }
            if (!context.next && this.resultCheck) {
              this.resultCheck(context);
            }
          }, "process")
        }, {
          key: "log",
          value: /* @__PURE__ */ __name(function log2(msg) {
            console.log("[jsondiffpatch] " + this.name + " pipe, " + msg);
          }, "log")
        }, {
          key: "append",
          value: /* @__PURE__ */ __name(function append() {
            var _filters;
            (_filters = this.filters).push.apply(_filters, arguments);
            return this;
          }, "append")
        }, {
          key: "prepend",
          value: /* @__PURE__ */ __name(function prepend() {
            var _filters2;
            (_filters2 = this.filters).unshift.apply(_filters2, arguments);
            return this;
          }, "prepend")
        }, {
          key: "indexOf",
          value: /* @__PURE__ */ __name(function indexOf(filterName) {
            if (!filterName) {
              throw new Error("a filter name is required");
            }
            for (var index2 = 0; index2 < this.filters.length; index2++) {
              var filter = this.filters[index2];
              if (filter.filterName === filterName) {
                return index2;
              }
            }
            throw new Error("filter not found: " + filterName);
          }, "indexOf")
        }, {
          key: "list",
          value: /* @__PURE__ */ __name(function list() {
            return this.filters.map(function(f) {
              return f.filterName;
            });
          }, "list")
        }, {
          key: "after",
          value: /* @__PURE__ */ __name(function after(filterName) {
            var index2 = this.indexOf(filterName);
            var params = Array.prototype.slice.call(arguments, 1);
            if (!params.length) {
              throw new Error("a filter is required");
            }
            params.unshift(index2 + 1, 0);
            Array.prototype.splice.apply(this.filters, params);
            return this;
          }, "after")
        }, {
          key: "before",
          value: /* @__PURE__ */ __name(function before(filterName) {
            var index2 = this.indexOf(filterName);
            var params = Array.prototype.slice.call(arguments, 1);
            if (!params.length) {
              throw new Error("a filter is required");
            }
            params.unshift(index2, 0);
            Array.prototype.splice.apply(this.filters, params);
            return this;
          }, "before")
        }, {
          key: "replace",
          value: /* @__PURE__ */ __name(function replace(filterName) {
            var index2 = this.indexOf(filterName);
            var params = Array.prototype.slice.call(arguments, 1);
            if (!params.length) {
              throw new Error("a filter is required");
            }
            params.unshift(index2, 1);
            Array.prototype.splice.apply(this.filters, params);
            return this;
          }, "replace")
        }, {
          key: "remove",
          value: /* @__PURE__ */ __name(function remove(filterName) {
            var index2 = this.indexOf(filterName);
            this.filters.splice(index2, 1);
            return this;
          }, "remove")
        }, {
          key: "clear",
          value: /* @__PURE__ */ __name(function clear() {
            this.filters.length = 0;
            return this;
          }, "clear")
        }, {
          key: "shouldHaveResult",
          value: /* @__PURE__ */ __name(function shouldHaveResult(should) {
            if (should === false) {
              this.resultCheck = null;
              return;
            }
            if (this.resultCheck) {
              return;
            }
            var pipe = this;
            this.resultCheck = function(context) {
              if (!context.hasResult) {
                console.log(context);
                var error = new Error(pipe.name + " failed");
                error.noResult = true;
                throw error;
              }
            };
            return this;
          }, "shouldHaveResult")
        }]);
        return Pipe2;
      }();
      var Context = function() {
        function Context2() {
          classCallCheck(this, Context2);
        }
        __name(Context2, "Context");
        createClass(Context2, [{
          key: "setResult",
          value: /* @__PURE__ */ __name(function setResult(result) {
            this.result = result;
            this.hasResult = true;
            return this;
          }, "setResult")
        }, {
          key: "exit",
          value: /* @__PURE__ */ __name(function exit() {
            this.exiting = true;
            return this;
          }, "exit")
        }, {
          key: "switchTo",
          value: /* @__PURE__ */ __name(function switchTo(next, pipe) {
            if (typeof next === "string" || next instanceof Pipe) {
              this.nextPipe = next;
            } else {
              this.next = next;
              if (pipe) {
                this.nextPipe = pipe;
              }
            }
            return this;
          }, "switchTo")
        }, {
          key: "push",
          value: /* @__PURE__ */ __name(function push(child, name) {
            child.parent = this;
            if (typeof name !== "undefined") {
              child.childName = name;
            }
            child.root = this.root || this;
            child.options = child.options || this.options;
            if (!this.children) {
              this.children = [child];
              this.nextAfterChildren = this.next || null;
              this.next = child;
            } else {
              this.children[this.children.length - 1].next = child;
              this.children.push(child);
            }
            child.next = this;
            return this;
          }, "push")
        }]);
        return Context2;
      }();
      var isArray2 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      };
      function cloneRegExp(re) {
        var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
        return new RegExp(regexMatch[1], regexMatch[2]);
      }
      __name(cloneRegExp, "cloneRegExp");
      function clone(arg) {
        if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) !== "object") {
          return arg;
        }
        if (arg === null) {
          return null;
        }
        if (isArray2(arg)) {
          return arg.map(clone);
        }
        if (arg instanceof Date) {
          return new Date(arg.getTime());
        }
        if (arg instanceof RegExp) {
          return cloneRegExp(arg);
        }
        var cloned = {};
        for (var name in arg) {
          if (Object.prototype.hasOwnProperty.call(arg, name)) {
            cloned[name] = clone(arg[name]);
          }
        }
        return cloned;
      }
      __name(clone, "clone");
      var DiffContext = function(_Context) {
        inherits2(DiffContext2, _Context);
        function DiffContext2(left, right) {
          classCallCheck(this, DiffContext2);
          var _this = possibleConstructorReturn(this, (DiffContext2.__proto__ || Object.getPrototypeOf(DiffContext2)).call(this));
          _this.left = left;
          _this.right = right;
          _this.pipe = "diff";
          return _this;
        }
        __name(DiffContext2, "DiffContext");
        createClass(DiffContext2, [{
          key: "setResult",
          value: /* @__PURE__ */ __name(function setResult(result) {
            if (this.options.cloneDiffValues && (typeof result === "undefined" ? "undefined" : _typeof(result)) === "object") {
              var clone$$1 = typeof this.options.cloneDiffValues === "function" ? this.options.cloneDiffValues : clone;
              if (_typeof(result[0]) === "object") {
                result[0] = clone$$1(result[0]);
              }
              if (_typeof(result[1]) === "object") {
                result[1] = clone$$1(result[1]);
              }
            }
            return Context.prototype.setResult.apply(this, arguments);
          }, "setResult")
        }]);
        return DiffContext2;
      }(Context);
      var PatchContext = function(_Context) {
        inherits2(PatchContext2, _Context);
        function PatchContext2(left, delta) {
          classCallCheck(this, PatchContext2);
          var _this = possibleConstructorReturn(this, (PatchContext2.__proto__ || Object.getPrototypeOf(PatchContext2)).call(this));
          _this.left = left;
          _this.delta = delta;
          _this.pipe = "patch";
          return _this;
        }
        __name(PatchContext2, "PatchContext");
        return PatchContext2;
      }(Context);
      var ReverseContext = function(_Context) {
        inherits2(ReverseContext2, _Context);
        function ReverseContext2(delta) {
          classCallCheck(this, ReverseContext2);
          var _this = possibleConstructorReturn(this, (ReverseContext2.__proto__ || Object.getPrototypeOf(ReverseContext2)).call(this));
          _this.delta = delta;
          _this.pipe = "reverse";
          return _this;
        }
        __name(ReverseContext2, "ReverseContext");
        return ReverseContext2;
      }(Context);
      var isArray$12 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      };
      var diffFilter = /* @__PURE__ */ __name(function trivialMatchesDiffFilter(context) {
        if (context.left === context.right) {
          context.setResult(void 0).exit();
          return;
        }
        if (typeof context.left === "undefined") {
          if (typeof context.right === "function") {
            throw new Error("functions are not supported");
          }
          context.setResult([context.right]).exit();
          return;
        }
        if (typeof context.right === "undefined") {
          context.setResult([context.left, 0, 0]).exit();
          return;
        }
        if (typeof context.left === "function" || typeof context.right === "function") {
          throw new Error("functions are not supported");
        }
        context.leftType = context.left === null ? "null" : _typeof(context.left);
        context.rightType = context.right === null ? "null" : _typeof(context.right);
        if (context.leftType !== context.rightType) {
          context.setResult([context.left, context.right]).exit();
          return;
        }
        if (context.leftType === "boolean" || context.leftType === "number") {
          context.setResult([context.left, context.right]).exit();
          return;
        }
        if (context.leftType === "object") {
          context.leftIsArray = isArray$12(context.left);
        }
        if (context.rightType === "object") {
          context.rightIsArray = isArray$12(context.right);
        }
        if (context.leftIsArray !== context.rightIsArray) {
          context.setResult([context.left, context.right]).exit();
          return;
        }
        if (context.left instanceof RegExp) {
          if (context.right instanceof RegExp) {
            context.setResult([context.left.toString(), context.right.toString()]).exit();
          } else {
            context.setResult([context.left, context.right]).exit();
          }
        }
      }, "trivialMatchesDiffFilter");
      diffFilter.filterName = "trivial";
      var patchFilter = /* @__PURE__ */ __name(function trivialMatchesPatchFilter(context) {
        if (typeof context.delta === "undefined") {
          context.setResult(context.left).exit();
          return;
        }
        context.nested = !isArray$12(context.delta);
        if (context.nested) {
          return;
        }
        if (context.delta.length === 1) {
          context.setResult(context.delta[0]).exit();
          return;
        }
        if (context.delta.length === 2) {
          if (context.left instanceof RegExp) {
            var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
            if (regexArgs) {
              context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
              return;
            }
          }
          context.setResult(context.delta[1]).exit();
          return;
        }
        if (context.delta.length === 3 && context.delta[2] === 0) {
          context.setResult(void 0).exit();
        }
      }, "trivialMatchesPatchFilter");
      patchFilter.filterName = "trivial";
      var reverseFilter = /* @__PURE__ */ __name(function trivialReferseFilter(context) {
        if (typeof context.delta === "undefined") {
          context.setResult(context.delta).exit();
          return;
        }
        context.nested = !isArray$12(context.delta);
        if (context.nested) {
          return;
        }
        if (context.delta.length === 1) {
          context.setResult([context.delta[0], 0, 0]).exit();
          return;
        }
        if (context.delta.length === 2) {
          context.setResult([context.delta[1], context.delta[0]]).exit();
          return;
        }
        if (context.delta.length === 3 && context.delta[2] === 0) {
          context.setResult([context.delta[0]]).exit();
        }
      }, "trivialReferseFilter");
      reverseFilter.filterName = "trivial";
      function collectChildrenDiffFilter(context) {
        if (!context || !context.children) {
          return;
        }
        var length = context.children.length;
        var child = void 0;
        var result = context.result;
        for (var index2 = 0; index2 < length; index2++) {
          child = context.children[index2];
          if (typeof child.result === "undefined") {
            continue;
          }
          result = result || {};
          result[child.childName] = child.result;
        }
        if (result && context.leftIsArray) {
          result._t = "a";
        }
        context.setResult(result).exit();
      }
      __name(collectChildrenDiffFilter, "collectChildrenDiffFilter");
      collectChildrenDiffFilter.filterName = "collectChildren";
      function objectsDiffFilter(context) {
        if (context.leftIsArray || context.leftType !== "object") {
          return;
        }
        var name = void 0;
        var child = void 0;
        var propertyFilter = context.options.propertyFilter;
        for (name in context.left) {
          if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
            continue;
          }
          if (propertyFilter && !propertyFilter(name, context)) {
            continue;
          }
          child = new DiffContext(context.left[name], context.right[name]);
          context.push(child, name);
        }
        for (name in context.right) {
          if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
            continue;
          }
          if (propertyFilter && !propertyFilter(name, context)) {
            continue;
          }
          if (typeof context.left[name] === "undefined") {
            child = new DiffContext(void 0, context.right[name]);
            context.push(child, name);
          }
        }
        if (!context.children || context.children.length === 0) {
          context.setResult(void 0).exit();
          return;
        }
        context.exit();
      }
      __name(objectsDiffFilter, "objectsDiffFilter");
      objectsDiffFilter.filterName = "objects";
      var patchFilter$1 = /* @__PURE__ */ __name(function nestedPatchFilter(context) {
        if (!context.nested) {
          return;
        }
        if (context.delta._t) {
          return;
        }
        var name = void 0;
        var child = void 0;
        for (name in context.delta) {
          child = new PatchContext(context.left[name], context.delta[name]);
          context.push(child, name);
        }
        context.exit();
      }, "nestedPatchFilter");
      patchFilter$1.filterName = "objects";
      var collectChildrenPatchFilter = /* @__PURE__ */ __name(function collectChildrenPatchFilter2(context) {
        if (!context || !context.children) {
          return;
        }
        if (context.delta._t) {
          return;
        }
        var length = context.children.length;
        var child = void 0;
        for (var index2 = 0; index2 < length; index2++) {
          child = context.children[index2];
          if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === void 0) {
            delete context.left[child.childName];
          } else if (context.left[child.childName] !== child.result) {
            context.left[child.childName] = child.result;
          }
        }
        context.setResult(context.left).exit();
      }, "collectChildrenPatchFilter");
      collectChildrenPatchFilter.filterName = "collectChildren";
      var reverseFilter$1 = /* @__PURE__ */ __name(function nestedReverseFilter(context) {
        if (!context.nested) {
          return;
        }
        if (context.delta._t) {
          return;
        }
        var name = void 0;
        var child = void 0;
        for (name in context.delta) {
          child = new ReverseContext(context.delta[name]);
          context.push(child, name);
        }
        context.exit();
      }, "nestedReverseFilter");
      reverseFilter$1.filterName = "objects";
      function collectChildrenReverseFilter(context) {
        if (!context || !context.children) {
          return;
        }
        if (context.delta._t) {
          return;
        }
        var length = context.children.length;
        var child = void 0;
        var delta = {};
        for (var index2 = 0; index2 < length; index2++) {
          child = context.children[index2];
          if (delta[child.childName] !== child.result) {
            delta[child.childName] = child.result;
          }
        }
        context.setResult(delta).exit();
      }
      __name(collectChildrenReverseFilter, "collectChildrenReverseFilter");
      collectChildrenReverseFilter.filterName = "collectChildren";
      var defaultMatch = /* @__PURE__ */ __name(function defaultMatch2(array1, array2, index1, index2) {
        return array1[index1] === array2[index2];
      }, "defaultMatch");
      var lengthMatrix = /* @__PURE__ */ __name(function lengthMatrix2(array1, array2, match, context) {
        var len1 = array1.length;
        var len2 = array2.length;
        var x = void 0, y = void 0;
        var matrix = [len1 + 1];
        for (x = 0; x < len1 + 1; x++) {
          matrix[x] = [len2 + 1];
          for (y = 0; y < len2 + 1; y++) {
            matrix[x][y] = 0;
          }
        }
        matrix.match = match;
        for (x = 1; x < len1 + 1; x++) {
          for (y = 1; y < len2 + 1; y++) {
            if (match(array1, array2, x - 1, y - 1, context)) {
              matrix[x][y] = matrix[x - 1][y - 1] + 1;
            } else {
              matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
            }
          }
        }
        return matrix;
      }, "lengthMatrix");
      var backtrack = /* @__PURE__ */ __name(function backtrack2(matrix, array1, array2, context) {
        var index1 = array1.length;
        var index2 = array2.length;
        var subsequence = {
          sequence: [],
          indices1: [],
          indices2: []
        };
        while (index1 !== 0 && index2 !== 0) {
          var sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);
          if (sameLetter) {
            subsequence.sequence.unshift(array1[index1 - 1]);
            subsequence.indices1.unshift(index1 - 1);
            subsequence.indices2.unshift(index2 - 1);
            --index1;
            --index2;
          } else {
            var valueAtMatrixAbove = matrix[index1][index2 - 1];
            var valueAtMatrixLeft = matrix[index1 - 1][index2];
            if (valueAtMatrixAbove > valueAtMatrixLeft) {
              --index2;
            } else {
              --index1;
            }
          }
        }
        return subsequence;
      }, "backtrack");
      var get$1 = /* @__PURE__ */ __name(function get3(array1, array2, match, context) {
        var innerContext = context || {};
        var matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);
        var result = backtrack(matrix, array1, array2, innerContext);
        if (typeof array1 === "string" && typeof array2 === "string") {
          result.sequence = result.sequence.join("");
        }
        return result;
      }, "get");
      var lcs = {
        get: get$1
      };
      var ARRAY_MOVE = 3;
      var isArray$2 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      };
      var arrayIndexOf = typeof Array.prototype.indexOf === "function" ? function(array, item) {
        return array.indexOf(item);
      } : function(array, item) {
        var length = array.length;
        for (var i = 0; i < length; i++) {
          if (array[i] === item) {
            return i;
          }
        }
        return -1;
      };
      function arraysHaveMatchByRef(array1, array2, len1, len2) {
        for (var index1 = 0; index1 < len1; index1++) {
          var val1 = array1[index1];
          for (var index2 = 0; index2 < len2; index2++) {
            var val2 = array2[index2];
            if (index1 !== index2 && val1 === val2) {
              return true;
            }
          }
        }
      }
      __name(arraysHaveMatchByRef, "arraysHaveMatchByRef");
      function matchItems(array1, array2, index1, index2, context) {
        var value1 = array1[index1];
        var value2 = array2[index2];
        if (value1 === value2) {
          return true;
        }
        if ((typeof value1 === "undefined" ? "undefined" : _typeof(value1)) !== "object" || (typeof value2 === "undefined" ? "undefined" : _typeof(value2)) !== "object") {
          return false;
        }
        var objectHash = context.objectHash;
        if (!objectHash) {
          return context.matchByPosition && index1 === index2;
        }
        var hash1 = void 0;
        var hash2 = void 0;
        if (typeof index1 === "number") {
          context.hashCache1 = context.hashCache1 || [];
          hash1 = context.hashCache1[index1];
          if (typeof hash1 === "undefined") {
            context.hashCache1[index1] = hash1 = objectHash(value1, index1);
          }
        } else {
          hash1 = objectHash(value1);
        }
        if (typeof hash1 === "undefined") {
          return false;
        }
        if (typeof index2 === "number") {
          context.hashCache2 = context.hashCache2 || [];
          hash2 = context.hashCache2[index2];
          if (typeof hash2 === "undefined") {
            context.hashCache2[index2] = hash2 = objectHash(value2, index2);
          }
        } else {
          hash2 = objectHash(value2);
        }
        if (typeof hash2 === "undefined") {
          return false;
        }
        return hash1 === hash2;
      }
      __name(matchItems, "matchItems");
      var diffFilter$1 = /* @__PURE__ */ __name(function arraysDiffFilter(context) {
        if (!context.leftIsArray) {
          return;
        }
        var matchContext = {
          objectHash: context.options && context.options.objectHash,
          matchByPosition: context.options && context.options.matchByPosition
        };
        var commonHead = 0;
        var commonTail = 0;
        var index2 = void 0;
        var index1 = void 0;
        var index22 = void 0;
        var array1 = context.left;
        var array2 = context.right;
        var len1 = array1.length;
        var len2 = array2.length;
        var child = void 0;
        if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== "boolean") {
          matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
        }
        while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
          index2 = commonHead;
          child = new DiffContext(context.left[index2], context.right[index2]);
          context.push(child, index2);
          commonHead++;
        }
        while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
          index1 = len1 - 1 - commonTail;
          index22 = len2 - 1 - commonTail;
          child = new DiffContext(context.left[index1], context.right[index22]);
          context.push(child, index22);
          commonTail++;
        }
        var result = void 0;
        if (commonHead + commonTail === len1) {
          if (len1 === len2) {
            context.setResult(void 0).exit();
            return;
          }
          result = result || {
            _t: "a"
          };
          for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
            result[index2] = [array2[index2]];
          }
          context.setResult(result).exit();
          return;
        }
        if (commonHead + commonTail === len2) {
          result = result || {
            _t: "a"
          };
          for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
            result["_" + index2] = [array1[index2], 0, 0];
          }
          context.setResult(result).exit();
          return;
        }
        delete matchContext.hashCache1;
        delete matchContext.hashCache2;
        var trimmed1 = array1.slice(commonHead, len1 - commonTail);
        var trimmed2 = array2.slice(commonHead, len2 - commonTail);
        var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
        var removedItems = [];
        result = result || {
          _t: "a"
        };
        for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
          if (arrayIndexOf(seq.indices1, index2 - commonHead) < 0) {
            result["_" + index2] = [array1[index2], 0, 0];
            removedItems.push(index2);
          }
        }
        var detectMove = true;
        if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
          detectMove = false;
        }
        var includeValueOnMove = false;
        if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
          includeValueOnMove = true;
        }
        var removedItemsLength = removedItems.length;
        for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
          var indexOnArray2 = arrayIndexOf(seq.indices2, index2 - commonHead);
          if (indexOnArray2 < 0) {
            var isMove = false;
            if (detectMove && removedItemsLength > 0) {
              for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
                index1 = removedItems[removeItemIndex1];
                if (matchItems(trimmed1, trimmed2, index1 - commonHead, index2 - commonHead, matchContext)) {
                  result["_" + index1].splice(1, 2, index2, ARRAY_MOVE);
                  if (!includeValueOnMove) {
                    result["_" + index1][0] = "";
                  }
                  index22 = index2;
                  child = new DiffContext(context.left[index1], context.right[index22]);
                  context.push(child, index22);
                  removedItems.splice(removeItemIndex1, 1);
                  isMove = true;
                  break;
                }
              }
            }
            if (!isMove) {
              result[index2] = [array2[index2]];
            }
          } else {
            index1 = seq.indices1[indexOnArray2] + commonHead;
            index22 = seq.indices2[indexOnArray2] + commonHead;
            child = new DiffContext(context.left[index1], context.right[index22]);
            context.push(child, index22);
          }
        }
        context.setResult(result).exit();
      }, "arraysDiffFilter");
      diffFilter$1.filterName = "arrays";
      var compare = {
        numerically: /* @__PURE__ */ __name(function numerically(a, b) {
          return a - b;
        }, "numerically"),
        numericallyBy: /* @__PURE__ */ __name(function numericallyBy(name) {
          return function(a, b) {
            return a[name] - b[name];
          };
        }, "numericallyBy")
      };
      var patchFilter$2 = /* @__PURE__ */ __name(function nestedPatchFilter(context) {
        if (!context.nested) {
          return;
        }
        if (context.delta._t !== "a") {
          return;
        }
        var index2 = void 0;
        var index1 = void 0;
        var delta = context.delta;
        var array = context.left;
        var toRemove = [];
        var toInsert = [];
        var toModify = [];
        for (index2 in delta) {
          if (index2 !== "_t") {
            if (index2[0] === "_") {
              if (delta[index2][2] === 0 || delta[index2][2] === ARRAY_MOVE) {
                toRemove.push(parseInt(index2.slice(1), 10));
              } else {
                throw new Error("only removal or move can be applied at original array indices," + (" invalid diff type: " + delta[index2][2]));
              }
            } else {
              if (delta[index2].length === 1) {
                toInsert.push({
                  index: parseInt(index2, 10),
                  value: delta[index2][0]
                });
              } else {
                toModify.push({
                  index: parseInt(index2, 10),
                  delta: delta[index2]
                });
              }
            }
          }
        }
        toRemove = toRemove.sort(compare.numerically);
        for (index2 = toRemove.length - 1; index2 >= 0; index2--) {
          index1 = toRemove[index2];
          var indexDiff = delta["_" + index1];
          var removedValue = array.splice(index1, 1)[0];
          if (indexDiff[2] === ARRAY_MOVE) {
            toInsert.push({
              index: indexDiff[1],
              value: removedValue
            });
          }
        }
        toInsert = toInsert.sort(compare.numericallyBy("index"));
        var toInsertLength = toInsert.length;
        for (index2 = 0; index2 < toInsertLength; index2++) {
          var insertion = toInsert[index2];
          array.splice(insertion.index, 0, insertion.value);
        }
        var toModifyLength = toModify.length;
        var child = void 0;
        if (toModifyLength > 0) {
          for (index2 = 0; index2 < toModifyLength; index2++) {
            var modification = toModify[index2];
            child = new PatchContext(context.left[modification.index], modification.delta);
            context.push(child, modification.index);
          }
        }
        if (!context.children) {
          context.setResult(context.left).exit();
          return;
        }
        context.exit();
      }, "nestedPatchFilter");
      patchFilter$2.filterName = "arrays";
      var collectChildrenPatchFilter$1 = /* @__PURE__ */ __name(function collectChildrenPatchFilter2(context) {
        if (!context || !context.children) {
          return;
        }
        if (context.delta._t !== "a") {
          return;
        }
        var length = context.children.length;
        var child = void 0;
        for (var index2 = 0; index2 < length; index2++) {
          child = context.children[index2];
          context.left[child.childName] = child.result;
        }
        context.setResult(context.left).exit();
      }, "collectChildrenPatchFilter");
      collectChildrenPatchFilter$1.filterName = "arraysCollectChildren";
      var reverseFilter$2 = /* @__PURE__ */ __name(function arraysReverseFilter(context) {
        if (!context.nested) {
          if (context.delta[2] === ARRAY_MOVE) {
            context.newName = "_" + context.delta[1];
            context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
          }
          return;
        }
        if (context.delta._t !== "a") {
          return;
        }
        var name = void 0;
        var child = void 0;
        for (name in context.delta) {
          if (name === "_t") {
            continue;
          }
          child = new ReverseContext(context.delta[name]);
          context.push(child, name);
        }
        context.exit();
      }, "arraysReverseFilter");
      reverseFilter$2.filterName = "arrays";
      var reverseArrayDeltaIndex = /* @__PURE__ */ __name(function reverseArrayDeltaIndex2(delta, index2, itemDelta) {
        if (typeof index2 === "string" && index2[0] === "_") {
          return parseInt(index2.substr(1), 10);
        } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
          return "_" + index2;
        }
        var reverseIndex = +index2;
        for (var deltaIndex in delta) {
          var deltaItem = delta[deltaIndex];
          if (isArray$2(deltaItem)) {
            if (deltaItem[2] === ARRAY_MOVE) {
              var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
              var moveToIndex = deltaItem[1];
              if (moveToIndex === +index2) {
                return moveFromIndex;
              }
              if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
                reverseIndex++;
              } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
                reverseIndex--;
              }
            } else if (deltaItem[2] === 0) {
              var deleteIndex = parseInt(deltaIndex.substr(1), 10);
              if (deleteIndex <= reverseIndex) {
                reverseIndex++;
              }
            } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
              reverseIndex--;
            }
          }
        }
        return reverseIndex;
      }, "reverseArrayDeltaIndex");
      function collectChildrenReverseFilter$1(context) {
        if (!context || !context.children) {
          return;
        }
        if (context.delta._t !== "a") {
          return;
        }
        var length = context.children.length;
        var child = void 0;
        var delta = {
          _t: "a"
        };
        for (var index2 = 0; index2 < length; index2++) {
          child = context.children[index2];
          var name = child.newName;
          if (typeof name === "undefined") {
            name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
          }
          if (delta[name] !== child.result) {
            delta[name] = child.result;
          }
        }
        context.setResult(delta).exit();
      }
      __name(collectChildrenReverseFilter$1, "collectChildrenReverseFilter$1");
      collectChildrenReverseFilter$1.filterName = "arraysCollectChildren";
      var diffFilter$2 = /* @__PURE__ */ __name(function datesDiffFilter(context) {
        if (context.left instanceof Date) {
          if (context.right instanceof Date) {
            if (context.left.getTime() !== context.right.getTime()) {
              context.setResult([context.left, context.right]);
            } else {
              context.setResult(void 0);
            }
          } else {
            context.setResult([context.left, context.right]);
          }
          context.exit();
        } else if (context.right instanceof Date) {
          context.setResult([context.left, context.right]).exit();
        }
      }, "datesDiffFilter");
      diffFilter$2.filterName = "dates";
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      __name(createCommonjsModule, "createCommonjsModule");
      var diffMatchPatch = createCommonjsModule(function(module2) {
        function diff_match_patch2() {
          this.Diff_Timeout = 1;
          this.Diff_EditCost = 4;
          this.Match_Threshold = 0.5;
          this.Match_Distance = 1e3;
          this.Patch_DeleteThreshold = 0.5;
          this.Patch_Margin = 4;
          this.Match_MaxBits = 32;
        }
        __name(diff_match_patch2, "diff_match_patch");
        var DIFF_DELETE = -1;
        var DIFF_INSERT = 1;
        var DIFF_EQUAL = 0;
        diff_match_patch2.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
          if (typeof opt_deadline == "undefined") {
            if (this.Diff_Timeout <= 0) {
              opt_deadline = Number.MAX_VALUE;
            } else {
              opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
            }
          }
          var deadline = opt_deadline;
          if (text1 == null || text2 == null) {
            throw new Error("Null input. (diff_main)");
          }
          if (text1 == text2) {
            if (text1) {
              return [[DIFF_EQUAL, text1]];
            }
            return [];
          }
          if (typeof opt_checklines == "undefined") {
            opt_checklines = true;
          }
          var checklines = opt_checklines;
          var commonlength = this.diff_commonPrefix(text1, text2);
          var commonprefix = text1.substring(0, commonlength);
          text1 = text1.substring(commonlength);
          text2 = text2.substring(commonlength);
          commonlength = this.diff_commonSuffix(text1, text2);
          var commonsuffix = text1.substring(text1.length - commonlength);
          text1 = text1.substring(0, text1.length - commonlength);
          text2 = text2.substring(0, text2.length - commonlength);
          var diffs = this.diff_compute_(text1, text2, checklines, deadline);
          if (commonprefix) {
            diffs.unshift([DIFF_EQUAL, commonprefix]);
          }
          if (commonsuffix) {
            diffs.push([DIFF_EQUAL, commonsuffix]);
          }
          this.diff_cleanupMerge(diffs);
          return diffs;
        };
        diff_match_patch2.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
          var diffs;
          if (!text1) {
            return [[DIFF_INSERT, text2]];
          }
          if (!text2) {
            return [[DIFF_DELETE, text1]];
          }
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          var i = longtext.indexOf(shorttext);
          if (i != -1) {
            diffs = [
              [DIFF_INSERT, longtext.substring(0, i)],
              [DIFF_EQUAL, shorttext],
              [DIFF_INSERT, longtext.substring(i + shorttext.length)]
            ];
            if (text1.length > text2.length) {
              diffs[0][0] = diffs[2][0] = DIFF_DELETE;
            }
            return diffs;
          }
          if (shorttext.length == 1) {
            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          }
          var hm = this.diff_halfMatch_(text1, text2);
          if (hm) {
            var text1_a = hm[0];
            var text1_b = hm[1];
            var text2_a = hm[2];
            var text2_b = hm[3];
            var mid_common = hm[4];
            var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
            var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
            return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
          }
          if (checklines && text1.length > 100 && text2.length > 100) {
            return this.diff_lineMode_(text1, text2, deadline);
          }
          return this.diff_bisect_(text1, text2, deadline);
        };
        diff_match_patch2.prototype.diff_lineMode_ = function(text1, text2, deadline) {
          var a = this.diff_linesToChars_(text1, text2);
          text1 = a.chars1;
          text2 = a.chars2;
          var linearray = a.lineArray;
          var diffs = this.diff_main(text1, text2, false, deadline);
          this.diff_charsToLines_(diffs, linearray);
          this.diff_cleanupSemantic(diffs);
          diffs.push([DIFF_EQUAL, ""]);
          var pointer = 0;
          var count_delete = 0;
          var count_insert = 0;
          var text_delete = "";
          var text_insert = "";
          while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
              case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                break;
              case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                break;
              case DIFF_EQUAL:
                if (count_delete >= 1 && count_insert >= 1) {
                  diffs.splice(
                    pointer - count_delete - count_insert,
                    count_delete + count_insert
                  );
                  pointer = pointer - count_delete - count_insert;
                  var a = this.diff_main(text_delete, text_insert, false, deadline);
                  for (var j = a.length - 1; j >= 0; j--) {
                    diffs.splice(pointer, 0, a[j]);
                  }
                  pointer = pointer + a.length;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = "";
                text_insert = "";
                break;
            }
            pointer++;
          }
          diffs.pop();
          return diffs;
        };
        diff_match_patch2.prototype.diff_bisect_ = function(text1, text2, deadline) {
          var text1_length = text1.length;
          var text2_length = text2.length;
          var max_d = Math.ceil((text1_length + text2_length) / 2);
          var v_offset = max_d;
          var v_length = 2 * max_d;
          var v1 = new Array(v_length);
          var v2 = new Array(v_length);
          for (var x = 0; x < v_length; x++) {
            v1[x] = -1;
            v2[x] = -1;
          }
          v1[v_offset + 1] = 0;
          v2[v_offset + 1] = 0;
          var delta = text1_length - text2_length;
          var front = delta % 2 != 0;
          var k1start = 0;
          var k1end = 0;
          var k2start = 0;
          var k2end = 0;
          for (var d = 0; d < max_d; d++) {
            if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
              break;
            }
            for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
              var k1_offset = v_offset + k1;
              var x1;
              if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                x1 = v1[k1_offset + 1];
              } else {
                x1 = v1[k1_offset - 1] + 1;
              }
              var y1 = x1 - k1;
              while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
              }
              v1[k1_offset] = x1;
              if (x1 > text1_length) {
                k1end += 2;
              } else if (y1 > text2_length) {
                k1start += 2;
              } else if (front) {
                var k2_offset = v_offset + delta - k1;
                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                  var x2 = text1_length - v2[k2_offset];
                  if (x1 >= x2) {
                    return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                  }
                }
              }
            }
            for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
              var k2_offset = v_offset + k2;
              var x2;
              if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                x2 = v2[k2_offset + 1];
              } else {
                x2 = v2[k2_offset - 1] + 1;
              }
              var y2 = x2 - k2;
              while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                x2++;
                y2++;
              }
              v2[k2_offset] = x2;
              if (x2 > text1_length) {
                k2end += 2;
              } else if (y2 > text2_length) {
                k2start += 2;
              } else if (!front) {
                var k1_offset = v_offset + delta - k2;
                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                  var x1 = v1[k1_offset];
                  var y1 = v_offset + x1 - k1_offset;
                  x2 = text1_length - x2;
                  if (x1 >= x2) {
                    return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                  }
                }
              }
            }
          }
          return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
        };
        diff_match_patch2.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
          var text1a = text1.substring(0, x);
          var text2a = text2.substring(0, y);
          var text1b = text1.substring(x);
          var text2b = text2.substring(y);
          var diffs = this.diff_main(text1a, text2a, false, deadline);
          var diffsb = this.diff_main(text1b, text2b, false, deadline);
          return diffs.concat(diffsb);
        };
        diff_match_patch2.prototype.diff_linesToChars_ = function(text1, text2) {
          var lineArray = [];
          var lineHash = {};
          lineArray[0] = "";
          function diff_linesToCharsMunge_(text) {
            var chars = "";
            var lineStart = 0;
            var lineEnd = -1;
            var lineArrayLength = lineArray.length;
            while (lineEnd < text.length - 1) {
              lineEnd = text.indexOf("\n", lineStart);
              if (lineEnd == -1) {
                lineEnd = text.length - 1;
              }
              var line = text.substring(lineStart, lineEnd + 1);
              lineStart = lineEnd + 1;
              if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
                chars += String.fromCharCode(lineHash[line]);
              } else {
                chars += String.fromCharCode(lineArrayLength);
                lineHash[line] = lineArrayLength;
                lineArray[lineArrayLength++] = line;
              }
            }
            return chars;
          }
          __name(diff_linesToCharsMunge_, "diff_linesToCharsMunge_");
          var chars1 = diff_linesToCharsMunge_(text1);
          var chars2 = diff_linesToCharsMunge_(text2);
          return { chars1, chars2, lineArray };
        };
        diff_match_patch2.prototype.diff_charsToLines_ = function(diffs, lineArray) {
          for (var x = 0; x < diffs.length; x++) {
            var chars = diffs[x][1];
            var text = [];
            for (var y = 0; y < chars.length; y++) {
              text[y] = lineArray[chars.charCodeAt(y)];
            }
            diffs[x][1] = text.join("");
          }
        };
        diff_match_patch2.prototype.diff_commonPrefix = function(text1, text2) {
          if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
            return 0;
          }
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerstart = 0;
          while (pointermin < pointermid) {
            if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
              pointermin = pointermid;
              pointerstart = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        };
        diff_match_patch2.prototype.diff_commonSuffix = function(text1, text2) {
          if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
            return 0;
          }
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerend = 0;
          while (pointermin < pointermid) {
            if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
              pointermin = pointermid;
              pointerend = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        };
        diff_match_patch2.prototype.diff_commonOverlap_ = function(text1, text2) {
          var text1_length = text1.length;
          var text2_length = text2.length;
          if (text1_length == 0 || text2_length == 0) {
            return 0;
          }
          if (text1_length > text2_length) {
            text1 = text1.substring(text1_length - text2_length);
          } else if (text1_length < text2_length) {
            text2 = text2.substring(0, text1_length);
          }
          var text_length = Math.min(text1_length, text2_length);
          if (text1 == text2) {
            return text_length;
          }
          var best = 0;
          var length = 1;
          while (true) {
            var pattern = text1.substring(text_length - length);
            var found = text2.indexOf(pattern);
            if (found == -1) {
              return best;
            }
            length += found;
            if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
              best = length;
              length++;
            }
          }
        };
        diff_match_patch2.prototype.diff_halfMatch_ = function(text1, text2) {
          if (this.Diff_Timeout <= 0) {
            return null;
          }
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
            return null;
          }
          var dmp = this;
          function diff_halfMatchI_(longtext2, shorttext2, i) {
            var seed2 = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
            var j = -1;
            var best_common = "";
            var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
            while ((j = shorttext2.indexOf(seed2, j + 1)) != -1) {
              var prefixLength = dmp.diff_commonPrefix(
                longtext2.substring(i),
                shorttext2.substring(j)
              );
              var suffixLength = dmp.diff_commonSuffix(
                longtext2.substring(0, i),
                shorttext2.substring(0, j)
              );
              if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
                best_longtext_a = longtext2.substring(0, i - suffixLength);
                best_longtext_b = longtext2.substring(i + prefixLength);
                best_shorttext_a = shorttext2.substring(0, j - suffixLength);
                best_shorttext_b = shorttext2.substring(j + prefixLength);
              }
            }
            if (best_common.length * 2 >= longtext2.length) {
              return [
                best_longtext_a,
                best_longtext_b,
                best_shorttext_a,
                best_shorttext_b,
                best_common
              ];
            } else {
              return null;
            }
          }
          __name(diff_halfMatchI_, "diff_halfMatchI_");
          var hm1 = diff_halfMatchI_(
            longtext,
            shorttext,
            Math.ceil(longtext.length / 4)
          );
          var hm2 = diff_halfMatchI_(
            longtext,
            shorttext,
            Math.ceil(longtext.length / 2)
          );
          var hm;
          if (!hm1 && !hm2) {
            return null;
          } else if (!hm2) {
            hm = hm1;
          } else if (!hm1) {
            hm = hm2;
          } else {
            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
          }
          var text1_a, text1_b, text2_a, text2_b;
          if (text1.length > text2.length) {
            text1_a = hm[0];
            text1_b = hm[1];
            text2_a = hm[2];
            text2_b = hm[3];
          } else {
            text2_a = hm[0];
            text2_b = hm[1];
            text1_a = hm[2];
            text1_b = hm[3];
          }
          var mid_common = hm[4];
          return [text1_a, text1_b, text2_a, text2_b, mid_common];
        };
        diff_match_patch2.prototype.diff_cleanupSemantic = function(diffs) {
          var changes = false;
          var equalities = [];
          var equalitiesLength = 0;
          var lastequality = null;
          var pointer = 0;
          var length_insertions1 = 0;
          var length_deletions1 = 0;
          var length_insertions2 = 0;
          var length_deletions2 = 0;
          while (pointer < diffs.length) {
            if (diffs[pointer][0] == DIFF_EQUAL) {
              equalities[equalitiesLength++] = pointer;
              length_insertions1 = length_insertions2;
              length_deletions1 = length_deletions2;
              length_insertions2 = 0;
              length_deletions2 = 0;
              lastequality = diffs[pointer][1];
            } else {
              if (diffs[pointer][0] == DIFF_INSERT) {
                length_insertions2 += diffs[pointer][1].length;
              } else {
                length_deletions2 += diffs[pointer][1].length;
              }
              if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(
                length_insertions2,
                length_deletions2
              )) {
                diffs.splice(
                  equalities[equalitiesLength - 1],
                  0,
                  [DIFF_DELETE, lastequality]
                );
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                equalitiesLength--;
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                length_insertions1 = 0;
                length_deletions1 = 0;
                length_insertions2 = 0;
                length_deletions2 = 0;
                lastequality = null;
                changes = true;
              }
            }
            pointer++;
          }
          if (changes) {
            this.diff_cleanupMerge(diffs);
          }
          this.diff_cleanupSemanticLossless(diffs);
          pointer = 1;
          while (pointer < diffs.length) {
            if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
              var deletion = diffs[pointer - 1][1];
              var insertion = diffs[pointer][1];
              var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
              var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
              if (overlap_length1 >= overlap_length2) {
                if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                  diffs.splice(
                    pointer,
                    0,
                    [DIFF_EQUAL, insertion.substring(0, overlap_length1)]
                  );
                  diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                  diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                  pointer++;
                }
              } else {
                if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                  diffs.splice(
                    pointer,
                    0,
                    [DIFF_EQUAL, deletion.substring(0, overlap_length2)]
                  );
                  diffs[pointer - 1][0] = DIFF_INSERT;
                  diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                  diffs[pointer + 1][0] = DIFF_DELETE;
                  diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                  pointer++;
                }
              }
              pointer++;
            }
            pointer++;
          }
        };
        diff_match_patch2.prototype.diff_cleanupSemanticLossless = function(diffs) {
          function diff_cleanupSemanticScore_(one, two) {
            if (!one || !two) {
              return 6;
            }
            var char1 = one.charAt(one.length - 1);
            var char2 = two.charAt(0);
            var nonAlphaNumeric1 = char1.match(diff_match_patch2.nonAlphaNumericRegex_);
            var nonAlphaNumeric2 = char2.match(diff_match_patch2.nonAlphaNumericRegex_);
            var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch2.whitespaceRegex_);
            var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch2.whitespaceRegex_);
            var lineBreak1 = whitespace1 && char1.match(diff_match_patch2.linebreakRegex_);
            var lineBreak2 = whitespace2 && char2.match(diff_match_patch2.linebreakRegex_);
            var blankLine1 = lineBreak1 && one.match(diff_match_patch2.blanklineEndRegex_);
            var blankLine2 = lineBreak2 && two.match(diff_match_patch2.blanklineStartRegex_);
            if (blankLine1 || blankLine2) {
              return 5;
            } else if (lineBreak1 || lineBreak2) {
              return 4;
            } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
              return 3;
            } else if (whitespace1 || whitespace2) {
              return 2;
            } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
              return 1;
            }
            return 0;
          }
          __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
          var pointer = 1;
          while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
              var equality1 = diffs[pointer - 1][1];
              var edit = diffs[pointer][1];
              var equality2 = diffs[pointer + 1][1];
              var commonOffset = this.diff_commonSuffix(equality1, edit);
              if (commonOffset) {
                var commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset);
                edit = commonString + edit.substring(0, edit.length - commonOffset);
                equality2 = commonString + equality2;
              }
              var bestEquality1 = equality1;
              var bestEdit = edit;
              var bestEquality2 = equality2;
              var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
              while (edit.charAt(0) === equality2.charAt(0)) {
                equality1 += edit.charAt(0);
                edit = edit.substring(1) + equality2.charAt(0);
                equality2 = equality2.substring(1);
                var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                if (score >= bestScore) {
                  bestScore = score;
                  bestEquality1 = equality1;
                  bestEdit = edit;
                  bestEquality2 = equality2;
                }
              }
              if (diffs[pointer - 1][1] != bestEquality1) {
                if (bestEquality1) {
                  diffs[pointer - 1][1] = bestEquality1;
                } else {
                  diffs.splice(pointer - 1, 1);
                  pointer--;
                }
                diffs[pointer][1] = bestEdit;
                if (bestEquality2) {
                  diffs[pointer + 1][1] = bestEquality2;
                } else {
                  diffs.splice(pointer + 1, 1);
                  pointer--;
                }
              }
            }
            pointer++;
          }
        };
        diff_match_patch2.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
        diff_match_patch2.whitespaceRegex_ = /\s/;
        diff_match_patch2.linebreakRegex_ = /[\r\n]/;
        diff_match_patch2.blanklineEndRegex_ = /\n\r?\n$/;
        diff_match_patch2.blanklineStartRegex_ = /^\r?\n\r?\n/;
        diff_match_patch2.prototype.diff_cleanupEfficiency = function(diffs) {
          var changes = false;
          var equalities = [];
          var equalitiesLength = 0;
          var lastequality = null;
          var pointer = 0;
          var pre_ins = false;
          var pre_del = false;
          var post_ins = false;
          var post_del = false;
          while (pointer < diffs.length) {
            if (diffs[pointer][0] == DIFF_EQUAL) {
              if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
                equalities[equalitiesLength++] = pointer;
                pre_ins = post_ins;
                pre_del = post_del;
                lastequality = diffs[pointer][1];
              } else {
                equalitiesLength = 0;
                lastequality = null;
              }
              post_ins = post_del = false;
            } else {
              if (diffs[pointer][0] == DIFF_DELETE) {
                post_del = true;
              } else {
                post_ins = true;
              }
              if (lastequality && (pre_ins && pre_del && post_ins && post_del || lastequality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
                diffs.splice(
                  equalities[equalitiesLength - 1],
                  0,
                  [DIFF_DELETE, lastequality]
                );
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                equalitiesLength--;
                lastequality = null;
                if (pre_ins && pre_del) {
                  post_ins = post_del = true;
                  equalitiesLength = 0;
                } else {
                  equalitiesLength--;
                  pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                  post_ins = post_del = false;
                }
                changes = true;
              }
            }
            pointer++;
          }
          if (changes) {
            this.diff_cleanupMerge(diffs);
          }
        };
        diff_match_patch2.prototype.diff_cleanupMerge = function(diffs) {
          diffs.push([DIFF_EQUAL, ""]);
          var pointer = 0;
          var count_delete = 0;
          var count_insert = 0;
          var text_delete = "";
          var text_insert = "";
          var commonlength;
          while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
              case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_EQUAL:
                if (count_delete + count_insert > 1) {
                  if (count_delete !== 0 && count_insert !== 0) {
                    commonlength = this.diff_commonPrefix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                        diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                      } else {
                        diffs.splice(0, 0, [
                          DIFF_EQUAL,
                          text_insert.substring(0, commonlength)
                        ]);
                        pointer++;
                      }
                      text_insert = text_insert.substring(commonlength);
                      text_delete = text_delete.substring(commonlength);
                    }
                    commonlength = this.diff_commonSuffix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                      text_insert = text_insert.substring(0, text_insert.length - commonlength);
                      text_delete = text_delete.substring(0, text_delete.length - commonlength);
                    }
                  }
                  if (count_delete === 0) {
                    diffs.splice(
                      pointer - count_insert,
                      count_delete + count_insert,
                      [DIFF_INSERT, text_insert]
                    );
                  } else if (count_insert === 0) {
                    diffs.splice(
                      pointer - count_delete,
                      count_delete + count_insert,
                      [DIFF_DELETE, text_delete]
                    );
                  } else {
                    diffs.splice(
                      pointer - count_delete - count_insert,
                      count_delete + count_insert,
                      [DIFF_DELETE, text_delete],
                      [DIFF_INSERT, text_insert]
                    );
                  }
                  pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - 1][1] += diffs[pointer][1];
                  diffs.splice(pointer, 1);
                } else {
                  pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = "";
                text_insert = "";
                break;
            }
          }
          if (diffs[diffs.length - 1][1] === "") {
            diffs.pop();
          }
          var changes = false;
          pointer = 1;
          while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
              if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
              } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
              }
            }
            pointer++;
          }
          if (changes) {
            this.diff_cleanupMerge(diffs);
          }
        };
        diff_match_patch2.prototype.diff_xIndex = function(diffs, loc) {
          var chars1 = 0;
          var chars2 = 0;
          var last_chars1 = 0;
          var last_chars2 = 0;
          var x;
          for (x = 0; x < diffs.length; x++) {
            if (diffs[x][0] !== DIFF_INSERT) {
              chars1 += diffs[x][1].length;
            }
            if (diffs[x][0] !== DIFF_DELETE) {
              chars2 += diffs[x][1].length;
            }
            if (chars1 > loc) {
              break;
            }
            last_chars1 = chars1;
            last_chars2 = chars2;
          }
          if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
            return last_chars2;
          }
          return last_chars2 + (loc - last_chars1);
        };
        diff_match_patch2.prototype.diff_prettyHtml = function(diffs) {
          var html2 = [];
          var pattern_amp = /&/g;
          var pattern_lt = /</g;
          var pattern_gt = />/g;
          var pattern_para = /\n/g;
          for (var x = 0; x < diffs.length; x++) {
            var op = diffs[x][0];
            var data = diffs[x][1];
            var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
            switch (op) {
              case DIFF_INSERT:
                html2[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
                break;
              case DIFF_DELETE:
                html2[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
                break;
              case DIFF_EQUAL:
                html2[x] = "<span>" + text + "</span>";
                break;
            }
          }
          return html2.join("");
        };
        diff_match_patch2.prototype.diff_text1 = function(diffs) {
          var text = [];
          for (var x = 0; x < diffs.length; x++) {
            if (diffs[x][0] !== DIFF_INSERT) {
              text[x] = diffs[x][1];
            }
          }
          return text.join("");
        };
        diff_match_patch2.prototype.diff_text2 = function(diffs) {
          var text = [];
          for (var x = 0; x < diffs.length; x++) {
            if (diffs[x][0] !== DIFF_DELETE) {
              text[x] = diffs[x][1];
            }
          }
          return text.join("");
        };
        diff_match_patch2.prototype.diff_levenshtein = function(diffs) {
          var levenshtein = 0;
          var insertions = 0;
          var deletions = 0;
          for (var x = 0; x < diffs.length; x++) {
            var op = diffs[x][0];
            var data = diffs[x][1];
            switch (op) {
              case DIFF_INSERT:
                insertions += data.length;
                break;
              case DIFF_DELETE:
                deletions += data.length;
                break;
              case DIFF_EQUAL:
                levenshtein += Math.max(insertions, deletions);
                insertions = 0;
                deletions = 0;
                break;
            }
          }
          levenshtein += Math.max(insertions, deletions);
          return levenshtein;
        };
        diff_match_patch2.prototype.diff_toDelta = function(diffs) {
          var text = [];
          for (var x = 0; x < diffs.length; x++) {
            switch (diffs[x][0]) {
              case DIFF_INSERT:
                text[x] = "+" + encodeURI(diffs[x][1]);
                break;
              case DIFF_DELETE:
                text[x] = "-" + diffs[x][1].length;
                break;
              case DIFF_EQUAL:
                text[x] = "=" + diffs[x][1].length;
                break;
            }
          }
          return text.join("	").replace(/%20/g, " ");
        };
        diff_match_patch2.prototype.diff_fromDelta = function(text1, delta) {
          var diffs = [];
          var diffsLength = 0;
          var pointer = 0;
          var tokens = delta.split(/\t/g);
          for (var x = 0; x < tokens.length; x++) {
            var param = tokens[x].substring(1);
            switch (tokens[x].charAt(0)) {
              case "+":
                try {
                  diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
                } catch (ex) {
                  throw new Error("Illegal escape in diff_fromDelta: " + param);
                }
                break;
              case "-":
              case "=":
                var n = parseInt(param, 10);
                if (isNaN(n) || n < 0) {
                  throw new Error("Invalid number in diff_fromDelta: " + param);
                }
                var text = text1.substring(pointer, pointer += n);
                if (tokens[x].charAt(0) == "=") {
                  diffs[diffsLength++] = [DIFF_EQUAL, text];
                } else {
                  diffs[diffsLength++] = [DIFF_DELETE, text];
                }
                break;
              default:
                if (tokens[x]) {
                  throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
                }
            }
          }
          if (pointer != text1.length) {
            throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
          }
          return diffs;
        };
        diff_match_patch2.prototype.match_main = function(text, pattern, loc) {
          if (text == null || pattern == null || loc == null) {
            throw new Error("Null input. (match_main)");
          }
          loc = Math.max(0, Math.min(loc, text.length));
          if (text == pattern) {
            return 0;
          } else if (!text.length) {
            return -1;
          } else if (text.substring(loc, loc + pattern.length) == pattern) {
            return loc;
          } else {
            return this.match_bitap_(text, pattern, loc);
          }
        };
        diff_match_patch2.prototype.match_bitap_ = function(text, pattern, loc) {
          if (pattern.length > this.Match_MaxBits) {
            throw new Error("Pattern too long for this browser.");
          }
          var s = this.match_alphabet_(pattern);
          var dmp = this;
          function match_bitapScore_(e, x) {
            var accuracy = e / pattern.length;
            var proximity = Math.abs(loc - x);
            if (!dmp.Match_Distance) {
              return proximity ? 1 : accuracy;
            }
            return accuracy + proximity / dmp.Match_Distance;
          }
          __name(match_bitapScore_, "match_bitapScore_");
          var score_threshold = this.Match_Threshold;
          var best_loc = text.indexOf(pattern, loc);
          if (best_loc != -1) {
            score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
            best_loc = text.lastIndexOf(pattern, loc + pattern.length);
            if (best_loc != -1) {
              score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
            }
          }
          var matchmask = 1 << pattern.length - 1;
          best_loc = -1;
          var bin_min, bin_mid;
          var bin_max = pattern.length + text.length;
          var last_rd;
          for (var d = 0; d < pattern.length; d++) {
            bin_min = 0;
            bin_mid = bin_max;
            while (bin_min < bin_mid) {
              if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                bin_min = bin_mid;
              } else {
                bin_max = bin_mid;
              }
              bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
            }
            bin_max = bin_mid;
            var start = Math.max(1, loc - bin_mid + 1);
            var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
            var rd = Array(finish + 2);
            rd[finish + 1] = (1 << d) - 1;
            for (var j = finish; j >= start; j--) {
              var charMatch = s[text.charAt(j - 1)];
              if (d === 0) {
                rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
              } else {
                rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
              }
              if (rd[j] & matchmask) {
                var score = match_bitapScore_(d, j - 1);
                if (score <= score_threshold) {
                  score_threshold = score;
                  best_loc = j - 1;
                  if (best_loc > loc) {
                    start = Math.max(1, 2 * loc - best_loc);
                  } else {
                    break;
                  }
                }
              }
            }
            if (match_bitapScore_(d + 1, loc) > score_threshold) {
              break;
            }
            last_rd = rd;
          }
          return best_loc;
        };
        diff_match_patch2.prototype.match_alphabet_ = function(pattern) {
          var s = {};
          for (var i = 0; i < pattern.length; i++) {
            s[pattern.charAt(i)] = 0;
          }
          for (var i = 0; i < pattern.length; i++) {
            s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
          }
          return s;
        };
        diff_match_patch2.prototype.patch_addContext_ = function(patch2, text) {
          if (text.length == 0) {
            return;
          }
          var pattern = text.substring(patch2.start2, patch2.start2 + patch2.length1);
          var padding = 0;
          while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
            padding += this.Patch_Margin;
            pattern = text.substring(
              patch2.start2 - padding,
              patch2.start2 + patch2.length1 + padding
            );
          }
          padding += this.Patch_Margin;
          var prefix = text.substring(patch2.start2 - padding, patch2.start2);
          if (prefix) {
            patch2.diffs.unshift([DIFF_EQUAL, prefix]);
          }
          var suffix = text.substring(
            patch2.start2 + patch2.length1,
            patch2.start2 + patch2.length1 + padding
          );
          if (suffix) {
            patch2.diffs.push([DIFF_EQUAL, suffix]);
          }
          patch2.start1 -= prefix.length;
          patch2.start2 -= prefix.length;
          patch2.length1 += prefix.length + suffix.length;
          patch2.length2 += prefix.length + suffix.length;
        };
        diff_match_patch2.prototype.patch_make = function(a, opt_b, opt_c) {
          var text1, diffs;
          if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
            text1 = /** @type {string} */
            a;
            diffs = this.diff_main(
              text1,
              /** @type {string} */
              opt_b,
              true
            );
            if (diffs.length > 2) {
              this.diff_cleanupSemantic(diffs);
              this.diff_cleanupEfficiency(diffs);
            }
          } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
            diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
            a;
            text1 = this.diff_text1(diffs);
          } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
            text1 = /** @type {string} */
            a;
            diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
            opt_b;
          } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
            text1 = /** @type {string} */
            a;
            diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
            opt_c;
          } else {
            throw new Error("Unknown call format to patch_make.");
          }
          if (diffs.length === 0) {
            return [];
          }
          var patches = [];
          var patch2 = new diff_match_patch2.patch_obj();
          var patchDiffLength = 0;
          var char_count1 = 0;
          var char_count2 = 0;
          var prepatch_text = text1;
          var postpatch_text = text1;
          for (var x = 0; x < diffs.length; x++) {
            var diff_type = diffs[x][0];
            var diff_text = diffs[x][1];
            if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
              patch2.start1 = char_count1;
              patch2.start2 = char_count2;
            }
            switch (diff_type) {
              case DIFF_INSERT:
                patch2.diffs[patchDiffLength++] = diffs[x];
                patch2.length2 += diff_text.length;
                postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
                break;
              case DIFF_DELETE:
                patch2.length1 += diff_text.length;
                patch2.diffs[patchDiffLength++] = diffs[x];
                postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
                break;
              case DIFF_EQUAL:
                if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
                  patch2.diffs[patchDiffLength++] = diffs[x];
                  patch2.length1 += diff_text.length;
                  patch2.length2 += diff_text.length;
                } else if (diff_text.length >= 2 * this.Patch_Margin) {
                  if (patchDiffLength) {
                    this.patch_addContext_(patch2, prepatch_text);
                    patches.push(patch2);
                    patch2 = new diff_match_patch2.patch_obj();
                    patchDiffLength = 0;
                    prepatch_text = postpatch_text;
                    char_count1 = char_count2;
                  }
                }
                break;
            }
            if (diff_type !== DIFF_INSERT) {
              char_count1 += diff_text.length;
            }
            if (diff_type !== DIFF_DELETE) {
              char_count2 += diff_text.length;
            }
          }
          if (patchDiffLength) {
            this.patch_addContext_(patch2, prepatch_text);
            patches.push(patch2);
          }
          return patches;
        };
        diff_match_patch2.prototype.patch_deepCopy = function(patches) {
          var patchesCopy = [];
          for (var x = 0; x < patches.length; x++) {
            var patch2 = patches[x];
            var patchCopy = new diff_match_patch2.patch_obj();
            patchCopy.diffs = [];
            for (var y = 0; y < patch2.diffs.length; y++) {
              patchCopy.diffs[y] = patch2.diffs[y].slice();
            }
            patchCopy.start1 = patch2.start1;
            patchCopy.start2 = patch2.start2;
            patchCopy.length1 = patch2.length1;
            patchCopy.length2 = patch2.length2;
            patchesCopy[x] = patchCopy;
          }
          return patchesCopy;
        };
        diff_match_patch2.prototype.patch_apply = function(patches, text) {
          if (patches.length == 0) {
            return [text, []];
          }
          patches = this.patch_deepCopy(patches);
          var nullPadding = this.patch_addPadding(patches);
          text = nullPadding + text + nullPadding;
          this.patch_splitMax(patches);
          var delta = 0;
          var results = [];
          for (var x = 0; x < patches.length; x++) {
            var expected_loc = patches[x].start2 + delta;
            var text1 = this.diff_text1(patches[x].diffs);
            var start_loc;
            var end_loc = -1;
            if (text1.length > this.Match_MaxBits) {
              start_loc = this.match_main(
                text,
                text1.substring(0, this.Match_MaxBits),
                expected_loc
              );
              if (start_loc != -1) {
                end_loc = this.match_main(
                  text,
                  text1.substring(text1.length - this.Match_MaxBits),
                  expected_loc + text1.length - this.Match_MaxBits
                );
                if (end_loc == -1 || start_loc >= end_loc) {
                  start_loc = -1;
                }
              }
            } else {
              start_loc = this.match_main(text, text1, expected_loc);
            }
            if (start_loc == -1) {
              results[x] = false;
              delta -= patches[x].length2 - patches[x].length1;
            } else {
              results[x] = true;
              delta = start_loc - expected_loc;
              var text2;
              if (end_loc == -1) {
                text2 = text.substring(start_loc, start_loc + text1.length);
              } else {
                text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
              }
              if (text1 == text2) {
                text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
              } else {
                var diffs = this.diff_main(text1, text2, false);
                if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
                  results[x] = false;
                } else {
                  this.diff_cleanupSemanticLossless(diffs);
                  var index1 = 0;
                  var index2;
                  for (var y = 0; y < patches[x].diffs.length; y++) {
                    var mod = patches[x].diffs[y];
                    if (mod[0] !== DIFF_EQUAL) {
                      index2 = this.diff_xIndex(diffs, index1);
                    }
                    if (mod[0] === DIFF_INSERT) {
                      text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
                    } else if (mod[0] === DIFF_DELETE) {
                      text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(
                        diffs,
                        index1 + mod[1].length
                      ));
                    }
                    if (mod[0] !== DIFF_DELETE) {
                      index1 += mod[1].length;
                    }
                  }
                }
              }
            }
          }
          text = text.substring(nullPadding.length, text.length - nullPadding.length);
          return [text, results];
        };
        diff_match_patch2.prototype.patch_addPadding = function(patches) {
          var paddingLength = this.Patch_Margin;
          var nullPadding = "";
          for (var x = 1; x <= paddingLength; x++) {
            nullPadding += String.fromCharCode(x);
          }
          for (var x = 0; x < patches.length; x++) {
            patches[x].start1 += paddingLength;
            patches[x].start2 += paddingLength;
          }
          var patch2 = patches[0];
          var diffs = patch2.diffs;
          if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
            diffs.unshift([DIFF_EQUAL, nullPadding]);
            patch2.start1 -= paddingLength;
            patch2.start2 -= paddingLength;
            patch2.length1 += paddingLength;
            patch2.length2 += paddingLength;
          } else if (paddingLength > diffs[0][1].length) {
            var extraLength = paddingLength - diffs[0][1].length;
            diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
            patch2.start1 -= extraLength;
            patch2.start2 -= extraLength;
            patch2.length1 += extraLength;
            patch2.length2 += extraLength;
          }
          patch2 = patches[patches.length - 1];
          diffs = patch2.diffs;
          if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
            diffs.push([DIFF_EQUAL, nullPadding]);
            patch2.length1 += paddingLength;
            patch2.length2 += paddingLength;
          } else if (paddingLength > diffs[diffs.length - 1][1].length) {
            var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
            diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
            patch2.length1 += extraLength;
            patch2.length2 += extraLength;
          }
          return nullPadding;
        };
        diff_match_patch2.prototype.patch_splitMax = function(patches) {
          var patch_size = this.Match_MaxBits;
          for (var x = 0; x < patches.length; x++) {
            if (patches[x].length1 <= patch_size) {
              continue;
            }
            var bigpatch = patches[x];
            patches.splice(x--, 1);
            var start1 = bigpatch.start1;
            var start2 = bigpatch.start2;
            var precontext = "";
            while (bigpatch.diffs.length !== 0) {
              var patch2 = new diff_match_patch2.patch_obj();
              var empty2 = true;
              patch2.start1 = start1 - precontext.length;
              patch2.start2 = start2 - precontext.length;
              if (precontext !== "") {
                patch2.length1 = patch2.length2 = precontext.length;
                patch2.diffs.push([DIFF_EQUAL, precontext]);
              }
              while (bigpatch.diffs.length !== 0 && patch2.length1 < patch_size - this.Patch_Margin) {
                var diff_type = bigpatch.diffs[0][0];
                var diff_text = bigpatch.diffs[0][1];
                if (diff_type === DIFF_INSERT) {
                  patch2.length2 += diff_text.length;
                  start2 += diff_text.length;
                  patch2.diffs.push(bigpatch.diffs.shift());
                  empty2 = false;
                } else if (diff_type === DIFF_DELETE && patch2.diffs.length == 1 && patch2.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
                  patch2.length1 += diff_text.length;
                  start1 += diff_text.length;
                  empty2 = false;
                  patch2.diffs.push([diff_type, diff_text]);
                  bigpatch.diffs.shift();
                } else {
                  diff_text = diff_text.substring(
                    0,
                    patch_size - patch2.length1 - this.Patch_Margin
                  );
                  patch2.length1 += diff_text.length;
                  start1 += diff_text.length;
                  if (diff_type === DIFF_EQUAL) {
                    patch2.length2 += diff_text.length;
                    start2 += diff_text.length;
                  } else {
                    empty2 = false;
                  }
                  patch2.diffs.push([diff_type, diff_text]);
                  if (diff_text == bigpatch.diffs[0][1]) {
                    bigpatch.diffs.shift();
                  } else {
                    bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
                  }
                }
              }
              precontext = this.diff_text2(patch2.diffs);
              precontext = precontext.substring(precontext.length - this.Patch_Margin);
              var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
              if (postcontext !== "") {
                patch2.length1 += postcontext.length;
                patch2.length2 += postcontext.length;
                if (patch2.diffs.length !== 0 && patch2.diffs[patch2.diffs.length - 1][0] === DIFF_EQUAL) {
                  patch2.diffs[patch2.diffs.length - 1][1] += postcontext;
                } else {
                  patch2.diffs.push([DIFF_EQUAL, postcontext]);
                }
              }
              if (!empty2) {
                patches.splice(++x, 0, patch2);
              }
            }
          }
        };
        diff_match_patch2.prototype.patch_toText = function(patches) {
          var text = [];
          for (var x = 0; x < patches.length; x++) {
            text[x] = patches[x];
          }
          return text.join("");
        };
        diff_match_patch2.prototype.patch_fromText = function(textline) {
          var patches = [];
          if (!textline) {
            return patches;
          }
          var text = textline.split("\n");
          var textPointer = 0;
          var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
          while (textPointer < text.length) {
            var m = text[textPointer].match(patchHeader);
            if (!m) {
              throw new Error("Invalid patch string: " + text[textPointer]);
            }
            var patch2 = new diff_match_patch2.patch_obj();
            patches.push(patch2);
            patch2.start1 = parseInt(m[1], 10);
            if (m[2] === "") {
              patch2.start1--;
              patch2.length1 = 1;
            } else if (m[2] == "0") {
              patch2.length1 = 0;
            } else {
              patch2.start1--;
              patch2.length1 = parseInt(m[2], 10);
            }
            patch2.start2 = parseInt(m[3], 10);
            if (m[4] === "") {
              patch2.start2--;
              patch2.length2 = 1;
            } else if (m[4] == "0") {
              patch2.length2 = 0;
            } else {
              patch2.start2--;
              patch2.length2 = parseInt(m[4], 10);
            }
            textPointer++;
            while (textPointer < text.length) {
              var sign = text[textPointer].charAt(0);
              try {
                var line = decodeURI(text[textPointer].substring(1));
              } catch (ex) {
                throw new Error("Illegal escape in patch_fromText: " + line);
              }
              if (sign == "-") {
                patch2.diffs.push([DIFF_DELETE, line]);
              } else if (sign == "+") {
                patch2.diffs.push([DIFF_INSERT, line]);
              } else if (sign == " ") {
                patch2.diffs.push([DIFF_EQUAL, line]);
              } else if (sign == "@") {
                break;
              } else if (sign === "")
                ;
              else {
                throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
              }
              textPointer++;
            }
          }
          return patches;
        };
        diff_match_patch2.patch_obj = function() {
          this.diffs = [];
          this.start1 = null;
          this.start2 = null;
          this.length1 = 0;
          this.length2 = 0;
        };
        diff_match_patch2.patch_obj.prototype.toString = function() {
          var coords1, coords2;
          if (this.length1 === 0) {
            coords1 = this.start1 + ",0";
          } else if (this.length1 == 1) {
            coords1 = this.start1 + 1;
          } else {
            coords1 = this.start1 + 1 + "," + this.length1;
          }
          if (this.length2 === 0) {
            coords2 = this.start2 + ",0";
          } else if (this.length2 == 1) {
            coords2 = this.start2 + 1;
          } else {
            coords2 = this.start2 + 1 + "," + this.length2;
          }
          var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
          var op;
          for (var x = 0; x < this.diffs.length; x++) {
            switch (this.diffs[x][0]) {
              case DIFF_INSERT:
                op = "+";
                break;
              case DIFF_DELETE:
                op = "-";
                break;
              case DIFF_EQUAL:
                op = " ";
                break;
            }
            text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
          }
          return text.join("").replace(/%20/g, " ");
        };
        module2.exports = diff_match_patch2;
        module2.exports["diff_match_patch"] = diff_match_patch2;
        module2.exports["DIFF_DELETE"] = DIFF_DELETE;
        module2.exports["DIFF_INSERT"] = DIFF_INSERT;
        module2.exports["DIFF_EQUAL"] = DIFF_EQUAL;
      });
      var TEXT_DIFF = 2;
      var DEFAULT_MIN_LENGTH = 60;
      var cachedDiffPatch = null;
      var getDiffMatchPatch = /* @__PURE__ */ __name(function getDiffMatchPatch2(required) {
        if (!cachedDiffPatch) {
          var instance = void 0;
          if (typeof diff_match_patch !== "undefined") {
            instance = typeof diff_match_patch === "function" ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
          } else if (diffMatchPatch) {
            try {
              instance = diffMatchPatch && new diffMatchPatch();
            } catch (err2) {
              instance = null;
            }
          }
          if (!instance) {
            if (!required) {
              return null;
            }
            var error = new Error("text diff_match_patch library not found");
            error.diff_match_patch_not_found = true;
            throw error;
          }
          cachedDiffPatch = {
            diff: /* @__PURE__ */ __name(function diff2(txt1, txt2) {
              return instance.patch_toText(instance.patch_make(txt1, txt2));
            }, "diff"),
            patch: /* @__PURE__ */ __name(function patch2(txt1, _patch) {
              var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);
              for (var i = 0; i < results[1].length; i++) {
                if (!results[1][i]) {
                  var _error = new Error("text patch failed");
                  _error.textPatchFailed = true;
                }
              }
              return results[0];
            }, "patch")
          };
        }
        return cachedDiffPatch;
      }, "getDiffMatchPatch");
      var diffFilter$3 = /* @__PURE__ */ __name(function textsDiffFilter(context) {
        if (context.leftType !== "string") {
          return;
        }
        var minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
        if (context.left.length < minLength || context.right.length < minLength) {
          context.setResult([context.left, context.right]).exit();
          return;
        }
        var diffMatchPatch$$1 = getDiffMatchPatch();
        if (!diffMatchPatch$$1) {
          context.setResult([context.left, context.right]).exit();
          return;
        }
        var diff2 = diffMatchPatch$$1.diff;
        context.setResult([diff2(context.left, context.right), 0, TEXT_DIFF]).exit();
      }, "textsDiffFilter");
      diffFilter$3.filterName = "texts";
      var patchFilter$3 = /* @__PURE__ */ __name(function textsPatchFilter(context) {
        if (context.nested) {
          return;
        }
        if (context.delta[2] !== TEXT_DIFF) {
          return;
        }
        var patch2 = getDiffMatchPatch(true).patch;
        context.setResult(patch2(context.left, context.delta[0])).exit();
      }, "textsPatchFilter");
      patchFilter$3.filterName = "texts";
      var textDeltaReverse = /* @__PURE__ */ __name(function textDeltaReverse2(delta) {
        var i = void 0;
        var l = void 0;
        var lines = void 0;
        var line = void 0;
        var lineTmp = void 0;
        var header = null;
        var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
        var lineHeader = void 0;
        lines = delta.split("\n");
        for (i = 0, l = lines.length; i < l; i++) {
          line = lines[i];
          var lineStart = line.slice(0, 1);
          if (lineStart === "@") {
            header = headerRegex.exec(line);
            lineHeader = i;
            lines[lineHeader] = "@@ -" + header[3] + "," + header[4] + " +" + header[1] + "," + header[2] + " @@";
          } else if (lineStart === "+") {
            lines[i] = "-" + lines[i].slice(1);
            if (lines[i - 1].slice(0, 1) === "+") {
              lineTmp = lines[i];
              lines[i] = lines[i - 1];
              lines[i - 1] = lineTmp;
            }
          } else if (lineStart === "-") {
            lines[i] = "+" + lines[i].slice(1);
          }
        }
        return lines.join("\n");
      }, "textDeltaReverse");
      var reverseFilter$3 = /* @__PURE__ */ __name(function textsReverseFilter(context) {
        if (context.nested) {
          return;
        }
        if (context.delta[2] !== TEXT_DIFF) {
          return;
        }
        context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
      }, "textsReverseFilter");
      reverseFilter$3.filterName = "texts";
      var DiffPatcher = function() {
        function DiffPatcher2(options) {
          classCallCheck(this, DiffPatcher2);
          this.processor = new Processor(options);
          this.processor.pipe(new Pipe("diff").append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
          this.processor.pipe(new Pipe("patch").append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
          this.processor.pipe(new Pipe("reverse").append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
        }
        __name(DiffPatcher2, "DiffPatcher");
        createClass(DiffPatcher2, [{
          key: "options",
          value: /* @__PURE__ */ __name(function options() {
            var _processor;
            return (_processor = this.processor).options.apply(_processor, arguments);
          }, "options")
        }, {
          key: "diff",
          value: /* @__PURE__ */ __name(function diff2(left, right) {
            return this.processor.process(new DiffContext(left, right));
          }, "diff")
        }, {
          key: "patch",
          value: /* @__PURE__ */ __name(function patch2(left, delta) {
            return this.processor.process(new PatchContext(left, delta));
          }, "patch")
        }, {
          key: "reverse",
          value: /* @__PURE__ */ __name(function reverse2(delta) {
            return this.processor.process(new ReverseContext(delta));
          }, "reverse")
        }, {
          key: "unpatch",
          value: /* @__PURE__ */ __name(function unpatch2(right, delta) {
            return this.patch(right, this.reverse(delta));
          }, "unpatch")
        }, {
          key: "clone",
          value: /* @__PURE__ */ __name(function clone$$1(value) {
            return clone(value);
          }, "clone$$1")
        }]);
        return DiffPatcher2;
      }();
      var isArray$3 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      };
      var getObjectKeys = typeof Object.keys === "function" ? function(obj) {
        return Object.keys(obj);
      } : function(obj) {
        var names = [];
        for (var property in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, property)) {
            names.push(property);
          }
        }
        return names;
      };
      var trimUnderscore = /* @__PURE__ */ __name(function trimUnderscore2(str) {
        if (str.substr(0, 1) === "_") {
          return str.slice(1);
        }
        return str;
      }, "trimUnderscore");
      var arrayKeyToSortNumber = /* @__PURE__ */ __name(function arrayKeyToSortNumber2(key) {
        if (key === "_t") {
          return -1;
        } else {
          if (key.substr(0, 1) === "_") {
            return parseInt(key.slice(1), 10);
          } else {
            return parseInt(key, 10) + 0.1;
          }
        }
      }, "arrayKeyToSortNumber");
      var arrayKeyComparer = /* @__PURE__ */ __name(function arrayKeyComparer2(key1, key2) {
        return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
      }, "arrayKeyComparer");
      var BaseFormatter = function() {
        function BaseFormatter2() {
          classCallCheck(this, BaseFormatter2);
        }
        __name(BaseFormatter2, "BaseFormatter");
        createClass(BaseFormatter2, [{
          key: "format",
          value: /* @__PURE__ */ __name(function format3(delta, left) {
            var context = {};
            this.prepareContext(context);
            this.recurse(context, delta, left);
            return this.finalize(context);
          }, "format")
        }, {
          key: "prepareContext",
          value: /* @__PURE__ */ __name(function prepareContext(context) {
            context.buffer = [];
            context.out = function() {
              var _buffer;
              (_buffer = this.buffer).push.apply(_buffer, arguments);
            };
          }, "prepareContext")
        }, {
          key: "typeFormattterNotFound",
          value: /* @__PURE__ */ __name(function typeFormattterNotFound(context, deltaType) {
            throw new Error("cannot format delta type: " + deltaType);
          }, "typeFormattterNotFound")
        }, {
          key: "typeFormattterErrorFormatter",
          value: /* @__PURE__ */ __name(function typeFormattterErrorFormatter(context, err2) {
            return err2.toString();
          }, "typeFormattterErrorFormatter")
        }, {
          key: "finalize",
          value: /* @__PURE__ */ __name(function finalize(_ref) {
            var buffer2 = _ref.buffer;
            if (isArray$3(buffer2)) {
              return buffer2.join("");
            }
          }, "finalize")
        }, {
          key: "recurse",
          value: /* @__PURE__ */ __name(function recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
            var useMoveOriginHere = delta && movedFrom;
            var leftValue = useMoveOriginHere ? movedFrom.value : left;
            if (typeof delta === "undefined" && typeof key === "undefined") {
              return void 0;
            }
            var type = this.getDeltaType(delta, movedFrom);
            var nodeType = type === "node" ? delta._t === "a" ? "array" : "object" : "";
            if (typeof key !== "undefined") {
              this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
            } else {
              this.rootBegin(context, type, nodeType);
            }
            var typeFormattter = void 0;
            try {
              typeFormattter = this["format_" + type] || this.typeFormattterNotFound(context, type);
              typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
            } catch (err2) {
              this.typeFormattterErrorFormatter(context, err2, delta, leftValue, key, leftKey, movedFrom);
              if (typeof console !== "undefined" && console.error) {
                console.error(err2.stack);
              }
            }
            if (typeof key !== "undefined") {
              this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
            } else {
              this.rootEnd(context, type, nodeType);
            }
          }, "recurse")
        }, {
          key: "formatDeltaChildren",
          value: /* @__PURE__ */ __name(function formatDeltaChildren(context, delta, left) {
            var self2 = this;
            this.forEachDeltaKey(delta, left, function(key, leftKey, movedFrom, isLast) {
              self2.recurse(context, delta[key], left ? left[leftKey] : void 0, key, leftKey, movedFrom, isLast);
            });
          }, "formatDeltaChildren")
        }, {
          key: "forEachDeltaKey",
          value: /* @__PURE__ */ __name(function forEachDeltaKey(delta, left, fn) {
            var keys = getObjectKeys(delta);
            var arrayKeys = delta._t === "a";
            var moveDestinations = {};
            var name = void 0;
            if (typeof left !== "undefined") {
              for (name in left) {
                if (Object.prototype.hasOwnProperty.call(left, name)) {
                  if (typeof delta[name] === "undefined" && (!arrayKeys || typeof delta["_" + name] === "undefined")) {
                    keys.push(name);
                  }
                }
              }
            }
            for (name in delta) {
              if (Object.prototype.hasOwnProperty.call(delta, name)) {
                var value = delta[name];
                if (isArray$3(value) && value[2] === 3) {
                  moveDestinations[value[1].toString()] = {
                    key: name,
                    value: left && left[parseInt(name.substr(1))]
                  };
                  if (this.includeMoveDestinations !== false) {
                    if (typeof left === "undefined" && typeof delta[value[1]] === "undefined") {
                      keys.push(value[1].toString());
                    }
                  }
                }
              }
            }
            if (arrayKeys) {
              keys.sort(arrayKeyComparer);
            } else {
              keys.sort();
            }
            for (var index2 = 0, length = keys.length; index2 < length; index2++) {
              var key = keys[index2];
              if (arrayKeys && key === "_t") {
                continue;
              }
              var leftKey = arrayKeys ? typeof key === "number" ? key : parseInt(trimUnderscore(key), 10) : key;
              var isLast = index2 === length - 1;
              fn(key, leftKey, moveDestinations[leftKey], isLast);
            }
          }, "forEachDeltaKey")
        }, {
          key: "getDeltaType",
          value: /* @__PURE__ */ __name(function getDeltaType(delta, movedFrom) {
            if (typeof delta === "undefined") {
              if (typeof movedFrom !== "undefined") {
                return "movedestination";
              }
              return "unchanged";
            }
            if (isArray$3(delta)) {
              if (delta.length === 1) {
                return "added";
              }
              if (delta.length === 2) {
                return "modified";
              }
              if (delta.length === 3 && delta[2] === 0) {
                return "deleted";
              }
              if (delta.length === 3 && delta[2] === 2) {
                return "textdiff";
              }
              if (delta.length === 3 && delta[2] === 3) {
                return "moved";
              }
            } else if ((typeof delta === "undefined" ? "undefined" : _typeof(delta)) === "object") {
              return "node";
            }
            return "unknown";
          }, "getDeltaType")
        }, {
          key: "parseTextDiff",
          value: /* @__PURE__ */ __name(function parseTextDiff(value) {
            var output = [];
            var lines = value.split("\n@@ ");
            for (var i = 0, l = lines.length; i < l; i++) {
              var line = lines[i];
              var lineOutput = {
                pieces: []
              };
              var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
              lineOutput.location = {
                line: location[0],
                chr: location[1]
              };
              var pieces = line.split("\n").slice(1);
              for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
                var piece = pieces[pieceIndex];
                if (!piece.length) {
                  continue;
                }
                var pieceOutput = {
                  type: "context"
                };
                if (piece.substr(0, 1) === "+") {
                  pieceOutput.type = "added";
                } else if (piece.substr(0, 1) === "-") {
                  pieceOutput.type = "deleted";
                }
                pieceOutput.text = piece.slice(1);
                lineOutput.pieces.push(pieceOutput);
              }
              output.push(lineOutput);
            }
            return output;
          }, "parseTextDiff")
        }]);
        return BaseFormatter2;
      }();
      var base = Object.freeze({
        default: BaseFormatter
      });
      var HtmlFormatter = function(_BaseFormatter) {
        inherits2(HtmlFormatter2, _BaseFormatter);
        function HtmlFormatter2() {
          classCallCheck(this, HtmlFormatter2);
          return possibleConstructorReturn(this, (HtmlFormatter2.__proto__ || Object.getPrototypeOf(HtmlFormatter2)).apply(this, arguments));
        }
        __name(HtmlFormatter2, "HtmlFormatter");
        createClass(HtmlFormatter2, [{
          key: "typeFormattterErrorFormatter",
          value: /* @__PURE__ */ __name(function typeFormattterErrorFormatter(context, err2) {
            context.out('<pre class="jsondiffpatch-error">' + err2 + "</pre>");
          }, "typeFormattterErrorFormatter")
        }, {
          key: "formatValue",
          value: /* @__PURE__ */ __name(function formatValue(context, value) {
            context.out("<pre>" + htmlEscape(JSON.stringify(value, null, 2)) + "</pre>");
          }, "formatValue")
        }, {
          key: "formatTextDiffString",
          value: /* @__PURE__ */ __name(function formatTextDiffString(context, value) {
            var lines = this.parseTextDiff(value);
            context.out('<ul class="jsondiffpatch-textdiff">');
            for (var i = 0, l = lines.length; i < l; i++) {
              var line = lines[i];
              context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
              var pieces = line.pieces;
              for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
                var piece = pieces[pieceIndex];
                context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + "</span>");
              }
              context.out("</div></li>");
            }
            context.out("</ul>");
          }, "formatTextDiffString")
        }, {
          key: "rootBegin",
          value: /* @__PURE__ */ __name(function rootBegin(context, type, nodeType) {
            var nodeClass = "jsondiffpatch-" + type + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
            context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
          }, "rootBegin")
        }, {
          key: "rootEnd",
          value: /* @__PURE__ */ __name(function rootEnd(context) {
            context.out("</div>" + (context.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ",10);<\/script>") : ""));
          }, "rootEnd")
        }, {
          key: "nodeBegin",
          value: /* @__PURE__ */ __name(function nodeBegin(context, key, leftKey, type, nodeType) {
            var nodeClass = "jsondiffpatch-" + type + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
            context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + "</div>"));
          }, "nodeBegin")
        }, {
          key: "nodeEnd",
          value: /* @__PURE__ */ __name(function nodeEnd(context) {
            context.out("</li>");
          }, "nodeEnd")
          /* jshint camelcase: false */
          /* eslint-disable camelcase */
        }, {
          key: "format_unchanged",
          value: /* @__PURE__ */ __name(function format_unchanged(context, delta, left) {
            if (typeof left === "undefined") {
              return;
            }
            context.out('<div class="jsondiffpatch-value">');
            this.formatValue(context, left);
            context.out("</div>");
          }, "format_unchanged")
        }, {
          key: "format_movedestination",
          value: /* @__PURE__ */ __name(function format_movedestination(context, delta, left) {
            if (typeof left === "undefined") {
              return;
            }
            context.out('<div class="jsondiffpatch-value">');
            this.formatValue(context, left);
            context.out("</div>");
          }, "format_movedestination")
        }, {
          key: "format_node",
          value: /* @__PURE__ */ __name(function format_node(context, delta, left) {
            var nodeType = delta._t === "a" ? "array" : "object";
            context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
            this.formatDeltaChildren(context, delta, left);
            context.out("</ul>");
          }, "format_node")
        }, {
          key: "format_added",
          value: /* @__PURE__ */ __name(function format_added(context, delta) {
            context.out('<div class="jsondiffpatch-value">');
            this.formatValue(context, delta[0]);
            context.out("</div>");
          }, "format_added")
        }, {
          key: "format_modified",
          value: /* @__PURE__ */ __name(function format_modified(context, delta) {
            context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
            this.formatValue(context, delta[0]);
            context.out('</div><div class="jsondiffpatch-value jsondiffpatch-right-value">');
            this.formatValue(context, delta[1]);
            context.out("</div>");
          }, "format_modified")
        }, {
          key: "format_deleted",
          value: /* @__PURE__ */ __name(function format_deleted(context, delta) {
            context.out('<div class="jsondiffpatch-value">');
            this.formatValue(context, delta[0]);
            context.out("</div>");
          }, "format_deleted")
        }, {
          key: "format_moved",
          value: /* @__PURE__ */ __name(function format_moved(context, delta) {
            context.out('<div class="jsondiffpatch-value">');
            this.formatValue(context, delta[0]);
            context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + "</div>");
            context.out(
              /* jshint multistr: true */
              '<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\n          <svg width="30" height="60" style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'
            );
            context.hasArrows = true;
          }, "format_moved")
        }, {
          key: "format_textdiff",
          value: /* @__PURE__ */ __name(function format_textdiff(context, delta) {
            context.out('<div class="jsondiffpatch-value">');
            this.formatTextDiffString(context, delta[0]);
            context.out("</div>");
          }, "format_textdiff")
        }]);
        return HtmlFormatter2;
      }(BaseFormatter);
      function htmlEscape(text) {
        var html2 = text;
        var replacements = [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/'/g, "&apos;"], [/"/g, "&quot;"]];
        for (var i = 0; i < replacements.length; i++) {
          html2 = html2.replace(replacements[i][0], replacements[i][1]);
        }
        return html2;
      }
      __name(htmlEscape, "htmlEscape");
      var adjustArrows = /* @__PURE__ */ __name(function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
        var node = nodeArg || document;
        var getElementText = /* @__PURE__ */ __name(function getElementText2(_ref) {
          var textContent = _ref.textContent, innerText = _ref.innerText;
          return textContent || innerText;
        }, "getElementText");
        var eachByQuery = /* @__PURE__ */ __name(function eachByQuery2(el, query, fn) {
          var elems = el.querySelectorAll(query);
          for (var i = 0, l = elems.length; i < l; i++) {
            fn(elems[i]);
          }
        }, "eachByQuery");
        var eachChildren = /* @__PURE__ */ __name(function eachChildren2(_ref2, fn) {
          var children = _ref2.children;
          for (var i = 0, l = children.length; i < l; i++) {
            fn(children[i], i);
          }
        }, "eachChildren");
        eachByQuery(node, ".jsondiffpatch-arrow", function(_ref3) {
          var parentNode = _ref3.parentNode, children = _ref3.children, style = _ref3.style;
          var arrowParent = parentNode;
          var svg = children[0];
          var path = svg.children[1];
          svg.style.display = "none";
          var destination = getElementText(arrowParent.querySelector(".jsondiffpatch-moved-destination"));
          var container = arrowParent.parentNode;
          var destinationElem = void 0;
          eachChildren(container, function(child) {
            if (child.getAttribute("data-key") === destination) {
              destinationElem = child;
            }
          });
          if (!destinationElem) {
            return;
          }
          try {
            var distance = destinationElem.offsetTop - arrowParent.offsetTop;
            svg.setAttribute("height", Math.abs(distance) + 6);
            style.top = -8 + (distance > 0 ? 0 : distance) + "px";
            var curve = distance > 0 ? "M30,0 Q-10," + Math.round(distance / 2) + " 26," + (distance - 4) : "M30," + -distance + " Q-10," + Math.round(-distance / 2) + " 26,4";
            path.setAttribute("d", curve);
            svg.style.display = "";
          } catch (err2) {
          }
        });
      }, "jsondiffpatchHtmlFormatterAdjustArrows");
      var showUnchanged = /* @__PURE__ */ __name(function showUnchanged2(show, node, delay) {
        var el = node || document.body;
        var prefix = "jsondiffpatch-unchanged-";
        var classes = {
          showing: prefix + "showing",
          hiding: prefix + "hiding",
          visible: prefix + "visible",
          hidden: prefix + "hidden"
        };
        var list = el.classList;
        if (!list) {
          return;
        }
        if (!delay) {
          list.remove(classes.showing);
          list.remove(classes.hiding);
          list.remove(classes.visible);
          list.remove(classes.hidden);
          if (show === false) {
            list.add(classes.hidden);
          }
          return;
        }
        if (show === false) {
          list.remove(classes.showing);
          list.add(classes.visible);
          setTimeout(function() {
            list.add(classes.hiding);
          }, 10);
        } else {
          list.remove(classes.hiding);
          list.add(classes.showing);
          list.remove(classes.hidden);
        }
        var intervalId = setInterval(function() {
          adjustArrows(el);
        }, 100);
        setTimeout(function() {
          list.remove(classes.showing);
          list.remove(classes.hiding);
          if (show === false) {
            list.add(classes.hidden);
            list.remove(classes.visible);
          } else {
            list.add(classes.visible);
            list.remove(classes.hidden);
          }
          setTimeout(function() {
            list.remove(classes.visible);
            clearInterval(intervalId);
          }, delay + 400);
        }, delay);
      }, "showUnchanged");
      var hideUnchanged = /* @__PURE__ */ __name(function hideUnchanged2(node, delay) {
        return showUnchanged(false, node, delay);
      }, "hideUnchanged");
      var defaultInstance = void 0;
      function format2(delta, left) {
        if (!defaultInstance) {
          defaultInstance = new HtmlFormatter();
        }
        return defaultInstance.format(delta, left);
      }
      __name(format2, "format");
      var html = Object.freeze({
        showUnchanged,
        hideUnchanged,
        default: HtmlFormatter,
        format: format2
      });
      var AnnotatedFormatter = function(_BaseFormatter) {
        inherits2(AnnotatedFormatter2, _BaseFormatter);
        function AnnotatedFormatter2() {
          classCallCheck(this, AnnotatedFormatter2);
          var _this = possibleConstructorReturn(this, (AnnotatedFormatter2.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2)).call(this));
          _this.includeMoveDestinations = false;
          return _this;
        }
        __name(AnnotatedFormatter2, "AnnotatedFormatter");
        createClass(AnnotatedFormatter2, [{
          key: "prepareContext",
          value: /* @__PURE__ */ __name(function prepareContext(context) {
            get2(AnnotatedFormatter2.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2.prototype), "prepareContext", this).call(this, context);
            context.indent = function(levels) {
              this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
              this.indentPad = new Array(this.indentLevel + 1).join("&nbsp;&nbsp;");
            };
            context.row = function(json, htmlNote) {
              context.out('<tr><td style="white-space: nowrap;"><pre class="jsondiffpatch-annotated-indent" style="display: inline-block">');
              context.out(context.indentPad);
              context.out('</pre><pre style="display: inline-block">');
              context.out(json);
              context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
              context.out(htmlNote);
              context.out("</div></td></tr>");
            };
          }, "prepareContext")
        }, {
          key: "typeFormattterErrorFormatter",
          value: /* @__PURE__ */ __name(function typeFormattterErrorFormatter(context, err2) {
            context.row("", '<pre class="jsondiffpatch-error">' + err2 + "</pre>");
          }, "typeFormattterErrorFormatter")
        }, {
          key: "formatTextDiffString",
          value: /* @__PURE__ */ __name(function formatTextDiffString(context, value) {
            var lines = this.parseTextDiff(value);
            context.out('<ul class="jsondiffpatch-textdiff">');
            for (var i = 0, l = lines.length; i < l; i++) {
              var line = lines[i];
              context.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
              var pieces = line.pieces;
              for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
                var piece = pieces[pieceIndex];
                context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + "</span>");
              }
              context.out("</div></li>");
            }
            context.out("</ul>");
          }, "formatTextDiffString")
        }, {
          key: "rootBegin",
          value: /* @__PURE__ */ __name(function rootBegin(context, type, nodeType) {
            context.out('<table class="jsondiffpatch-annotated-delta">');
            if (type === "node") {
              context.row("{");
              context.indent();
            }
            if (nodeType === "array") {
              context.row('"_t": "a",', "Array delta (member names indicate array indices)");
            }
          }, "rootBegin")
        }, {
          key: "rootEnd",
          value: /* @__PURE__ */ __name(function rootEnd(context, type) {
            if (type === "node") {
              context.indent(-1);
              context.row("}");
            }
            context.out("</table>");
          }, "rootEnd")
        }, {
          key: "nodeBegin",
          value: /* @__PURE__ */ __name(function nodeBegin(context, key, leftKey, type, nodeType) {
            context.row("&quot;" + key + "&quot;: {");
            if (type === "node") {
              context.indent();
            }
            if (nodeType === "array") {
              context.row('"_t": "a",', "Array delta (member names indicate array indices)");
            }
          }, "nodeBegin")
        }, {
          key: "nodeEnd",
          value: /* @__PURE__ */ __name(function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
            if (type === "node") {
              context.indent(-1);
            }
            context.row("}" + (isLast ? "" : ","));
          }, "nodeEnd")
          /* jshint camelcase: false */
          /* eslint-disable camelcase */
        }, {
          key: "format_unchanged",
          value: /* @__PURE__ */ __name(function format_unchanged() {
          }, "format_unchanged")
        }, {
          key: "format_movedestination",
          value: /* @__PURE__ */ __name(function format_movedestination() {
          }, "format_movedestination")
        }, {
          key: "format_node",
          value: /* @__PURE__ */ __name(function format_node(context, delta, left) {
            this.formatDeltaChildren(context, delta, left);
          }, "format_node")
        }]);
        return AnnotatedFormatter2;
      }(BaseFormatter);
      var wrapPropertyName = /* @__PURE__ */ __name(function wrapPropertyName2(name) {
        return '<pre style="display:inline-block">&quot;' + name + "&quot;</pre>";
      }, "wrapPropertyName");
      var deltaAnnotations = {
        added: /* @__PURE__ */ __name(function added(delta, left, key, leftKey) {
          var formatLegend = " <pre>([newValue])</pre>";
          if (typeof leftKey === "undefined") {
            return "new value" + formatLegend;
          }
          if (typeof leftKey === "number") {
            return "insert at index " + leftKey + formatLegend;
          }
          return "add property " + wrapPropertyName(leftKey) + formatLegend;
        }, "added"),
        modified: /* @__PURE__ */ __name(function modified(delta, left, key, leftKey) {
          var formatLegend = " <pre>([previousValue, newValue])</pre>";
          if (typeof leftKey === "undefined") {
            return "modify value" + formatLegend;
          }
          if (typeof leftKey === "number") {
            return "modify at index " + leftKey + formatLegend;
          }
          return "modify property " + wrapPropertyName(leftKey) + formatLegend;
        }, "modified"),
        deleted: /* @__PURE__ */ __name(function deleted(delta, left, key, leftKey) {
          var formatLegend = " <pre>([previousValue, 0, 0])</pre>";
          if (typeof leftKey === "undefined") {
            return "delete value" + formatLegend;
          }
          if (typeof leftKey === "number") {
            return "remove index " + leftKey + formatLegend;
          }
          return "delete property " + wrapPropertyName(leftKey) + formatLegend;
        }, "deleted"),
        moved: /* @__PURE__ */ __name(function moved(delta, left, key, leftKey) {
          return 'move from <span title="(position to remove at original state)">' + ("index " + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + "</span>");
        }, "moved"),
        textdiff: /* @__PURE__ */ __name(function textdiff(delta, left, key, leftKey) {
          var location = typeof leftKey === "undefined" ? "" : typeof leftKey === "number" ? " at index " + leftKey : " at property " + wrapPropertyName(leftKey);
          return "text diff" + location + ', format is <a href="https://code.google.com/p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
        }, "textdiff")
      };
      var formatAnyChange = /* @__PURE__ */ __name(function formatAnyChange2(context, delta) {
        var deltaType = this.getDeltaType(delta);
        var annotator = deltaAnnotations[deltaType];
        var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
        var json = JSON.stringify(delta, null, 2);
        if (deltaType === "textdiff") {
          json = json.split("\\n").join('\\n"+\n   "');
        }
        context.indent();
        context.row(json, htmlNote);
        context.indent(-1);
      }, "formatAnyChange");
      AnnotatedFormatter.prototype.format_added = formatAnyChange;
      AnnotatedFormatter.prototype.format_modified = formatAnyChange;
      AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
      AnnotatedFormatter.prototype.format_moved = formatAnyChange;
      AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
      var defaultInstance$1 = void 0;
      function format$1(delta, left) {
        if (!defaultInstance$1) {
          defaultInstance$1 = new AnnotatedFormatter();
        }
        return defaultInstance$1.format(delta, left);
      }
      __name(format$1, "format$1");
      var annotated = Object.freeze({
        default: AnnotatedFormatter,
        format: format$1
      });
      var OPERATIONS = {
        add: "add",
        remove: "remove",
        replace: "replace",
        move: "move"
      };
      var JSONFormatter = function(_BaseFormatter) {
        inherits2(JSONFormatter2, _BaseFormatter);
        function JSONFormatter2() {
          classCallCheck(this, JSONFormatter2);
          var _this = possibleConstructorReturn(this, (JSONFormatter2.__proto__ || Object.getPrototypeOf(JSONFormatter2)).call(this));
          _this.includeMoveDestinations = true;
          return _this;
        }
        __name(JSONFormatter2, "JSONFormatter");
        createClass(JSONFormatter2, [{
          key: "prepareContext",
          value: /* @__PURE__ */ __name(function prepareContext(context) {
            get2(JSONFormatter2.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter2.prototype), "prepareContext", this).call(this, context);
            context.result = [];
            context.path = [];
            context.pushCurrentOp = function(obj) {
              var op = obj.op, value = obj.value;
              var val2 = {
                op,
                path: this.currentPath()
              };
              if (typeof value !== "undefined") {
                val2.value = value;
              }
              this.result.push(val2);
            };
            context.pushMoveOp = function(to) {
              var from = this.currentPath();
              this.result.push({
                op: OPERATIONS.move,
                from,
                path: this.toPath(to)
              });
            };
            context.currentPath = function() {
              return "/" + this.path.join("/");
            };
            context.toPath = function(toPath) {
              var to = this.path.slice();
              to[to.length - 1] = toPath;
              return "/" + to.join("/");
            };
          }, "prepareContext")
        }, {
          key: "typeFormattterErrorFormatter",
          value: /* @__PURE__ */ __name(function typeFormattterErrorFormatter(context, err2) {
            context.out("[ERROR] " + err2);
          }, "typeFormattterErrorFormatter")
        }, {
          key: "rootBegin",
          value: /* @__PURE__ */ __name(function rootBegin() {
          }, "rootBegin")
        }, {
          key: "rootEnd",
          value: /* @__PURE__ */ __name(function rootEnd() {
          }, "rootEnd")
        }, {
          key: "nodeBegin",
          value: /* @__PURE__ */ __name(function nodeBegin(_ref, key, leftKey) {
            var path = _ref.path;
            path.push(leftKey);
          }, "nodeBegin")
        }, {
          key: "nodeEnd",
          value: /* @__PURE__ */ __name(function nodeEnd(_ref2) {
            var path = _ref2.path;
            path.pop();
          }, "nodeEnd")
          /* jshint camelcase: false */
          /* eslint-disable camelcase */
        }, {
          key: "format_unchanged",
          value: /* @__PURE__ */ __name(function format_unchanged() {
          }, "format_unchanged")
        }, {
          key: "format_movedestination",
          value: /* @__PURE__ */ __name(function format_movedestination() {
          }, "format_movedestination")
        }, {
          key: "format_node",
          value: /* @__PURE__ */ __name(function format_node(context, delta, left) {
            this.formatDeltaChildren(context, delta, left);
          }, "format_node")
        }, {
          key: "format_added",
          value: /* @__PURE__ */ __name(function format_added(context, delta) {
            context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
          }, "format_added")
        }, {
          key: "format_modified",
          value: /* @__PURE__ */ __name(function format_modified(context, delta) {
            context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
          }, "format_modified")
        }, {
          key: "format_deleted",
          value: /* @__PURE__ */ __name(function format_deleted(context) {
            context.pushCurrentOp({ op: OPERATIONS.remove });
          }, "format_deleted")
        }, {
          key: "format_moved",
          value: /* @__PURE__ */ __name(function format_moved(context, delta) {
            var to = delta[1];
            context.pushMoveOp(to);
          }, "format_moved")
        }, {
          key: "format_textdiff",
          value: /* @__PURE__ */ __name(function format_textdiff() {
            throw new Error("Not implemented");
          }, "format_textdiff")
        }, {
          key: "format",
          value: /* @__PURE__ */ __name(function format3(delta, left) {
            var context = {};
            this.prepareContext(context);
            this.recurse(context, delta, left);
            return context.result;
          }, "format")
        }]);
        return JSONFormatter2;
      }(BaseFormatter);
      var last = /* @__PURE__ */ __name(function last2(arr) {
        return arr[arr.length - 1];
      }, "last");
      var sortBy = /* @__PURE__ */ __name(function sortBy2(arr, pred) {
        arr.sort(pred);
        return arr;
      }, "sortBy");
      var compareByIndexDesc = /* @__PURE__ */ __name(function compareByIndexDesc2(indexA, indexB) {
        var lastA = parseInt(indexA, 10);
        var lastB = parseInt(indexB, 10);
        if (!(isNaN(lastA) || isNaN(lastB))) {
          return lastB - lastA;
        } else {
          return 0;
        }
      }, "compareByIndexDesc");
      var opsByDescendingOrder = /* @__PURE__ */ __name(function opsByDescendingOrder2(removeOps) {
        return sortBy(removeOps, function(a, b) {
          var splitA = a.path.split("/");
          var splitB = b.path.split("/");
          if (splitA.length !== splitB.length) {
            return splitA.length - splitB.length;
          } else {
            return compareByIndexDesc(last(splitA), last(splitB));
          }
        });
      }, "opsByDescendingOrder");
      var partitionOps = /* @__PURE__ */ __name(function partitionOps2(arr, fns) {
        var initArr = Array(fns.length + 1).fill().map(function() {
          return [];
        });
        return arr.map(function(item) {
          var position = fns.map(function(fn) {
            return fn(item);
          }).indexOf(true);
          if (position < 0) {
            position = fns.length;
          }
          return { item, position };
        }).reduce(function(acc, item) {
          acc[item.position].push(item.item);
          return acc;
        }, initArr);
      }, "partitionOps");
      var isMoveOp = /* @__PURE__ */ __name(function isMoveOp2(_ref3) {
        var op = _ref3.op;
        return op === "move";
      }, "isMoveOp");
      var isRemoveOp = /* @__PURE__ */ __name(function isRemoveOp2(_ref4) {
        var op = _ref4.op;
        return op === "remove";
      }, "isRemoveOp");
      var reorderOps = /* @__PURE__ */ __name(function reorderOps2(diff2) {
        var _partitionOps = partitionOps(diff2, [isMoveOp, isRemoveOp]), _partitionOps2 = slicedToArray(_partitionOps, 3), moveOps = _partitionOps2[0], removedOps = _partitionOps2[1], restOps = _partitionOps2[2];
        var removeOpsReverse = opsByDescendingOrder(removedOps);
        return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));
      }, "reorderOps");
      var defaultInstance$2 = void 0;
      var format$2 = /* @__PURE__ */ __name(function format3(delta, left) {
        if (!defaultInstance$2) {
          defaultInstance$2 = new JSONFormatter();
        }
        return reorderOps(defaultInstance$2.format(delta, left));
      }, "format");
      var log = /* @__PURE__ */ __name(function log2(delta, left) {
        console.log(format$2(delta, left));
      }, "log");
      var jsonpatch = Object.freeze({
        default: JSONFormatter,
        partitionOps,
        format: format$2,
        log
      });
      function chalkColor(name) {
        return chalk && chalk[name] || function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return args;
        };
      }
      __name(chalkColor, "chalkColor");
      var colors = {
        added: chalkColor("green"),
        deleted: chalkColor("red"),
        movedestination: chalkColor("gray"),
        moved: chalkColor("yellow"),
        unchanged: chalkColor("gray"),
        error: chalkColor("white.bgRed"),
        textDiffLine: chalkColor("gray")
      };
      var ConsoleFormatter = function(_BaseFormatter) {
        inherits2(ConsoleFormatter2, _BaseFormatter);
        function ConsoleFormatter2() {
          classCallCheck(this, ConsoleFormatter2);
          var _this = possibleConstructorReturn(this, (ConsoleFormatter2.__proto__ || Object.getPrototypeOf(ConsoleFormatter2)).call(this));
          _this.includeMoveDestinations = false;
          return _this;
        }
        __name(ConsoleFormatter2, "ConsoleFormatter");
        createClass(ConsoleFormatter2, [{
          key: "prepareContext",
          value: /* @__PURE__ */ __name(function prepareContext(context) {
            get2(ConsoleFormatter2.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter2.prototype), "prepareContext", this).call(this, context);
            context.indent = function(levels) {
              this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
              this.indentPad = new Array(this.indentLevel + 1).join("  ");
              this.outLine();
            };
            context.outLine = function() {
              this.buffer.push("\n" + (this.indentPad || ""));
            };
            context.out = function() {
              for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              for (var i = 0, l = args.length; i < l; i++) {
                var lines = args[i].split("\n");
                var text = lines.join("\n" + (this.indentPad || ""));
                if (this.color && this.color[0]) {
                  text = this.color[0](text);
                }
                this.buffer.push(text);
              }
            };
            context.pushColor = function(color2) {
              this.color = this.color || [];
              this.color.unshift(color2);
            };
            context.popColor = function() {
              this.color = this.color || [];
              this.color.shift();
            };
          }, "prepareContext")
        }, {
          key: "typeFormattterErrorFormatter",
          value: /* @__PURE__ */ __name(function typeFormattterErrorFormatter(context, err2) {
            context.pushColor(colors.error);
            context.out("[ERROR]" + err2);
            context.popColor();
          }, "typeFormattterErrorFormatter")
        }, {
          key: "formatValue",
          value: /* @__PURE__ */ __name(function formatValue(context, value) {
            context.out(JSON.stringify(value, null, 2));
          }, "formatValue")
        }, {
          key: "formatTextDiffString",
          value: /* @__PURE__ */ __name(function formatTextDiffString(context, value) {
            var lines = this.parseTextDiff(value);
            context.indent();
            for (var i = 0, l = lines.length; i < l; i++) {
              var line = lines[i];
              context.pushColor(colors.textDiffLine);
              context.out(line.location.line + "," + line.location.chr + " ");
              context.popColor();
              var pieces = line.pieces;
              for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
                var piece = pieces[pieceIndex];
                context.pushColor(colors[piece.type]);
                context.out(piece.text);
                context.popColor();
              }
              if (i < l - 1) {
                context.outLine();
              }
            }
            context.indent(-1);
          }, "formatTextDiffString")
        }, {
          key: "rootBegin",
          value: /* @__PURE__ */ __name(function rootBegin(context, type, nodeType) {
            context.pushColor(colors[type]);
            if (type === "node") {
              context.out(nodeType === "array" ? "[" : "{");
              context.indent();
            }
          }, "rootBegin")
        }, {
          key: "rootEnd",
          value: /* @__PURE__ */ __name(function rootEnd(context, type, nodeType) {
            if (type === "node") {
              context.indent(-1);
              context.out(nodeType === "array" ? "]" : "}");
            }
            context.popColor();
          }, "rootEnd")
        }, {
          key: "nodeBegin",
          value: /* @__PURE__ */ __name(function nodeBegin(context, key, leftKey, type, nodeType) {
            context.pushColor(colors[type]);
            context.out(leftKey + ": ");
            if (type === "node") {
              context.out(nodeType === "array" ? "[" : "{");
              context.indent();
            }
          }, "nodeBegin")
        }, {
          key: "nodeEnd",
          value: /* @__PURE__ */ __name(function nodeEnd(context, key, leftKey, type, nodeType, isLast) {
            if (type === "node") {
              context.indent(-1);
              context.out(nodeType === "array" ? "]" : "}" + (isLast ? "" : ","));
            }
            if (!isLast) {
              context.outLine();
            }
            context.popColor();
          }, "nodeEnd")
          /* jshint camelcase: false */
          /* eslint-disable camelcase */
        }, {
          key: "format_unchanged",
          value: /* @__PURE__ */ __name(function format_unchanged(context, delta, left) {
            if (typeof left === "undefined") {
              return;
            }
            this.formatValue(context, left);
          }, "format_unchanged")
        }, {
          key: "format_movedestination",
          value: /* @__PURE__ */ __name(function format_movedestination(context, delta, left) {
            if (typeof left === "undefined") {
              return;
            }
            this.formatValue(context, left);
          }, "format_movedestination")
        }, {
          key: "format_node",
          value: /* @__PURE__ */ __name(function format_node(context, delta, left) {
            this.formatDeltaChildren(context, delta, left);
          }, "format_node")
        }, {
          key: "format_added",
          value: /* @__PURE__ */ __name(function format_added(context, delta) {
            this.formatValue(context, delta[0]);
          }, "format_added")
        }, {
          key: "format_modified",
          value: /* @__PURE__ */ __name(function format_modified(context, delta) {
            context.pushColor(colors.deleted);
            this.formatValue(context, delta[0]);
            context.popColor();
            context.out(" => ");
            context.pushColor(colors.added);
            this.formatValue(context, delta[1]);
            context.popColor();
          }, "format_modified")
        }, {
          key: "format_deleted",
          value: /* @__PURE__ */ __name(function format_deleted(context, delta) {
            this.formatValue(context, delta[0]);
          }, "format_deleted")
        }, {
          key: "format_moved",
          value: /* @__PURE__ */ __name(function format_moved(context, delta) {
            context.out("==> " + delta[1]);
          }, "format_moved")
        }, {
          key: "format_textdiff",
          value: /* @__PURE__ */ __name(function format_textdiff(context, delta) {
            this.formatTextDiffString(context, delta[0]);
          }, "format_textdiff")
        }]);
        return ConsoleFormatter2;
      }(BaseFormatter);
      var defaultInstance$3 = void 0;
      var format$3 = /* @__PURE__ */ __name(function format3(delta, left) {
        if (!defaultInstance$3) {
          defaultInstance$3 = new ConsoleFormatter();
        }
        return defaultInstance$3.format(delta, left);
      }, "format");
      function log$1(delta, left) {
        console.log(format$3(delta, left));
      }
      __name(log$1, "log$1");
      var console$1 = Object.freeze({
        default: ConsoleFormatter,
        format: format$3,
        log: log$1
      });
      var index = Object.freeze({
        base,
        html,
        annotated,
        jsonpatch,
        console: console$1
      });
      function dateReviver(key, value) {
        var parts = void 0;
        if (typeof value === "string") {
          parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value);
          if (parts) {
            return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
          }
        }
        return value;
      }
      __name(dateReviver, "dateReviver");
      function create(options) {
        return new DiffPatcher(options);
      }
      __name(create, "create");
      var defaultInstance$4 = void 0;
      function diff() {
        if (!defaultInstance$4) {
          defaultInstance$4 = new DiffPatcher();
        }
        return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
      }
      __name(diff, "diff");
      function patch() {
        if (!defaultInstance$4) {
          defaultInstance$4 = new DiffPatcher();
        }
        return defaultInstance$4.patch.apply(defaultInstance$4, arguments);
      }
      __name(patch, "patch");
      function unpatch() {
        if (!defaultInstance$4) {
          defaultInstance$4 = new DiffPatcher();
        }
        return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);
      }
      __name(unpatch, "unpatch");
      function reverse() {
        if (!defaultInstance$4) {
          defaultInstance$4 = new DiffPatcher();
        }
        return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);
      }
      __name(reverse, "reverse");
      function clone$1() {
        if (!defaultInstance$4) {
          defaultInstance$4 = new DiffPatcher();
        }
        return defaultInstance$4.clone.apply(defaultInstance$4, arguments);
      }
      __name(clone$1, "clone$1");
      exports2.DiffPatcher = DiffPatcher;
      exports2.formatters = index;
      exports2.console = console$1;
      exports2.create = create;
      exports2.dateReviver = dateReviver;
      exports2.diff = diff;
      exports2.patch = patch;
      exports2.unpatch = unpatch;
      exports2.reverse = reverse;
      exports2.clone = clone$1;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  })(jsondiffpatch_umd, jsondiffpatch_umd.exports);
  const proteinAlphabet = {
    A: {
      value: "A",
      name: "Alanine",
      threeLettersName: "Ala",
      hydrophobicity: 1.8,
      colorByFamily: "#00FFFF",
      color: "hsl(327.3, 100%, 69%)",
      mass: 71.0779
    },
    R: {
      value: "R",
      name: "Arginine",
      threeLettersName: "Arg",
      hydrophobicity: -4.5,
      colorByFamily: "#FFC0CB",
      color: "hsl(258.1, 100%, 69%)",
      mass: 156.18568
    },
    N: {
      value: "N",
      name: "Asparagine",
      threeLettersName: "Asn",
      hydrophobicity: -3.5,
      colorByFamily: "#D3D3D3",
      color: "hsl(268.9, 100%, 69%)",
      mass: 114.10264
    },
    D: {
      value: "D",
      name: "Aspartic acid",
      threeLettersName: "Asp",
      hydrophobicity: -3.5,
      colorByFamily: "#EE82EE",
      color: "hsl(268.9, 100%, 69%)",
      mass: 115.0874
    },
    C: {
      value: "C",
      name: "Cysteine",
      threeLettersName: "Cys",
      hydrophobicity: 2.5,
      colorByFamily: "#FFFF00",
      color: "hsl(335.1, 100%, 69%)",
      mass: 103.1429
    },
    E: {
      value: "E",
      name: "Glutamic acid",
      threeLettersName: "Glu",
      hydrophobicity: -3.5,
      colorByFamily: "#EE82EE",
      color: "hsl(268.9, 100%, 69%)",
      mass: 129.11398
    },
    Q: {
      value: "Q",
      name: "Glutamine",
      threeLettersName: "Gln",
      hydrophobicity: -3.5,
      colorByFamily: "#D3D3D3",
      color: "hsl(268.9, 100%, 69%)",
      mass: 128.12922
    },
    G: {
      value: "G",
      name: "Glycine",
      threeLettersName: "Gly",
      hydrophobicity: -0.4,
      colorByFamily: "#00FFFF",
      color: "hsl(303.1, 100%, 69%)",
      mass: 57.05132
    },
    H: {
      value: "H",
      name: "Histidine",
      threeLettersName: "His",
      hydrophobicity: -3.2,
      colorByFamily: "#FFC0CB",
      color: "hsl(272.2, 100%, 69%)",
      mass: 137.13928
    },
    I: {
      value: "I",
      name: "Isoleucine ",
      threeLettersName: "Ile",
      hydrophobicity: 4.5,
      colorByFamily: "#00FFFF",
      color: "hsl(356.9, 100%, 69%)",
      mass: 113.15764
    },
    L: {
      value: "L",
      name: "Leucine",
      threeLettersName: "Leu",
      hydrophobicity: 3.8,
      colorByFamily: "#00FFFF",
      color: "hsl(349.4, 100%, 69%)",
      mass: 113.15764
    },
    K: {
      value: "K",
      name: "Lysine",
      threeLettersName: "Lys",
      hydrophobicity: -3.9,
      colorByFamily: "#FFC0CB",
      color: "hsl(264.7, 100%, 69%)",
      mass: 128.17228
    },
    M: {
      value: "M",
      name: "Methionine",
      threeLettersName: "Met",
      hydrophobicity: 1.9,
      colorByFamily: "#FFFF00",
      color: "hsl(328.5, 100%, 69%)",
      mass: 131.19606
    },
    F: {
      value: "F",
      name: "Phenylalanine",
      threeLettersName: "Phe",
      hydrophobicity: 2.8,
      colorByFamily: "#FFA500",
      color: "hsl(338.4, 100%, 69%)",
      mass: 147.17386
    },
    P: {
      value: "P",
      name: "Proline",
      threeLettersName: "Pro",
      hydrophobicity: -1.6,
      colorByFamily: "#00FFFF",
      color: "hsl(289.9, 100%, 69%)",
      mass: 97.11518
    },
    S: {
      value: "S",
      name: "Serine",
      threeLettersName: "Ser",
      hydrophobicity: -0.8,
      colorByFamily: "#90EE90",
      color: "hsl(298.6, 100%, 69%)",
      mass: 87.0773
    },
    T: {
      value: "T",
      name: "Threonine",
      threeLettersName: "Thr",
      hydrophobicity: -0.7,
      colorByFamily: "#90EE90",
      color: "hsl(299.8, 100%, 69%)",
      mass: 101.10388
    },
    U: {
      value: "U",
      name: "Selenocysteine",
      threeLettersName: "Sec",
      colorByFamily: "#FF0000",
      color: "hsl(0, 100%, 69%)",
      mass: 150.3079
    },
    W: {
      value: "W",
      name: "Tryptophan",
      threeLettersName: "Trp",
      hydrophobicity: -0.9,
      colorByFamily: "#FFA500",
      color: "hsl(297.6, 100%, 69%)",
      mass: 186.2099
    },
    Y: {
      value: "Y",
      name: "Tyrosine",
      threeLettersName: "Tyr",
      hydrophobicity: -1.3,
      colorByFamily: "#FFA500",
      color: "hsl(293.2, 100%, 69%)",
      mass: 163.17326
    },
    V: {
      value: "V",
      name: "Valine",
      threeLettersName: "Val",
      hydrophobicity: 4.2,
      colorByFamily: "#00FFFF",
      color: "hsl(353.6, 100%, 69%)",
      mass: 99.13106
    },
    "*": {
      value: "*",
      name: "Stop",
      threeLettersName: "Stop",
      colorByFamily: "#FF0000",
      color: "hsl(0, 100%, 69%)",
      mass: 0
    },
    ".": {
      //tnr: this is actually a deletion/gap character (previously we had this as a stop character which is incorrect) https://www.dnabaser.com/articles/IUPAC%20ambiguity%20codes.html
      value: ".",
      name: "Gap",
      threeLettersName: "Gap",
      colorByFamily: "#FF0000",
      color: "hsl(0, 100%, 69%)",
      mass: 0
    },
    "-": {
      value: "-",
      name: "Gap",
      threeLettersName: "Gap",
      colorByFamily: "#FF0000",
      color: "hsl(0, 100%, 69%)",
      mass: 0
    },
    B: {
      value: "B",
      threeLettersName: "ND",
      colorByFamily: "#D3D3D3",
      color: "hsl(268.9, 100%, 69%)",
      isAmbiguous: true,
      name: "B",
      aliases: "ND",
      mass: 0
    },
    J: {
      value: "J",
      threeLettersName: "IL",
      colorByFamily: "#00FFFF",
      color: "hsl(352, 100%, 69%)",
      isAmbiguous: true,
      name: "J",
      aliases: "IL",
      mass: 0
    },
    X: {
      value: "X",
      threeLettersName: "ACDEFGHIKLMNPQRSTVWY",
      colorByFamily: "#FFFFFF",
      color: "hsl(60, 100%, 69%)",
      isAmbiguous: true,
      name: "X",
      aliases: "ACDEFGHIKLMNPQRSTVWY",
      mass: 0
    },
    Z: {
      value: "Z",
      threeLettersName: "QE",
      colorByFamily: "#D3D3D3",
      color: "hsl(268.9, 100%, 69%)",
      isAmbiguous: true,
      name: "Z",
      aliases: "QE",
      mass: 0
    }
  };
  const threeLetterSequenceStringToAminoAcidMap = {
    gct: proteinAlphabet.A,
    gcc: proteinAlphabet.A,
    gca: proteinAlphabet.A,
    gcg: proteinAlphabet.A,
    gcu: proteinAlphabet.A,
    cgt: proteinAlphabet.R,
    cgc: proteinAlphabet.R,
    cga: proteinAlphabet.R,
    cgg: proteinAlphabet.R,
    aga: proteinAlphabet.R,
    agg: proteinAlphabet.R,
    cgu: proteinAlphabet.R,
    aat: proteinAlphabet.N,
    aac: proteinAlphabet.N,
    aau: proteinAlphabet.N,
    gat: proteinAlphabet.D,
    gac: proteinAlphabet.D,
    gau: proteinAlphabet.D,
    tgt: proteinAlphabet.C,
    tgc: proteinAlphabet.C,
    ugu: proteinAlphabet.C,
    ugc: proteinAlphabet.C,
    gaa: proteinAlphabet.E,
    gag: proteinAlphabet.E,
    caa: proteinAlphabet.Q,
    cag: proteinAlphabet.Q,
    ggt: proteinAlphabet.G,
    ggc: proteinAlphabet.G,
    gga: proteinAlphabet.G,
    ggg: proteinAlphabet.G,
    ggu: proteinAlphabet.G,
    cat: proteinAlphabet.H,
    cac: proteinAlphabet.H,
    cau: proteinAlphabet.H,
    att: proteinAlphabet.I,
    atc: proteinAlphabet.I,
    ata: proteinAlphabet.I,
    auu: proteinAlphabet.I,
    auc: proteinAlphabet.I,
    aua: proteinAlphabet.I,
    ctt: proteinAlphabet.L,
    ctc: proteinAlphabet.L,
    cta: proteinAlphabet.L,
    ctg: proteinAlphabet.L,
    tta: proteinAlphabet.L,
    ttg: proteinAlphabet.L,
    cuu: proteinAlphabet.L,
    cuc: proteinAlphabet.L,
    cua: proteinAlphabet.L,
    cug: proteinAlphabet.L,
    uua: proteinAlphabet.L,
    uug: proteinAlphabet.L,
    aaa: proteinAlphabet.K,
    aag: proteinAlphabet.K,
    atg: proteinAlphabet.M,
    aug: proteinAlphabet.M,
    ttt: proteinAlphabet.F,
    ttc: proteinAlphabet.F,
    uuu: proteinAlphabet.F,
    uuc: proteinAlphabet.F,
    cct: proteinAlphabet.P,
    ccc: proteinAlphabet.P,
    cca: proteinAlphabet.P,
    ccg: proteinAlphabet.P,
    ccu: proteinAlphabet.P,
    tct: proteinAlphabet.S,
    tcc: proteinAlphabet.S,
    tca: proteinAlphabet.S,
    tcg: proteinAlphabet.S,
    agt: proteinAlphabet.S,
    agc: proteinAlphabet.S,
    ucu: proteinAlphabet.S,
    ucc: proteinAlphabet.S,
    uca: proteinAlphabet.S,
    ucg: proteinAlphabet.S,
    agu: proteinAlphabet.S,
    act: proteinAlphabet.T,
    acc: proteinAlphabet.T,
    aca: proteinAlphabet.T,
    acg: proteinAlphabet.T,
    acu: proteinAlphabet.T,
    tgg: proteinAlphabet.W,
    ugg: proteinAlphabet.W,
    tat: proteinAlphabet.Y,
    tac: proteinAlphabet.Y,
    uau: proteinAlphabet.Y,
    uac: proteinAlphabet.Y,
    gtt: proteinAlphabet.V,
    gtc: proteinAlphabet.V,
    gta: proteinAlphabet.V,
    gtg: proteinAlphabet.V,
    guu: proteinAlphabet.V,
    guc: proteinAlphabet.V,
    gua: proteinAlphabet.V,
    gug: proteinAlphabet.V,
    taa: proteinAlphabet["*"],
    tag: proteinAlphabet["*"],
    tga: proteinAlphabet["*"],
    "...": proteinAlphabet["."],
    "---": proteinAlphabet["-"]
  };
  const degenerateDnaToAminoAcidMap = lodashExports.invert(aminoAcidToDegenerateDnaMap);
  function getAminoAcidFromSequenceTriplet(sequenceString) {
    sequenceString = sequenceString.toLowerCase();
    if (sequenceString.length !== 3) {
      throw new Error("must pass a string of length 3");
    }
    const aa = threeLetterSequenceStringToAminoAcidMap[sequenceString];
    if (aa) {
      return aa;
    }
    const letter = degenerateDnaToAminoAcidMap[
      sequenceString.replace("x", "n")
      //replace x's with n's as those are equivalent dna chars
    ] || "x";
    return proteinAlphabet[letter.toUpperCase()];
  }
  __name(getAminoAcidFromSequenceTriplet, "getAminoAcidFromSequenceTriplet");
  function getAminoAcidDataForEachBaseOfDna(originalSequenceString, forward, optionalSubrangeRange, isProteinSequence) {
    const originalSequenceStringLength = isProteinSequence ? originalSequenceString.length * 3 : originalSequenceString.length;
    let sequenceString = originalSequenceString;
    let startOffset = 0;
    if (optionalSubrangeRange) {
      sequenceString = getSequenceWithinRange(
        optionalSubrangeRange,
        originalSequenceString
      );
      startOffset = optionalSubrangeRange.start;
    }
    const sequenceStringLength = isProteinSequence ? sequenceString.length * 3 : sequenceString.length;
    const aminoAcidDataForEachBaseOfDNA = [];
    let codonRange;
    let revCompGapLength = 0;
    let aminoAcidIndex = 0;
    if (!forward) {
      aminoAcidIndex = Math.floor((sequenceStringLength - 1) / 3);
      revCompGapLength = sequenceStringLength % 3;
      codonRange = translateRange(
        {
          start: 0,
          end: revCompGapLength - 1
        },
        startOffset,
        originalSequenceStringLength
      );
      if (revCompGapLength > 0) {
        for (let i = 0; i < revCompGapLength; i++) {
          aminoAcidDataForEachBaseOfDNA.push({
            aminoAcid: getAminoAcidFromSequenceTriplet("xxx"),
            //fake xxx triplet returns the ambiguous X amino acid
            positionInCodon: revCompGapLength - i - 1,
            aminoAcidIndex,
            sequenceIndex: codonRange.start + i,
            codonRange,
            fullCodon: false
          });
        }
        aminoAcidIndex--;
      }
    }
    for (let index = 2 + revCompGapLength; index < sequenceStringLength; index += 3) {
      let aminoAcid;
      if (isProteinSequence) {
        aminoAcid = proteinAlphabet[sequenceString[(index - 2) / 3].toUpperCase()];
      } else {
        let triplet = sequenceString.slice(index - 2, index + 1);
        if (!forward) {
          triplet = getReverseComplementSequenceString(triplet);
        }
        aminoAcid = getAminoAcidFromSequenceTriplet(triplet);
      }
      codonRange = translateRange(
        {
          start: index - 2,
          end: index
        },
        startOffset,
        originalSequenceStringLength
      );
      aminoAcidDataForEachBaseOfDNA.push({
        aminoAcid,
        //gap amino acid
        positionInCodon: forward ? 0 : 2,
        aminoAcidIndex,
        sequenceIndex: codonRange.start,
        codonRange,
        fullCodon: true
      });
      aminoAcidDataForEachBaseOfDNA.push({
        aminoAcid,
        //gap amino acid
        positionInCodon: 1,
        aminoAcidIndex,
        sequenceIndex: codonRange.start + 1,
        codonRange,
        fullCodon: true
      });
      aminoAcidDataForEachBaseOfDNA.push({
        aminoAcid,
        //gap amino acid
        positionInCodon: forward ? 2 : 0,
        aminoAcidIndex,
        sequenceIndex: codonRange.start + 2,
        codonRange,
        fullCodon: true
      });
      if (forward) {
        aminoAcidIndex++;
      } else {
        aminoAcidIndex--;
      }
    }
    const lengthOfEndBpsNotCoveredByAminoAcids = sequenceStringLength - aminoAcidDataForEachBaseOfDNA.length;
    codonRange = translateRange(
      {
        start: sequenceStringLength - lengthOfEndBpsNotCoveredByAminoAcids,
        end: sequenceStringLength - 1
      },
      startOffset,
      originalSequenceStringLength
    );
    for (let j = 0; j < lengthOfEndBpsNotCoveredByAminoAcids; j++) {
      aminoAcidDataForEachBaseOfDNA.push({
        aminoAcid: getAminoAcidFromSequenceTriplet("xxx"),
        //fake xxx triplet returns the gap amino acid
        positionInCodon: j,
        aminoAcidIndex,
        sequenceIndex: codonRange.start + j,
        fullCodon: false,
        codonRange
      });
    }
    if (sequenceStringLength !== aminoAcidDataForEachBaseOfDNA.length) {
      throw new Error("something went wrong!");
    }
    return aminoAcidDataForEachBaseOfDNA;
  }
  __name(getAminoAcidDataForEachBaseOfDna, "getAminoAcidDataForEachBaseOfDna");
  const annotationTypes = [
    "features",
    "warnings",
    "assemblyPieces",
    "lineageAnnotations",
    "parts",
    "cutsites",
    "orfs",
    "translations",
    "primers",
    "guides"
  ];
  function filterSequenceString(sequenceString = "", {
    additionalValidChars = "",
    isOligo,
    name,
    isProtein,
    isRna,
    isMixedRnaAndDna
  } = {}) {
    const acceptedChars = getAcceptedChars({
      isOligo,
      isProtein,
      isRna,
      isMixedRnaAndDna
    });
    const replaceChars = getReplaceChars({
      isOligo,
      isProtein,
      isRna,
      isMixedRnaAndDna
    });
    let sanitizedVal = "";
    const invalidChars = [];
    const chars = `${acceptedChars}${additionalValidChars.split("").join("\\")}`;
    const warnings = [];
    const replaceCount = {};
    sequenceString.split("").forEach((letter) => {
      const lowerLetter = letter.toLowerCase();
      if (replaceChars && replaceChars[lowerLetter]) {
        if (!replaceCount[lowerLetter]) {
          replaceCount[lowerLetter] = 0;
        }
        replaceCount[lowerLetter]++;
        const isUpper = lowerLetter !== letter;
        sanitizedVal += isUpper ? replaceChars[lowerLetter].toUpperCase() : replaceChars[lowerLetter];
      } else if (chars.includes(lowerLetter)) {
        sanitizedVal += letter;
      } else {
        invalidChars.push(letter);
      }
    });
    Object.keys(replaceCount).forEach((letter) => {
      warnings.push(
        `Replaced "${letter}" with "${replaceChars[letter]}"${replaceCount[letter] > 1 ? ` ${replaceCount[letter]} times` : ""}`
      );
    });
    if (sequenceString.length !== sanitizedVal.length) {
      warnings.push(
        `${name ? `Sequence ${name}: ` : ""}Invalid character(s) detected and removed: ${invalidChars.slice(0, 100).join(", ")} `
      );
    }
    if (typeof window !== "undefined" && window.toastr && warnings.length) {
      warnings.forEach((warning) => {
        window.toastr.warning(warning);
      });
    }
    return [sanitizedVal, warnings];
  }
  __name(filterSequenceString, "filterSequenceString");
  function getAcceptedChars({
    isOligo,
    isProtein,
    isRna,
    isMixedRnaAndDna
  } = {}) {
    return isProtein ? `${extended_protein_letters.toLowerCase()}}` : isOligo ? ambiguous_rna_letters.toLowerCase() + "t" : isRna ? ambiguous_rna_letters.toLowerCase() + "t" : isMixedRnaAndDna ? ambiguous_rna_letters.toLowerCase() + ambiguous_dna_letters.toLowerCase() : (
      //just plain old dna
      ambiguous_rna_letters.toLowerCase() + ambiguous_dna_letters.toLowerCase()
    );
  }
  __name(getAcceptedChars, "getAcceptedChars");
  function getReplaceChars({
    isOligo,
    isProtein,
    isRna,
    isMixedRnaAndDna
  } = {}) {
    return isProtein ? {} : (
      // {".": "*"}
      isOligo ? {} : isRna ? { t: "u" } : isMixedRnaAndDna ? {} : (
        //just plain old dna
        {}
      )
    );
  }
  __name(getReplaceChars, "getReplaceChars");
  function tidyUpAnnotation(_annotation, {
    sequenceData = {},
    convertAnnotationsFromAAIndices,
    annotationType,
    provideNewIdsForAnnotations,
    doNotProvideIdsForAnnotations,
    messages = [],
    mutative,
    allowNonStandardGenbankTypes,
    featureTypes
  }) {
    const { size, circular, isProtein } = sequenceData;
    if (!_annotation || typeof _annotation !== "object") {
      messages.push("Invalid annotation detected and removed");
      return false;
    }
    let annotation = _annotation;
    if (!mutative) {
      annotation = lodashExports.cloneDeep(_annotation);
    }
    annotation.annotationTypePlural = annotationType;
    if (!annotation.name || typeof annotation.name !== "string") {
      messages.push(
        'Unable to detect valid name for annotation, setting name to "Untitled annotation"'
      );
      annotation.name = "Untitled annotation";
    }
    if (provideNewIdsForAnnotations) {
      annotation.id = shortid$1();
    }
    if (!annotation.id && annotation.id !== 0 && !doNotProvideIdsForAnnotations) {
      annotation.id = shortid$1();
      messages.push(
        "Unable to detect valid ID for annotation, setting ID to " + annotation.id
      );
    }
    coerceLocation({
      isProtein,
      location: annotation,
      convertAnnotationsFromAAIndices,
      size,
      messages,
      circular,
      name: annotation.name
    });
    annotation.locations && annotation.locations.forEach((location) => {
      coerceLocation({
        isProtein,
        location,
        convertAnnotationsFromAAIndices,
        size,
        messages,
        circular,
        name: annotation.name
      });
    });
    if (isProtein || annotation.forward === true || annotation.forward === "true" || annotation.strand === 1 || annotation.strand === "1" || annotation.strand === "+") {
      annotation.forward = true;
      annotation.strand = 1;
    } else {
      annotation.forward = false;
      annotation.strand = -1;
    }
    if (!annotation.type || typeof annotation.type !== "string" || !lodashExports.some(featureTypes || getFeatureTypes(), (featureType) => {
      if (featureType.toLowerCase() === annotation.type.toLowerCase()) {
        annotation.type = featureType;
        return true;
      }
      if (allowNonStandardGenbankTypes || typeof window !== "undefined" && lodashExports.get(window, "tg_allowNonStandardGenbankTypes") || typeof global !== "undefined" && lodashExports.get(global, "tg_allowNonStandardGenbankTypes"))
        return true;
      return false;
    })) {
      messages.push(
        "Invalid annotation type detected:  " + annotation.type + " for " + annotation.name + ". set type to misc_feature"
      );
      annotation.type = "misc_feature";
    }
    if (annotation.notes && typeof annotation.notes === "string") {
      try {
        annotation.notes = JSON.parse(annotation.notes);
      } catch (error) {
        console.info(
          `warning 33y00a0912 - couldn't parse notes for ${annotation.name || ""} ${annotation.notes}:`,
          error
        );
      }
    }
    if (!annotation.color) {
      annotation.color = getFeatureToColorMap()[annotation.type];
    }
    return annotation;
  }
  __name(tidyUpAnnotation, "tidyUpAnnotation");
  function coerceLocation({
    location,
    convertAnnotationsFromAAIndices,
    size,
    isProtein,
    messages,
    circular,
    name
  }) {
    location.start = parseInt(location.start, 10);
    location.end = parseInt(location.end, 10);
    if (convertAnnotationsFromAAIndices) {
      location.start = location.start * 3;
      location.end = location.end * 3 + 2;
    }
    if (location.start < 0 || !(location.start <= size - 1) || location.start > size - 1) {
      messages.push(
        "Invalid annotation start: " + location.start + " detected for " + location.name + " and set to size: " + size
      );
      location.start = Math.max(0, size - (isProtein ? 3 : 1));
    }
    if (location.end < 0 || !(location.end <= size - 1) || location.end > size - 1) {
      messages.push(
        "Invalid annotation end:  " + location.end + " detected for " + location.name + " and set to seq size: " + size
      );
      location.end = Math.max(0, size - 1);
    }
    if (location.start > location.end && circular === false) {
      messages.push(
        "Invalid circular annotation detected for " + name + ". end set to 1"
      );
      location.end = size;
    }
  }
  __name(coerceLocation, "coerceLocation");
  function getDegenerateDnaStringFromAAString(aaString) {
    return aaString.split("").map((char) => aminoAcidToDegenerateDnaMap[char.toLowerCase()] || "nnn").join("");
  }
  __name(getDegenerateDnaStringFromAAString, "getDegenerateDnaStringFromAAString");
  function tidyUpSequenceData(pSeqData, options = {}) {
    const {
      annotationsAsObjects,
      logMessages,
      doNotRemoveInvalidChars,
      additionalValidChars,
      noTranslationData,
      doNotProvideIdsForAnnotations,
      noCdsTranslations,
      convertAnnotationsFromAAIndices,
      topLevelSeqData
    } = options;
    let seqData = lodashExports.cloneDeep(pSeqData);
    const response = {
      messages: []
    };
    if (!seqData) {
      seqData = {};
    }
    if (!seqData.sequence) {
      seqData.sequence = "";
    }
    if (!seqData.proteinSequence) {
      seqData.proteinSequence = "";
    }
    let needsBackTranslation = false;
    if (seqData.isProtein) {
      seqData.circular = false;
      if (!seqData.proteinSequence && seqData.proteinSequence !== "") {
        seqData.proteinSequence = seqData.sequence;
      }
      if (!seqData.sequence || seqData.sequence.length !== seqData.proteinSequence.length * 3) {
        needsBackTranslation = true;
      }
    }
    if (seqData.isRna) {
      seqData.sequence = seqData.sequence.replace(/t/gi, "u");
    }
    if (!doNotRemoveInvalidChars) {
      if (seqData.isProtein) {
        const [newSeq] = filterSequenceString(seqData.proteinSequence, __spreadValues({}, topLevelSeqData || seqData));
        seqData.proteinSequence = newSeq;
      } else {
        const [newSeq] = filterSequenceString(seqData.sequence, __spreadValues({
          additionalValidChars
        }, topLevelSeqData || seqData));
        seqData.sequence = newSeq;
      }
    }
    if (seqData.isProtein) {
      if (needsBackTranslation) {
        seqData.sequence = getDegenerateDnaStringFromAAString(
          seqData.proteinSequence
        );
      }
      seqData.aminoAcidDataForEachBaseOfDNA = getAminoAcidDataForEachBaseOfDna(
        seqData.proteinSequence,
        true,
        null,
        true
      );
    }
    seqData.size = seqData.noSequence ? seqData.size : seqData.sequence.length;
    seqData.proteinSize = seqData.noSequence ? seqData.proteinSize : seqData.proteinSequence.length;
    if (seqData.circular === "false" || /* eslint-disable eqeqeq*/
    seqData.circular == -1 || /* eslint-enable eqeqeq*/
    seqData.circular === false || !seqData.circular && seqData.sequenceTypeCode !== "CIRCULAR_DNA") {
      seqData.circular = false;
    } else {
      seqData.circular = true;
    }
    const featureTypes = getFeatureTypes();
    annotationTypes.forEach((annotationType) => {
      if (!Array.isArray(seqData[annotationType])) {
        if (typeof seqData[annotationType] === "object") {
          seqData[annotationType] = Object.keys(seqData[annotationType]).map(
            (key) => {
              return seqData[annotationType][key];
            }
          );
        } else {
          seqData[annotationType] = [];
        }
      }
      seqData[annotationType] = seqData[annotationType].filter((annotation) => {
        return tidyUpAnnotation(annotation, __spreadProps(__spreadValues({}, options), {
          featureTypes,
          sequenceData: seqData,
          convertAnnotationsFromAAIndices,
          mutative: true,
          annotationType
        }));
      });
    });
    if (!noTranslationData) {
      seqData.translations = lodashExports.flatMap(seqData.translations, (translation) => {
        if (noCdsTranslations && translation.translationType === "CDS Feature") {
          return [];
        }
        if (!translation.aminoAcids && !seqData.noSequence) {
          translation.aminoAcids = getAminoAcidDataForEachBaseOfDna(
            seqData.sequence,
            translation.forward,
            translation
          );
        }
        return translation;
      });
    }
    if (annotationsAsObjects) {
      annotationTypes.forEach((name) => {
        seqData[name] = seqData[name].reduce((acc, item) => {
          let itemId;
          if (item.id || item.id === 0) {
            itemId = item.id;
          } else {
            itemId = shortid$1();
            if (!doNotProvideIdsForAnnotations) {
              item.id = itemId;
            }
          }
          acc[itemId] = item;
          return acc;
        }, {});
      });
    }
    if (logMessages && response.messages.length > 0) {
      console.info("tidyUpSequenceData messages:", response.messages);
    }
    return seqData;
  }
  __name(tidyUpSequenceData, "tidyUpSequenceData");
  const aminoAcidToDegenerateRnaMap = {
    "-": "---",
    ".": "...",
    "*": "trr",
    a: "gcn",
    b: "ray",
    c: "ugy",
    d: "gay",
    e: "gar",
    f: "uuy",
    g: "ggn",
    h: "cay",
    i: "auh",
    j: "hun",
    k: "aar",
    l: "yun",
    m: "aug",
    n: "aay",
    o: "uag",
    p: "ccn",
    q: "car",
    r: "mgn",
    s: "wsn",
    t: "acn",
    u: "uga",
    v: "gun",
    w: "ugg",
    x: "nnn",
    y: "uay",
    z: "sar"
  };
  const calcTmMethods = {
    TABLE_BRESLAUER: "breslauer",
    TABLE_SUGIMOTO: "sugimoto",
    TABLE_UNIFIED: "unified",
    A: -10.8,
    // Helix initiation for deltaS
    R: 1.987,
    // Gas constant (cal/(K*mol)).
    C: 5e-7,
    // Oligo concentration. 0.5uM is typical for PCR.
    Na: 0.05,
    // Monovalent salt concentration. 50mM is typical for PCR.
    /**
     * Calculates temperature for DNA sequence using a given algorithm.
     * @param  {String} sequence The DNA sequence to use.
     * @param  {String} type Either Teselagen.bio.tools.TemperatureCalculator.TABLE_BRESLAUER, TABLE_SUGIMOTO, or TABLE_UNIFIED
     * @param  {Double} A Helix initation for deltaS. Defaults to -10.8.
     * @param  {Double} R The gas constant, in cal/(K*mol). Defaults to 0.5e-6M.
     * @param  {Double} Na THe monovalent salt concentration. Defaults to 50e-3M.
     * @return {Double} Temperature for the given sequence, in Celsius.
     */
    calculateTemperature: function(sequence, type, A, R, C, Na) {
      if (typeof type === "undefined") {
        type = this.TABLE_BRESLAUER;
      } else if (type != this.TABLE_BRESLAUER && type != this.TABLE_UNIFIED && type != this.TABLE_SUGIMOTO) {
        throw new Error("Invalid table type!");
      }
      if (!A) {
        A = this.A;
      }
      if (!R) {
        R = this.R;
      }
      if (!C) {
        C = this.C;
      }
      if (!Na) {
        Na = this.Na;
      }
      const sequenceLength = sequence.length;
      if (sequenceLength == 0) {
        return 0;
      }
      const deltaHTable = this.getDeltaHTable(type);
      const deltaSTable = this.getDeltaSTable(type);
      const neighbors = [];
      neighbors.push(this.calculateReps(sequence, "aa"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "at"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ac"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ag"));
      neighbors.push(this.calculateReps(sequence, "tt"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ta"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "tc"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "tg"));
      neighbors.push(this.calculateReps(sequence, "cc"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ca"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ct"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "cg"));
      neighbors.push(this.calculateReps(sequence, "gg"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "ga"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "gt"));
      neighbors.push(this.calculateNumberOfOccurrences(sequence, "gc"));
      let sumDeltaH = 0;
      let sumDeltaS = 0;
      for (let i = 0; i < 16; i++) {
        sumDeltaH = sumDeltaH + neighbors[i] * deltaHTable[i];
        sumDeltaS = sumDeltaS + neighbors[i] * deltaSTable[i];
      }
      const temperature = -1e3 * sumDeltaH / (A + -sumDeltaS + R * Math.log(C / 4)) - 273.15 + 16.6 * Math.LOG10E * Math.log(Na);
      if (temperature < 0) {
        return 0;
      }
      return temperature.toFixed(2);
    },
    /**
     * @private
     * Function to return deltaH table for given algorithm.
     * @param {String} type Algorithm to get table for.
     * @return {Number[]} deltaH table for given algorithm.
     */
    getDeltaHTable: function(type) {
      if (type == this.TABLE_BRESLAUER) {
        return [
          9.1,
          8.6,
          6.5,
          7.8,
          9.1,
          6,
          5.6,
          5.8,
          11,
          5.8,
          7.8,
          11.9,
          11,
          5.6,
          6.5,
          11.1
        ];
      } else if (type == this.TABLE_SUGIMOTO) {
        return [
          8,
          5.6,
          6.5,
          7.8,
          8,
          5.6,
          5.6,
          5.8,
          10.9,
          8.2,
          6.6,
          11.8,
          10.9,
          6.6,
          9.4,
          11.9
        ];
      } else if (type == this.TABLE_UNIFIED) {
        return [
          7.9,
          7.2,
          8.4,
          7.8,
          7.9,
          7.2,
          8.2,
          8.5,
          8,
          8.5,
          7.8,
          10.6,
          8,
          8.2,
          8.4,
          9.8
        ];
      } else {
        return null;
      }
    },
    /**
     * @private
     * Function to return deltaS table for given algorithm.
     * @param {String} type Algorithm to get table for.
     * @return {Number[]} deltaS table for given algorithm.
     */
    getDeltaSTable: function(type) {
      if (type == this.TABLE_BRESLAUER) {
        return [
          24,
          23.9,
          17.3,
          20.8,
          24,
          16.9,
          13.5,
          12.9,
          26.6,
          12.9,
          20.8,
          27.8,
          26.6,
          13.5,
          17.3,
          26.7
        ];
      } else if (type == this.TABLE_SUGIMOTO) {
        return [
          21.9,
          15.2,
          17.3,
          20.8,
          21.9,
          15.2,
          13.5,
          12.9,
          28.4,
          25.5,
          23.5,
          29,
          28.4,
          16.4,
          25.5,
          29
        ];
      } else if (type == this.TABLE_UNIFIED) {
        return [
          22.2,
          20.4,
          22.4,
          21,
          22.2,
          21.3,
          22.2,
          22.7,
          19.9,
          22.7,
          21,
          27.2,
          19.9,
          22.2,
          22.4,
          24.4
        ];
      } else {
        return null;
      }
    },
    /**
     * @private
     * Finds number of occurrences of target in sequence.
     * Will find repeating sequences, meaning that
     * calculateReps("aaa", "aa") returns 2 rather than 1.
     * @param  {String} sequence The string to search through.
     * @param  {String} target   The string to search for.
     * @return {Int} Number of occurrences of target in sequence, with repeats.
     */
    calculateReps: function(sequence, target) {
      const sequenceLength = sequence.length;
      if (sequenceLength == 0) {
        return 0;
      }
      let numFound = 0;
      let seqOffset = 0;
      while (true) {
        const foundSeq = sequence.indexOf(target, seqOffset);
        if (foundSeq == -1) {
          break;
        }
        seqOffset = foundSeq + 1;
        numFound++;
        if (seqOffset > sequenceLength) {
          break;
        }
      }
      return numFound;
    },
    /**
     * @private
     * Counts number of occurrences of target in sequence, without repeating.
     * @param  {String} sequence The string to search through.
     * @param  {String} target   The string to search for.
     * @return {Int} Number of occurrences of target in sequence.
     */
    calculateNumberOfOccurrences: function(sequence, target) {
      const sequenceLength = sequence.length;
      if (sequenceLength == 0) {
        return 0;
      }
      const numberFound = sequence.split(target).length - 1;
      return numberFound;
    }
  };
  calcTmMethods.calculateTemperature.bind(calcTmMethods);
  const aliasedEnzymes = [
    {
      aliases: [
        "ErpI",
        "Bme18I",
        "BsrAI",
        "SmuEI",
        "FdiI",
        "BmpI",
        "VpaK11BI",
        "CauI",
        "Kzo49I",
        "SinI",
        "EagMI",
        "HgiHIII",
        "AvaII",
        "BamNxI",
        "AflI",
        "FssI",
        "Asp745I",
        "BthAI",
        "HgiCII",
        "FspMSI",
        "DsaIV",
        "Eco47I",
        "Csp68KI",
        "BcuAI",
        "HgiEI",
        "HgiJI",
        "HgiBI",
        "Bme216I"
      ],
      site: "ggwcc",
      forwardRegex: "g{2}[atw]c{2}",
      reverseRegex: "g{2}[atw]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "Eco196I",
        "Uba1126I",
        "Pae17I",
        "Ssp1725I",
        "BacI",
        "Eco104I",
        "Bsp12I",
        "Eco100I",
        "EccI",
        "Kpn19I",
        "DrdFI",
        "Cfr37I",
        "DrdEI",
        "DrdBI",
        "DrdAI",
        "DrdCI",
        "Cfr45II",
        "FscI",
        "Cte1I",
        "Pfl1108II",
        "NlaSI",
        "Ecl1I",
        "Bac465I",
        "Uba66I",
        "NgoDIII",
        "NgoJIII",
        "Pae7I",
        "Dsp1I",
        "SseII",
        "BscTI",
        "MraI",
        "Pae36I",
        "SsmII",
        "NlaDIII",
        "Eco55I",
        "Uba77I",
        "Uba1364I",
        "Uba1369I",
        "Pae44I",
        "Pae43I",
        "Pae42I",
        "Sfr382I",
        "Ese3I",
        "Ese6I",
        "SfrI",
        "Cfr43I",
        "Cfr41I",
        "Uba1234I",
        "StaI",
        "Uba90I",
        "NgoKIII",
        "Eco151I",
        "Eco208I",
        "Uba1306I",
        "Ecl28I",
        "Eco158I",
        "TtoI",
        "Uba1244I",
        "Asp32HI",
        "SboI",
        "Eco134I",
        "Eco135I",
        "SenpCI",
        "ShyI",
        "TglI",
        "UbaHKAI",
        "NgoGIII",
        "NgoMIII",
        "Eco96I",
        "SakI",
        "Eco92I",
        "Ssm5II",
        "SaaI",
        "SabI",
        "Uba1111I",
        "AosIII",
        "Uba1113I",
        "Eco182I",
        "Eco99I",
        "Uba1187I",
        "Uba1095I",
        "Uba1093I",
        "Ecl37I",
        "Uba1229I"
      ],
      site: "ccgcgg",
      forwardRegex: "c{2}gcg{2}",
      reverseRegex: "c{2}gcg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SplI",
        "PpuAI",
        "BvuBI",
        "Pfl23II",
        "PspLI",
        "SunI",
        "BsiWI",
        "BpuB5I",
        "MaeK81I"
      ],
      site: "cgtacg",
      forwardRegex: "cgtacg",
      reverseRegex: "cgtacg",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Uba1366II",
        "Bsh108AI",
        "Uba1161I",
        "Uba1379I",
        "BfrAI",
        "BscVI",
        "Uba1145I",
        "Uba1257I",
        "Uba1144I",
        "Bsp145I",
        "Apu16I",
        "Uba1138I",
        "Uba1286I",
        "Bth1202I",
        "Uba1137I",
        "Uba1133I",
        "Bli576I",
        "Bsp84I",
        "Uba1427I",
        "BstLVI",
        "Uba1200I",
        "Bsp127I",
        "Bsp126I",
        "Bsp125I",
        "Uba1275I",
        "Bli585I",
        "BazI",
        "Uba1412I",
        "Uba1342I",
        "Uba1416I",
        "Uba1195I",
        "Uba1197I",
        "Uba1196I",
        "Bth9415I",
        "Uba1295I",
        "Uba1096I",
        "Bco79I",
        "Bsp2I",
        "Uba43I",
        "Bsp4I",
        "Uba34I",
        "Asp86I",
        "Asp14I",
        "Uba1430I",
        "Uba1100I",
        "Csp4I",
        "Uba1198I",
        "Uba1199I",
        "Uba30I",
        "Asp123I",
        "Uba1246I",
        "Uba22I",
        "Uba24I",
        "Asp707I",
        "BsrCI",
        "Uba1168I",
        "Uba1315I",
        "Uba1394I",
        "Asp37I",
        "Uba1233I",
        "Uba1238I",
        "Asp130I",
        "BtuI",
        "Uba1451I",
        "Uba1453I",
        "Uba1380I"
      ],
      site: "atcgat",
      forwardRegex: "atcgat",
      reverseRegex: "atcgat",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Bbv12I",
        "MspV281I",
        "BsiHKAI",
        "Alw21I",
        "Bsm6I",
        "Bsh45I",
        "AspHI",
        "HgiAI"
      ],
      site: "gwgcwc",
      forwardRegex: "g[atw]gc[atw]c",
      reverseRegex: "g[atw]gc[atw]c",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SmiMII",
        "NflAI",
        "Rma495II",
        "Bsc217I",
        "Tsp273I",
        "Eco17I",
        "NanI",
        "Eco178I",
        "BshLI",
        "Bsp16I",
        "Pac1110II",
        "BsoAI",
        "PxyARI",
        "UbaN4I",
        "Rma497II",
        "Rma496II",
        "Uba1400I",
        "BstRI",
        "Pfl16I"
      ],
      site: "gatatc",
      forwardRegex: "gatatc",
      reverseRegex: "gatatc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Uba1223I",
        "MthTI",
        "Bpa36I",
        "Bce71I",
        "NgoCII",
        "SagI",
        "Bal3006I",
        "Uba9I",
        "NlaI",
        "Uba1449I",
        "HhgI",
        "Bsu1114I",
        "Uba1336I",
        "Bfi458I",
        "Uba1228I",
        "Bsp23I",
        "Uba1097I",
        "Uba1214I",
        "Tsp266I",
        "TteAI",
        "Uba1210I",
        "Afl83II",
        "BmeU1594I",
        "Uba1322I",
        "Bme46I",
        "Bsp2500I",
        "Csp2I",
        "UbaN8I",
        "MniI",
        "BshAI",
        "BshDI",
        "BshEI",
        "Van91III",
        "BshBI",
        "BshCI",
        "Bsp2013I",
        "HpyF10V",
        "NgoAII",
        "SulI",
        "BsiDI",
        "BsiAI",
        "Uba1169I",
        "NgoNII",
        "Uba1319I",
        "BliI",
        "BsiHI",
        "Uba1392I",
        "Uba1395I",
        "Uba1231I",
        "BsaRI",
        "HpyF72I",
        "Uba1235I",
        "Uba1450I",
        "Bsp1261I",
        "Tsp132I",
        "Uba1230I",
        "FinSI",
        "Tsp281I",
        "Bsp2362I",
        "BssCI",
        "Uba1176I",
        "Uba1175I",
        "Uba1174I",
        "Uba1179I",
        "Uba1388I",
        "Uba1178I",
        "BspLRI",
        "Psp29I",
        "BspBDG2I",
        "Bsu1076I",
        "PaiI",
        "TtnI",
        "Bse126I",
        "Bsp137I",
        "BstJI",
        "HpyF69II",
        "Uba1150I",
        "HpyF63I",
        "Uba1152I",
        "Bal475I",
        "HpyF26II",
        "Uba1153I",
        "Uba1155I",
        "BhaII",
        "Uth557I",
        "Tsp273II",
        "Uba1408I",
        "Uth555I",
        "Bco33I",
        "PpuI",
        "BscQI",
        "Uba1377I",
        "Bme74I",
        "HpyF33II",
        "VniI",
        "BstCI",
        "BluII",
        "AspTIII",
        "Tsp560I",
        "Uba1146I",
        "HpyF57I",
        "Uba1147I",
        "HpyF53I",
        "BseI",
        "Uba1140I",
        "Bsp881I",
        "M.H2I",
        "HpyF73III",
        "Vha1168I",
        "M.Csp68KV",
        "TspZNI",
        "HpyF49IV",
        "Uth549I",
        "BspBSE18I",
        "HpyF42I",
        "UbaN2I",
        "Uba1288I",
        "Uba1209I",
        "Uba1208I",
        "EsaWC1I",
        "HpyF46V",
        "Uba1207I",
        "Asp742I",
        "ClmI",
        "Bse9I",
        "Bsp44II",
        "Uba1429I",
        "BspCHE15I",
        "Uba61I",
        "OchI",
        "NgoSII",
        "Uba1422I",
        "Hpy178VII",
        "Uba1292I",
        "SplIII",
        "Uba1293I",
        "Bsp1593I",
        "MnnII",
        "Bsp226I",
        "BspBake1I",
        "AcaIV",
        "M.NgoGII",
        "Uba1418I",
        "VhaI",
        "Uba54I",
        "BspGHA1I",
        "BspH106II",
        "Psb9879I",
        "Ple214I",
        "NgoTII",
        "AvrBI",
        "HpyF29I"
      ],
      site: "ggcc",
      forwardRegex: "g{2}c{2}",
      reverseRegex: "g{2}c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "ErhB9I",
        "Afa16RI",
        "XorII",
        "NblI",
        "Ple19I",
        "RshI",
        "BpvUI",
        "Afa22MI",
        "PvuI",
        "Psu161I",
        "EagBI",
        "MvrI",
        "BspCI"
      ],
      site: "cgatcg",
      forwardRegex: "cgatcg",
      reverseRegex: "cgatcg",
      topSnipOffset: 4,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "BsmRI",
        "Ssp4800I",
        "Bsp1407I",
        "BstAUI",
        "BsrGI",
        "SspBI",
        "AauI"
      ],
      site: "tgtaca",
      forwardRegex: "tgtaca",
      reverseRegex: "tgtaca",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Psp32I",
        "Acs1422I",
        "Acs1421I",
        "BstZ16I",
        "Acs1371I",
        "Acs1372I",
        "Acs1373I",
        "CglAII",
        "RhpI",
        "RheI",
        "Psp89I",
        "XamI",
        "RroI",
        "RrhI",
        "Uba89I",
        "BtgAI",
        "Psp33I",
        "KoyI"
      ],
      site: "gtcgac",
      forwardRegex: "gtcgac",
      reverseRegex: "gtcgac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Ecl136I",
        "Scg2I",
        "Bme2095I",
        "Ecl1zII",
        "Bsp56I",
        "Esp2I",
        "Eco70I",
        "Eco71I",
        "Eco206I",
        "Asp2HI",
        "Eco207I",
        "Uba1181I",
        "M.SPRI",
        "Eco67I",
        "Uba1185I",
        "Uba13I",
        "Acc38I",
        "Uba11I",
        "CfrS37I",
        "BsaNI",
        "Uba20I",
        "Bsp44I",
        "Ese6II",
        "SflHK7462I",
        "Cdi27I",
        "Sau16I",
        "Uba1171I",
        "BsiUI",
        "Uba1243I",
        "BsiVI",
        "UbaN16I",
        "Bsp103I",
        "Uba1218I",
        "Eco128I",
        "BspSI",
        "SflHK7234I",
        "SflHK2374I",
        "Eco170I",
        "Cfr11I",
        "Esp24I",
        "M.EcoKDcm",
        "AcuII",
        "EagKI",
        "Cfr5I",
        "Bsp317I",
        "Ecl37kII",
        "EcaII",
        "Uba1118I",
        "Bst7QII",
        "Uba1189I",
        "HhdI",
        "Uba1114I",
        "Uba1193I",
        "SflHK8401I",
        "BstGII",
        "Sfl2bI",
        "Uba1410I",
        "Sfl2aI",
        "Kpn16I",
        "Kpn14I",
        "Cfr35I",
        "Eco38I",
        "Kpn13I",
        "MpsI",
        "Ecl57kI",
        "Cfr31I",
        "Cfr30I",
        "EclII",
        "Uba1120I",
        "Uba1121I",
        "KspHK12I",
        "KspHK14I",
        "Eco256I",
        "Kpn10I",
        "TspAI",
        "Eco254I",
        "BsoGI",
        "Eco193I",
        "Cfr28I",
        "Cfr29I",
        "Uba1125I",
        "MphI",
        "Cfr27I",
        "Cfr25I",
        "Cfr24I",
        "Ecl66I",
        "EclS39I",
        "Uba1428I",
        "Cfr22I",
        "Lla497I",
        "Cfr20I",
        "EspHK7I",
        "Sgr20I",
        "Mlu2300I",
        "BspH43I",
        "EspHK30I",
        "Cfr58I",
        "Kox165I",
        "SflHK2731I",
        "UbaN11II",
        "Eco60I",
        "Ecl54kI",
        "Eco61I",
        "Sth455I",
        "SflHK10790I",
        "SflHK6873I",
        "BinSI",
        "Psp39I",
        "AtuBI",
        "Uba82I",
        "Uba81I",
        "Ecl137II",
        "Eco41I",
        "Eco40I",
        "AtuII",
        "SflHK1794I",
        "Atu1I",
        "Pca17AI",
        "M.Bbu297I",
        "EspHK22I"
      ],
      site: "ccwgg",
      forwardRegex: "c{2}[atw]g{2}",
      reverseRegex: "c{2}[atw]g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SspCI",
        "NaeI",
        "SauLPI",
        "SauSI",
        "SauBMKI",
        "RrhJ1I",
        "SauHPI",
        "CcoI",
        "PdiI",
        "SauNI",
        "Slu1777I"
      ],
      site: "gccggc",
      forwardRegex: "gc{2}g{2}c",
      reverseRegex: "gc{2}g{2}c",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "AflIV",
        "BstMI",
        "Uba1158I",
        "LlaDI",
        "VchO49I",
        "NmeSI",
        "PinI",
        "Asp763I",
        "BsoSI",
        "Uba1094I",
        "BshHI"
      ],
      site: "agtact",
      forwardRegex: "agtact",
      reverseRegex: "agtact",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Eco190I",
        "Uba1280I",
        "Uba1347I",
        "RshII",
        "BspJ67I",
        "Uba1424I",
        "Uba1423I",
        "SflHK11086I",
        "Asp1I",
        "SflHK11087I",
        "BspF105I",
        "SflHK10695I",
        "Uba1372I",
        "Uba1370I",
        "Tmu1I",
        "Uba1378I",
        "Uba1401I",
        "Uba1376I",
        "Uba1389I",
        "Bsp55I",
        "SflHK11572I",
        "HgiS21I",
        "Uba1318I",
        "Pae181I",
        "Eco179I",
        "UbaN11I",
        "Eco121I",
        "Hin3I",
        "Bsp7I",
        "Bsp8I",
        "SflHK115731I",
        "Uba42I",
        "Uba41I",
        "EciDI",
        "Ssp2I"
      ],
      site: "ccsgg",
      forwardRegex: "c{2}[cgs]g{2}",
      reverseRegex: "c{2}[cgs]g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AgeI", "CsiAI", "AsiAI", "AsiGI", "PinAI", "BshTI", "CspAI"],
      site: "accggt",
      forwardRegex: "ac{2}g{2}t",
      reverseRegex: "ac{2}g{2}t",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BtsI"],
      site: "gcagtg",
      forwardRegex: "gcagtg",
      reverseRegex: "cactgc",
      topSnipOffset: 8,
      bottomSnipOffset: 6,
      isType2S: true
    },
    {
      aliases: [
        "SteI",
        "Eco147I",
        "StuI",
        "PceI",
        "AatI",
        "SarI",
        "Pme55I",
        "GdiI",
        "Sru30DI",
        "SseBI",
        "Eco1524I",
        "AspMI"
      ],
      site: "aggcct",
      forwardRegex: "ag{2}c{2}t",
      reverseRegex: "ag{2}c{2}t",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "HpyF10I",
        "HinS1I",
        "HinS2I",
        "Hin7I",
        "BcaI",
        "HinGUI",
        "Hpy99III",
        "Mho2965I",
        "Csp1470I",
        "MnnIV",
        "CcoP95I",
        "NgoEII"
      ],
      site: "gcgc",
      forwardRegex: "gcgc",
      reverseRegex: "gcgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BceBI",
        "Bsp50I",
        "BtkI",
        "Bpu95I",
        "Csp68KVI",
        "BepI",
        "MvnI",
        "Bsh1236I",
        "AccII",
        "BstFNI",
        "FnuDII",
        "FalII",
        "FauBII",
        "Bsp123I",
        "ThaI",
        "BstUI",
        "BspFNI",
        "Bsu1532I"
      ],
      site: "cgcg",
      forwardRegex: "cgcg",
      reverseRegex: "cgcg",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["TspBI", "BstDSI", "BtgI", "DsaI"],
      site: "ccrygg",
      forwardRegex: "c{2}[agr][cty]g{2}",
      reverseRegex: "c{2}[agr][cty]g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "BecAII",
        "BspKI",
        "HaeIII",
        "PlaI",
        "BshFI",
        "BspBRI",
        "BspRI",
        "SuaI",
        "PhoI",
        "Pde133I",
        "SbvI",
        "NgoPII",
        "PalI",
        "PflKI",
        "BteI",
        "SfaI",
        "Bsp211I",
        "DsaII",
        "Bme361I",
        "BsuRI",
        "BshI",
        "BsnI",
        "CltI",
        "NspLKI",
        "MchAII",
        "EsaBC4I",
        "BspANI",
        "FnuDI",
        "BseQI",
        "Bim19II",
        "MfoAI",
        "BanAI",
        "Pru2I"
      ],
      site: "ggcc",
      forwardRegex: "g{2}c{2}",
      reverseRegex: "g{2}c{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "CceI",
        "Bsp116I",
        "HpyF43I",
        "Uba1355I",
        "Asp748I",
        "M.Csp68KIV",
        "Uba1128I",
        "Uba1267I",
        "Pme35I",
        "SecII",
        "Uba1141I",
        "Bsp48I",
        "Bsp47I",
        "HpyVIII",
        "BsaZI",
        "FinII",
        "Hin5I",
        "SfaGUI",
        "Msp199I",
        "MniII",
        "Bsu1192I",
        "Uba1338I",
        "Bsp5I",
        "Bsp1591II",
        "BshMI",
        "UbaN13I",
        "Uba1439I"
      ],
      site: "ccgg",
      forwardRegex: "c{2}g{2}",
      reverseRegex: "c{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Cfr10I",
        "Bse634I",
        "BssAI",
        "Bco118I",
        "Bse118I",
        "BstB7SI",
        "BsrFI"
      ],
      site: "rccggy",
      forwardRegex: "[agr]c{2}g{2}[cty]",
      reverseRegex: "[agr]c{2}g{2}[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BseRI"],
      isType2S: true,
      site: "gaggag",
      forwardRegex: "gag{2}ag",
      reverseRegex: "ctc{2}tc",
      topSnipOffset: 16,
      bottomSnipOffset: 14
    },
    {
      aliases: [
        "MmaI",
        "XmaII",
        "XorI",
        "ScoAI",
        "VpaK29AI",
        "XveI",
        "Pph2066I",
        "Asp708I",
        "Bsp43I",
        "Uba1399I",
        "Eco161I",
        "Eco83I",
        "BloHIII",
        "Eco167I",
        "Uba1184I",
        "BsaQI",
        "Pma44I",
        "MkrI",
        "Ali2882I",
        "Uba1232I",
        "Asp36I",
        "Pph2059I",
        "Ecl133I",
        "EaePI",
        "SkaII",
        "Bsp268I",
        "Psp28I",
        "Uba1115I",
        "PmaI",
        "Uba1116I",
        "Ssp12I",
        "Uba1112I",
        "Bth9411I",
        "Uba46I",
        "Bsp17I",
        "Uba1225I",
        "Uba1294II",
        "Uba1296I",
        "PspSI",
        "Ecl1zI",
        "AinI",
        "Uba1337I",
        "Uba1186I",
        "Uba1119I",
        "SriI",
        "UbaHKBI",
        "Uba1213I",
        "Uba1212I",
        "Uba1211I",
        "Uba1328I",
        "Bsp107I",
        "Uba1215I",
        "Uba1216I",
        "Esp141I",
        "NasI",
        "PmyI",
        "PshEI",
        "Pae24I",
        "Pae25I",
        "Pae22I",
        "Ecl593I",
        "Pae26I",
        "Pfl37I",
        "Uba1287I",
        "BbiI",
        "ClcI",
        "Bsp108I",
        "MauI",
        "VchO87I",
        "Bsp81I",
        "BspS122I",
        "VpaK4AI",
        "VpaK4BI",
        "Pae14I",
        "Pae15I",
        "Uba1123I",
        "GseII",
        "Kpn12I",
        "SgiI",
        "Ecl699kI",
        "Ecl77I",
        "Uba1411I",
        "Srl32DI",
        "Bsp93I",
        "Uba1417I",
        "XorKII",
        "Esp5II",
        "Eco260I",
        "Eco261I",
        "Srl2DI",
        "Uba1262I",
        "Pae40I",
        "Pae41I",
        "YenDI",
        "YenEI",
        "YenBI",
        "YenCI",
        "Eco49I",
        "YenAI",
        "BscDI",
        "TspGWII",
        "Eco48I",
        "Msp11I",
        "VpaKutGI",
        "AspTI",
        "Pae39I",
        "BsaNII",
        "Srl1DI",
        "Uba1256I",
        "CauIII",
        "Sal13I",
        "Uba1149I",
        "Bsp78I",
        "Bce170I",
        "Pae9I",
        "Pae8I",
        "Uba72I",
        "Psp46I",
        "Uba71I",
        "BmeBI",
        "SprLI",
        "NgbI",
        "NocI",
        "XphI",
        "MizI"
      ],
      site: "ctgcag",
      forwardRegex: "ctgcag",
      reverseRegex: "ctgcag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco32I", "HpyCI", "HjaI", "EcoRV", "CeqI", "NsiCI"],
      site: "gatatc",
      forwardRegex: "gatatc",
      reverseRegex: "gatatc",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "BspBS31I",
        "BbsI",
        "Bbv16II",
        "BpiI",
        "BstV2I",
        "BspTS514I",
        "BspIS4I",
        "BstBS32I",
        "Bsc91I",
        "BbvII",
        "BstTS5I",
        "BpuAI"
      ],
      isType2S: true,
      site: "gaagac",
      forwardRegex: "ga{2}gac",
      reverseRegex: "gtct{2}c",
      topSnipOffset: 8,
      bottomSnipOffset: 12
    },
    {
      aliases: [
        "BspJ64I",
        "HpyHPK5II",
        "Ssu212I",
        "Ssu211I",
        "R2.Ssu4109I",
        "TrsSI",
        "M.PhaTDam",
        "Uba1204I",
        "Bst1274I",
        "NlaDI",
        "TrsTI",
        "M.Kpn43816Dam",
        "UbaN1I",
        "CtyI",
        "Bth1997I",
        "Bth1786I",
        "AsuMBI",
        "Mel7JI",
        "Ssu220I",
        "NciAI",
        "BfiSHI",
        "M.EcoT2Dam",
        "SauCI",
        "M.Ssp6803Dam",
        "R1.Ssu11318I",
        "SalAI",
        "Bsp122I",
        "SauFI",
        "M.CjeEDam",
        "SauGI",
        "MspBI",
        "SauDI",
        "SauEI",
        "Uba59I",
        "SalHI",
        "Msp67II",
        "NmeAII",
        "Bth1140I",
        "BsmXII",
        "Bth1141I",
        "EsaLHCI",
        "SsuRBI",
        "NsuDI",
        "NgoDXIV",
        "Bsp91I",
        "Bsp61I",
        "Bsp60I",
        "R2.SsuDAT1I",
        "M.SmaII",
        "NsiAI",
        "Bsp65I",
        "Bsp135I",
        "Bsp64I",
        "R1.SsuDAT1I",
        "HpyAIII",
        "Mel5TI",
        "BthCanI",
        "Bsp138I",
        "Mel5OI",
        "Bsp136I",
        "Bsp66I",
        "FtnUIV",
        "BstEIII",
        "Bth211I",
        "Mel5JI",
        "SinMI",
        "M.HinHP1Dam",
        "M.EcoEc67Dam",
        "M.FspVDam",
        "CcoP31I",
        "R2.Ssu4961I",
        "Bth84I",
        "Cte1179I",
        "PfaI",
        "TruII",
        "Uba1259I",
        "Bsp72I",
        "Bsp74I",
        "Bsp147I",
        "FnuAII",
        "Bsp76I",
        "Cte1180I",
        "NflI",
        "CdiCD6II",
        "R1.Ssu4961I",
        "Mel4OI",
        "CcoP95II",
        "Sau6782I",
        "Bth221I",
        "Uba1366I",
        "Bth213I",
        "M.HindDam",
        "CpaPI",
        "Mmu5I",
        "Rlu1I",
        "Bme2494I",
        "BspI",
        "CviHI",
        "NanII",
        "MnoIII",
        "Sau15I",
        "Mel3JI",
        "R1.Ssu8074I",
        "M.YpsADam",
        "TdeI",
        "BsrMI",
        "Uba1317I",
        "Vha44I",
        "Bsp49I",
        "M.HinHP2Dam",
        "M.CviBII",
        "R1.Ssu2479I",
        "MthI",
        "BsrPII",
        "M.VvuDam",
        "Pph288I",
        "LlaDCHI",
        "Tsp133I",
        "Uba1183I",
        "Pei9403I",
        "Uba1182I",
        "SmiMBI",
        "M.StyDam",
        "M.TpaI",
        "M.PmuADam",
        "MjaIII",
        "Bth945I",
        "Mel2TI",
        "BsaPI",
        "BssGII",
        "M.NmaPhiCh1I",
        "BtcI",
        "Btu41I",
        "NmeBL859I",
        "Bsp58I",
        "Bsp59I",
        "M.CjeNIII",
        "Bsp57I",
        "Bsp54I",
        "MmeII",
        "Bsp52I",
        "M.PgiI",
        "Bsp51I",
        "Uba1177I",
        "NspAI",
        "NflBI",
        "Lsp1109II",
        "M.EcoT1Dam",
        "CcoP219I",
        "Mth1047I",
        "LlaKR2I",
        "Cin1467I",
        "CcoP76I",
        "Gst1588II",
        "M.EcoVT2Dam",
        "NmuEI",
        "R2.Ssu8074I",
        "MmuP2I",
        "Bsp18I",
        "NmuDI",
        "R1.Ssu4109I",
        "Btu34I",
        "R2.Ssu2479I",
        "Uba4I",
        "Btu33I",
        "MosI",
        "TrsKTI",
        "Btu39I",
        "Btu36I",
        "M.EcoT4Dam",
        "CjeP338I",
        "M.Sty14028Dam",
        "M.VchK139I",
        "Bsp9I",
        "Btu37I",
        "NsuI",
        "Uba1101I",
        "Csp5I",
        "R2.Ssu11318I",
        "M.EcoP1Dam",
        "M.StyLT2Dam",
        "CcoP84I",
        "Uba1323I",
        "MeuI",
        "M.EcoKDam",
        "BstXII",
        "CpfAI",
        "M.PmuDam",
        "Mph1103II",
        "NflAII",
        "MthAI"
      ],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SmaAIII",
        "EclJI",
        "Pvu84I",
        "Uba1129I",
        "XorKI",
        "DrdIII",
        "Uba1139I",
        "BmaDI",
        "BmaCI",
        "BmaBI",
        "Cfr51I",
        "RspI",
        "Xgl3220I",
        "Kpl79I",
        "Xgl3216I",
        "BmaI",
        "XniI",
        "Xgl3219I",
        "Xgl3218I",
        "Xgl3217I",
        "PntI",
        "BstZ8I",
        "BmaAI",
        "SplAIII",
        "SpaPII",
        "Cas2I",
        "XmlAI",
        "XmlI"
      ],
      site: "cgatcg",
      forwardRegex: "cgatcg",
      reverseRegex: "cgatcg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BthII", "Bth617I", "BsrWI", "BpuFI", "Ral8I"],
      site: "ggatc",
      forwardRegex: "g{2}atc",
      reverseRegex: "gatc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BfuAI", "BspMI", "Acc36I", "BveI"],
      isType2S: true,
      site: "acctgc",
      forwardRegex: "ac{2}tgc",
      reverseRegex: "gcag{2}t",
      topSnipOffset: 10,
      bottomSnipOffset: 14
    },
    {
      aliases: ["Bst2BI", "BssSI", "BsiI", "BauI"],
      site: "cacgag",
      forwardRegex: "cacgag",
      reverseRegex: "ctcgtg",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "NmuFI",
        "Afa24RI",
        "ApeAI",
        "RluI",
        "SaoI",
        "AmeII",
        "NasWI",
        "AniMI",
        "NmuI",
        "Srl77DI",
        "Esp5I",
        "NspWI",
        "Smo40529I",
        "SkaI",
        "MisI",
        "PglI",
        "Mlu9273II",
        "NtaSII",
        "NbrI",
        "NbaI",
        "BheI",
        "Psp61I",
        "AprI",
        "SacAI",
        "MauAI",
        "SauAI",
        "SalCI",
        "Uba1122I"
      ],
      site: "gccggc",
      forwardRegex: "gc{2}g{2}c",
      reverseRegex: "gc{2}g{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BthI",
        "DdeII",
        "PflNI",
        "BbiIII",
        "McaI",
        "ScuI",
        "PflWI",
        "Pfl67I",
        "Uba1237I",
        "Uba1397I",
        "SluI",
        "Uba1166I",
        "MecI",
        "Sca1827I",
        "Asp703I",
        "Uba1248I",
        "SdiAI",
        "Sfu1762I",
        "Msp23II",
        "AhyAI",
        "Psp4I",
        "Asp15I",
        "PspNI",
        "Ssp4I",
        "Uba1298I",
        "Uba1448I",
        "CjaI",
        "Uba1335I",
        "Sph1719I",
        "DrdDI",
        "SgoI",
        "MpuI",
        "Bsp92I",
        "Sve194I",
        "BadI",
        "Uba1271I",
        "MhaI",
        "SpaI",
        "Bsp129I",
        "SgaI",
        "AlwFII",
        "Shy1766I",
        "OcoI",
        "AerAI",
        "Uba1130I",
        "BbfI",
        "StaAI",
        "Asp47I",
        "Sgr1841I",
        "Bsp140I",
        "Bsp141I",
        "SrifpI",
        "Bsp142I",
        "MrhI",
        "BsuMI",
        "SciBI",
        "Uba1148I",
        "Sci1831I",
        "Eae2I",
        "MscAI",
        "Sal1974I",
        "Uba1154I",
        "SexI",
        "BstLI",
        "MsiI",
        "BstHI",
        "Bsp139I"
      ],
      site: "ctcgag",
      forwardRegex: "ctcgag",
      reverseRegex: "ctcgag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Uba1382I", "Uba1415I"],
      site: "gaatgc",
      forwardRegex: "ga{2}tgc",
      reverseRegex: "gcat{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Eco97I",
        "Eco95I",
        "Bli161I",
        "Eco120I",
        "Eco127I",
        "Eco233I",
        "Eco185I",
        "Eco217I",
        "Eco225I",
        "Eco203I",
        "Eco156I",
        "Eco204I",
        "Eco155I",
        "Eco205I",
        "Eco157I",
        "PpaI",
        "Eco162I",
        "Uba1316I",
        "SlbI",
        "Eco129I",
        "Sau12I",
        "Eco51I",
        "Bli49I",
        "Bli5508I",
        "Cfr56I",
        "VpaKutHI",
        "Eco71KI",
        "Eco42I",
        "VpaK57AI",
        "Uba84I",
        "Rle69I",
        "Eco263I",
        "Eco101I",
        "VpaK57I",
        "Uba1343I",
        "Bli576II",
        "Eco191I",
        "Uba65I",
        "Eco239I",
        "Eco246I",
        "Eco247I",
        "Eco240I",
        "Eco241I"
      ],
      site: "ggtctc",
      forwardRegex: "g{2}tctc",
      reverseRegex: "gagac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BmrI", "BfiI", "BmuI"],
      isType2S: true,
      site: "actggg",
      forwardRegex: "actg{3}",
      reverseRegex: "c{3}agt",
      topSnipOffset: 11,
      bottomSnipOffset: 10
    },
    {
      aliases: ["BstRZ246I", "MspSWI", "BstSWI", "SmiI", "SwaI"],
      site: "atttaaat",
      forwardRegex: "at{3}a{3}t",
      reverseRegex: "at{3}a{3}t",
      topSnipOffset: 4,
      bottomSnipOffset: 4
    },
    {
      aliases: ["Srl76DI", "Srl19I", "Srl61DI"],
      site: "tttaaa",
      forwardRegex: "t{3}a{3}",
      reverseRegex: "t{3}a{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Tsp32I", "Tsp32II", "TaqI", "PpaAII", "TthHB8I"],
      site: "tcga",
      forwardRegex: "tcga",
      reverseRegex: "tcga",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["EcoPI"],
      isType2S: true,
      site: "agacc",
      forwardRegex: "agac{2}",
      reverseRegex: "g{2}tct",
      topSnipOffset: 30,
      bottomSnipOffset: 32
    },
    {
      aliases: ["OmiBII", "DsaVI"],
      site: "gtmkac",
      forwardRegex: "gt[acm][gkt]ac",
      reverseRegex: "gt[acm][gkt]ac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpuSI", "BspLU11III", "BstOZ616I", "BslFI", "FaqI", "BsmFI"],
      isType2S: true,
      site: "gggac",
      forwardRegex: "g{3}ac",
      reverseRegex: "gtc{3}",
      topSnipOffset: 15,
      bottomSnipOffset: 19
    },
    {
      aliases: [
        "BspJ105I",
        "VpaK13AI",
        "Uba1314I",
        "GspAI",
        "Uba1249I",
        "PolI",
        "VpaK7AI",
        "NspDII",
        "BceSII",
        "MliI",
        "VpaK11DI",
        "AspBII",
        "VpaK11I",
        "NspGI",
        "BtiI",
        "NspKI",
        "VpaK11CI",
        "Uba1304I",
        "Bsp1260I",
        "MfoI",
        "Uba48I",
        "UbaN15I",
        "NmuAII",
        "Uba1438I",
        "Bsp100I",
        "Tsp301I",
        "BspF53I",
        "Uba62I",
        "ClmII",
        "VpaK65I",
        "AspDII",
        "NspHII",
        "Sgh1835I",
        "Uba1131I",
        "CliI",
        "Asp697I",
        "Uba1413I",
        "Nli3877II",
        "Uba1278I",
        "Uba1272I",
        "Bsp128I",
        "NliII",
        "MspAI",
        "Bst4QI",
        "SfnI",
        "Uth554I",
        "Uba1373I",
        "Tru28I",
        "Pfl19I",
        "SinJI",
        "SinHI",
        "SinGI",
        "SinFI",
        "SinEI",
        "SinDI",
        "SinCI",
        "SinBI",
        "SinAI",
        "Bsp133I",
        "Bsp132I",
        "SynI",
        "TruI",
        "Hsp2I",
        "Bsp71I"
      ],
      site: "ggwcc",
      forwardRegex: "g{2}[atw]c{2}",
      reverseRegex: "g{2}[atw]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "NtaSI",
        "Uba1180I",
        "SsvI",
        "Uba1239I",
        "Uba1170I",
        "Ppu13I",
        "VchO44I",
        "ChyI",
        "GobAI",
        "Uba1217I",
        "PluI",
        "Uba40I",
        "Uba1419I",
        "Asp78I",
        "Uba1371I",
        "Uba1403I"
      ],
      site: "aggcct",
      forwardRegex: "ag{2}c{2}t",
      reverseRegex: "ag{2}c{2}t",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BseGI", "BstF5I", "BtsCI"],
      site: "ggatg",
      forwardRegex: "g{2}atg",
      reverseRegex: "catc{2}",
      topSnipOffset: 7,
      bottomSnipOffset: 5,
      isType2S: true
    },
    {
      aliases: ["AvrII", "AspA2I", "XmaJI", "BlnI", "AvrBII", "BspA2I"],
      site: "cctagg",
      forwardRegex: "c{2}tag{2}",
      reverseRegex: "c{2}tag{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "BspKT8I",
        "SsbI",
        "BspLAIII",
        "LlaCI",
        "BstFI",
        "HindIII",
        "HsuI",
        "BbrI",
        "EcoVIII"
      ],
      site: "aagctt",
      forwardRegex: "a{2}gct{2}",
      reverseRegex: "a{2}gct{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "NsbI",
        "Acc16I",
        "PamI",
        "Pun14627I",
        "MstI",
        "AosI",
        "FspI",
        "AviII",
        "FdiII"
      ],
      site: "tgcgca",
      forwardRegex: "tgcgca",
      reverseRegex: "tgcgca",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["Ecl136II", "BpuAmI", "MxaI", "Eco53kI", "EcoICRI"],
      site: "gagctc",
      forwardRegex: "gagctc",
      reverseRegex: "gagctc",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "TtmI",
        "TspWAM8AI",
        "HpyF74II",
        "HpyF35II",
        "TspIDSI",
        "HpyF13III"
      ],
      site: "acgt",
      forwardRegex: "acgt",
      reverseRegex: "acgt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BseZI",
        "Ksp632I",
        "EarI",
        "Eam1104I",
        "Bsu6I",
        "Bst6I",
        "CatHI",
        "Bco116I",
        "Bco5I",
        "BcoKI"
      ],
      isType2S: true,
      site: "ctcttc",
      forwardRegex: "ctct{2}c",
      reverseRegex: "ga{2}gag",
      topSnipOffset: 7,
      bottomSnipOffset: 10
    },
    {
      aliases: [
        "Msp24I",
        "BsaSI",
        "HpyF73IV",
        "MjaII",
        "VpaK15I",
        "TdeIII",
        "Sau557I",
        "Sau17I",
        "GseI",
        "Bfi105I",
        "Eco201I",
        "CfrNI",
        "Sau13I",
        "Sau14I",
        "Bse54I",
        "Eco196II",
        "VpaK25I",
        "Uba1164I",
        "NlaDII",
        "Cfr4I",
        "Cfr8I",
        "CdiCD6I",
        "AhaB1I",
        "MthBI",
        "Pph1579I",
        "Pph1773I",
        "Hin5II",
        "Sau32I",
        "VpaK9AI",
        "Sau33I",
        "Uba1099I",
        "NmuSI",
        "SauBI",
        "VchO85I",
        "Sau5I",
        "Cfr33I",
        "Eco39I",
        "Sau2I",
        "ApuI",
        "VchO90I",
        "PspI",
        "Uba1134I",
        "BpsI",
        "Cfr23I",
        "MhoI",
        "PseI",
        "Eco47II",
        "HpyF71II",
        "VpaK19AI",
        "VpaK19BI",
        "SdyI",
        "NmuEII",
        "Cfr52I",
        "Cfr54I",
        "NspLII",
        "VpaKutBI",
        "CdiAI",
        "VpaKutAI",
        "Bsu5044I",
        "HpyF66I",
        "SelAI",
        "Cfr46I",
        "Cfr47I",
        "Cfr45I",
        "Uba1160I",
        "VchO66I",
        "VpaKutJI"
      ],
      site: "ggncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Cpa1150I",
        "PflAI",
        "TmaI",
        "BceRI",
        "FspMI",
        "MvaAI",
        "Uba1446I",
        "Bsu1193I",
        "EsaBS9I",
        "HpyF52II",
        "Bsu1192II",
        "HpyF14I",
        "HpyF15I",
        "Uba1321I",
        "HpyF64IV",
        "SceAI",
        "HpyF26I",
        "BspJ76I",
        "Bce31293I",
        "BsuEII",
        "Hin1056I",
        "Uba1405I",
        "Uba1404I",
        "Bsu6633I",
        "CpaAI",
        "Bsp70I"
      ],
      site: "cgcg",
      forwardRegex: "cgcg",
      reverseRegex: "cgcg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TseI", "ApeKI", "AceI", "Taq52I", "SuiI"],
      site: "gcwgc",
      forwardRegex: "gc[atw]gc",
      reverseRegex: "gc[atw]gc",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "Asp27HI",
        "Asp26HI",
        "PctI",
        "Asp40HI",
        "BsaMI",
        "BscCI",
        "BsmI",
        "BmaHI",
        "Mva1269I",
        "Asp50HI",
        "Asp36HI",
        "Asp35HI"
      ],
      site: "gaatgc",
      forwardRegex: "ga{2}tgc",
      reverseRegex: "gcat{2}c",
      topSnipOffset: 7,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Uba51I",
        "M.BamHII",
        "Uba1414I",
        "Uba1346I",
        "Bsu8646I",
        "AcaII",
        "SpvI",
        "BamNI",
        "GdoI",
        "UbaN3I",
        "BamKI",
        "Uba1205I",
        "BamFI",
        "BsuB519I",
        "Bst2902I",
        "Rlu4I",
        "Ali12257I",
        "Ali12258I",
        "Uba1250I",
        "RhsI",
        "Psp56I",
        "Uba1258I",
        "Bsp144I",
        "AinII",
        "Bco10278I",
        "Uba88I",
        "Uba1402I",
        "Bca1259I",
        "Bsp90II",
        "Bsp131I",
        "Bsp130I",
        "BstQI",
        "MleI",
        "Uba1383I",
        "Uba1302I",
        "GinI",
        "Uba19I",
        "Bst2464I",
        "Uba1167I",
        "GseIII",
        "Uba1163I",
        "BsaDI",
        "Pac1110I",
        "Bsp46I",
        "Uba1398I",
        "Uba1173I",
        "Uba1242I",
        "Uba1172I",
        "NasBI",
        "UbaN14I",
        "GoxI",
        "AaeI",
        "Uba31I",
        "DdsI",
        "Uba1324I",
        "Bsp30I",
        "Uba1325I",
        "AspTII",
        "Uba38I",
        "AacLI",
        "Pae177I",
        "Uba1098I",
        "BsuB763I",
        "Uba1339I",
        "Uba1297I",
        "Uba1334I",
        "Bst1126I",
        "Uba1224I",
        "Atu1II",
        "Bsu8565I",
        "Bsu90I"
      ],
      site: "ggatcc",
      forwardRegex: "g{2}atc{2}",
      reverseRegex: "g{2}atc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SpaPIII",
        "PvuHKUI",
        "MziI",
        "SciAII",
        "SplAIV",
        "Sol3335I",
        "Bth2350I",
        "GspI",
        "Uba1245I",
        "Uba1227I",
        "SmaAIV",
        "Psp3I",
        "SbaI",
        "Psp5I"
      ],
      site: "cagctg",
      forwardRegex: "cagctg",
      reverseRegex: "cagctg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BspZEI",
        "BscI",
        "Bsa29I",
        "PgaI",
        "BspOVII",
        "ClaI",
        "BseCI",
        "Bli41I",
        "BavCI",
        "BciBI",
        "LplI",
        "SpmI",
        "Ssp27144I",
        "ZhoI",
        "BspDI",
        "BanIII",
        "BsuTUI",
        "BshVI",
        "BspXI",
        "BstNZ169I",
        "Bsu15I",
        "BspJII",
        "AagI",
        "Bsp106I",
        "Bli86I",
        "BliAI",
        "Bst28I",
        "BbvAII",
        "BsiXI",
        "BcmI",
        "BliRI",
        "Bci29I",
        "LcaI",
        "Rme21I",
        "BdiI"
      ],
      site: "atcgat",
      forwardRegex: "atcgat",
      reverseRegex: "atcgat",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "BspJ74I",
        "Bco35I",
        "Bth1795I",
        "Uba1444I",
        "Bsp22I",
        "Bsp28I",
        "Uba1437I"
      ],
      site: "ctggag",
      forwardRegex: "ctg{2}ag",
      reverseRegex: "ctc{2}ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SolI",
        "Bsp98I",
        "Bce751I",
        "Uba4009I",
        "BamHI",
        "RspLKII",
        "SurI",
        "BstI",
        "OkrAI",
        "ApaCI",
        "Nsp29132II",
        "BspAAIII",
        "CelI",
        "AliI",
        "AsiI",
        "GstI",
        "Mlu23I",
        "NspSAIV",
        "Pfl8I",
        "BnaI",
        "AccEBI",
        "Bsp4009I"
      ],
      site: "ggatcc",
      forwardRegex: "g{2}atc{2}",
      reverseRegex: "g{2}atc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["M.NgoHVIII", "NgoMVIII", "NgoJVIII", "NgoBVIII", "NgoDVIII"],
      site: "ggtga",
      forwardRegex: "g{2}tga",
      reverseRegex: "tcac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "HpyF13I",
        "HpyF1I",
        "HpyF4I",
        "HpyF6II",
        "HpyF9I",
        "HpyF31II",
        "HpyF49II",
        "HpyF51I",
        "HpyF34II",
        "HpyF48I",
        "HpyF62III",
        "HpyF40III",
        "HpyF25II",
        "Hpy99II",
        "Hpy8II",
        "HpyF35IV",
        "HpyF36I"
      ],
      site: "gtsac",
      forwardRegex: "gt[cgs]ac",
      reverseRegex: "gt[cgs]ac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PsyI", "BgiI", "TelI", "Tth111I", "AspI", "PflFI", "AtsI"],
      site: "gacnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{3}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{3}gtc",
      topSnipOffset: 4,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "PfaAI",
        "AccB1I",
        "HgiHI",
        "HgiCI",
        "BspT107I",
        "MspB4I",
        "BanI",
        "BshNI",
        "Eco64I",
        "BbvBI"
      ],
      site: "ggyrcc",
      forwardRegex: "g{2}[cty][agr]c{2}",
      reverseRegex: "g{2}[cty][agr]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "BspMAI",
        "CflI",
        "Psp23I",
        "BspBI",
        "AliAJI",
        "Srl5DI",
        "MhaAI",
        "CfrA4I",
        "Ecl2zI",
        "AjoI",
        "Sag16I",
        "PstI",
        "Sag23I",
        "Ecl37kI",
        "Pfl21I",
        "ApiI",
        "Sst12I",
        "SalPI",
        "CstI",
        "YenI",
        "Bsp63I",
        "BloHII",
        "CfuII",
        "PaePI",
        "SflI",
        "HalII",
        "BsuBI",
        "Asp713I"
      ],
      site: "ctgcag",
      forwardRegex: "ctgcag",
      reverseRegex: "ctgcag",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SvoI", "PsuNI"],
      site: "crccggyg",
      forwardRegex: "c[agr]c{2}g{2}[cty]g",
      reverseRegex: "c[agr]c{2}g{2}[cty]g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SphI", "BbuI", "PaeI", "SpaHI", "RspLKI", "PfaAIII"],
      site: "gcatgc",
      forwardRegex: "gcatgc",
      reverseRegex: "gcatgc",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PspN4I", "BspLI", "BmiI", "AspNI", "BscBI", "NlaIV"],
      site: "ggnncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]{2}c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]{2}c{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "HpyHPK5I",
        "HpyF32I",
        "HpyF34I",
        "HpyHI",
        "HpyF25I",
        "HpyF27I",
        "HpyF24II",
        "HpyF37I",
        "HpyF13II",
        "HpyF60II",
        "HpyF59I",
        "HpyF68II",
        "HpyF4II",
        "Bpa36II",
        "HpyF67I",
        "HpyF41II",
        "HpyF64V",
        "Bst295I",
        "BscPI",
        "HpyF70I",
        "HpyF5I",
        "HpyF7I",
        "HpyF66II",
        "HpyF6III",
        "HpyF72II",
        "HpyF30II",
        "HpyF11I",
        "HpyF19I",
        "HpyF22II",
        "HpyCH4II",
        "HpyF9II",
        "HpyF21I"
      ],
      site: "ctnag",
      forwardRegex: "ct[abcdghkmnrstvwy]ag",
      reverseRegex: "ct[abcdghkmnrstvwy]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "HpyF51II",
        "HpyF74I",
        "HpyF42II",
        "HpyF35III",
        "HpyF9III",
        "HpyF64II",
        "HpyF20I",
        "HpyF22I",
        "HpyF12I",
        "HpyF41I",
        "HpyF40I",
        "HpyF46I",
        "HpyF56I",
        "HpyF58I",
        "HpyF55I",
        "HpyF54I",
        "HpyF5II",
        "HpyF48II",
        "HpyF69I",
        "HpyF68I",
        "HpyF65I",
        "HpyF62I"
      ],
      site: "acngt",
      forwardRegex: "ac[abcdghkmnrstvwy]gt",
      reverseRegex: "ac[abcdghkmnrstvwy]gt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "HpyF15II",
        "HpyF17I",
        "HpyF64III",
        "HpyF50II",
        "HpyF61I",
        "HpyF11II",
        "HpyF27II",
        "HpyF12II",
        "HpyF46IV",
        "Hpy166I",
        "HpyF42III",
        "HpyF33I",
        "HpyF28I",
        "HpyF19II"
      ],
      site: "tcnga",
      forwardRegex: "tc[abcdghkmnrstvwy]ga",
      reverseRegex: "tc[abcdghkmnrstvwy]ga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "EclRI",
        "TspMI",
        "Pac25I",
        "XmaCI",
        "EaeAI",
        "AhyI",
        "XmaI",
        "Cfr9I",
        "PspAI",
        "XcyI"
      ],
      site: "cccggg",
      forwardRegex: "c{3}g{3}",
      reverseRegex: "c{3}g{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["XapI", "CfaI", "FsiI", "ApoI", "AcsI"],
      site: "raatty",
      forwardRegex: "[agr]a{2}t{2}[cty]",
      reverseRegex: "[agr]a{2}t{2}[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "SenPI",
        "HpyNI",
        "Bsp548I",
        "LlaMI",
        "Eco51II",
        "Eco43I",
        "BsoI",
        "Bsp73I",
        "Eco200I",
        "Eco85I",
        "BsaCI",
        "Eco80I",
        "Uba17I",
        "Uba1391I",
        "Eco153I",
        "Bsp53I",
        "Eco93I"
      ],
      site: "ccngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Tsp49I", "TaiI", "TscI"],
      site: "acgt",
      forwardRegex: "acgt",
      reverseRegex: "acgt",
      topSnipOffset: 4,
      bottomSnipOffset: 0
    },
    {
      aliases: ["DraII", "EcoO109I"],
      site: "rggnccy",
      forwardRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      reverseRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Ssp34I",
        "AcaI",
        "Bsp151I",
        "Uba1452I",
        "Ssp48I",
        "Ssp47I",
        "BpuHI",
        "NspJI",
        "Uba1385I",
        "Rma376I",
        "NspFI",
        "Ssp45I",
        "NspBI",
        "Ssp42I",
        "Ssp43I",
        "Ssp14I",
        "Psc27I",
        "Psc28I",
        "BspH22I",
        "Afl83I",
        "Bsp101I",
        "Ssp152I",
        "Bsp102I",
        "Bsp104I",
        "Mva16I",
        "Bsp241I",
        "Rma523I",
        "Bsp82I",
        "Sgr1839I",
        "OspI",
        "Bsp90I",
        "AviI",
        "BspH106I",
        "BspH103I",
        "Bsp148I",
        "Nsp29132I"
      ],
      site: "ttcgaa",
      forwardRegex: "t{2}cga{2}",
      reverseRegex: "t{2}cga{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CjuII"],
      site: "caynnnnnctc",
      forwardRegex: "ca[cty][abcdghkmnrstvwy]{5}ctc",
      reverseRegex: "gag[abcdghkmnrstvwy]{5}[agr]tg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "UbaN6II",
        "BstNSII",
        "Bst7QI",
        "AspDI",
        "AspBI",
        "AvrI",
        "EspHK29I",
        "NspDI",
        "NspEI",
        "AcrI",
        "Uba1205II",
        "Gst1588I",
        "BstZ4I",
        "Uba1436I",
        "BstBAII",
        "Umi5I",
        "NliI",
        "NmuAI",
        "Uba1440I"
      ],
      site: "cycgrg",
      forwardRegex: "c[cty]cg[agr]g",
      reverseRegex: "c[cty]cg[agr]g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AdeI", "DraIII", "BstIZ316I"],
      site: "cacnnngtg",
      forwardRegex: "cac[abcdghkmnrstvwy]{3}gtg",
      reverseRegex: "cac[abcdghkmnrstvwy]{3}gtg",
      topSnipOffset: 6,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Uba153AI",
        "BavAI",
        "BavBI",
        "BspO4I",
        "BamGI",
        "BavI",
        "EclI",
        "Pvu84II",
        "BspM39I",
        "UbaM39I",
        "NmeRI",
        "PvuII",
        "DmaI",
        "Bsp153AI",
        "Pun14627II",
        "Cfr6I",
        "Pae17kI"
      ],
      site: "cagctg",
      forwardRegex: "cagctg",
      reverseRegex: "cagctg",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Ava458I",
        "Cfr38I",
        "Cfr39I",
        "KspHK15I",
        "Cfr40I",
        "EspHK24I",
        "Cfr55I",
        "EcoHAI",
        "Cfr59I",
        "Eco164I",
        "EspHK16I",
        "Uba1188I",
        "EciBI",
        "Eco90I",
        "Uba1327I",
        "Cfr14I",
        "Uba36I"
      ],
      site: "yggccr",
      forwardRegex: "[cty]g{2}c{2}[agr]",
      reverseRegex: "[cty]g{2}c{2}[agr]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MchAI", "CspBI", "NotI", "CsiBI", "CciNI"],
      site: "gcggccgc",
      forwardRegex: "gcg{2}c{2}gc",
      reverseRegex: "gcg{2}c{2}gc",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["BscKI", "Rtr20I", "BspVI", "Bco102II", "BsaVI"],
      site: "gaagac",
      forwardRegex: "ga{2}gac",
      reverseRegex: "gtct{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "AspMDI",
        "BfuCI",
        "NlaII",
        "HacI",
        "CcyI",
        "FnuEI",
        "FnuCI",
        "NdeII",
        "RalF40I",
        "BstMBI",
        "Sth368I",
        "SauMI",
        "Kzo9I",
        "MgoI",
        "MboI",
        "NphI",
        "Bsp67I",
        "BscFI",
        "LlaAI",
        "Bsp143I",
        "DpnII",
        "CviAI",
        "Bme12I",
        "PbrTI",
        "CpfI",
        "NmeCI",
        "SsiBI",
        "SsiAI",
        "Bfi57I",
        "Bst19II",
        "BstENII",
        "BssMI",
        "MkrAI",
        "BspAI",
        "BspFI",
        "BtkII",
        "BspJI",
        "CacI",
        "Bsp2095I",
        "BspKMI",
        "Sau3AI",
        "Bce243I",
        "Bsp105I"
      ],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 0,
      bottomSnipOffset: 4
    },
    {
      aliases: ["EcoprrI"],
      site: "ccannnnnnnrtgc",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{7}[agr]tgc",
      reverseRegex: "gca[cty][abcdghkmnrstvwy]{7}tg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Cfr48I",
        "Ese4I",
        "BscMI",
        "Uba1409I",
        "Eco262I",
        "Uba1159I",
        "Uba1264I",
        "Uba1263I",
        "Uba1363I",
        "Uba1142I",
        "Uba1357I",
        "Uba1421I",
        "Eco26I",
        "Eco25I",
        "Bsp117I",
        "Uba1206I",
        "Eco249I",
        "Eco35I",
        "Uba57I",
        "Uba1124I",
        "OmiAI",
        "OmiBI",
        "Eco113I",
        "Eco215I",
        "Eco216I",
        "Eco180I",
        "Uba1330I",
        "EcoT88I",
        "Uba1329I",
        "Ppu20I",
        "Eco232I",
        "Uba39I",
        "BstZ7I",
        "Uba1307I",
        "EcoT95I",
        "EcoT93I",
        "Eco68I",
        "Psp31I",
        "Eco211I"
      ],
      site: "grgcyc",
      forwardRegex: "g[agr]gc[cty]c",
      reverseRegex: "g[agr]gc[cty]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "PaeR7I",
        "PanI",
        "BluI",
        "BssHI",
        "TliI",
        "Sol10179I",
        "StrI",
        "SauLPII",
        "SlaI",
        "AbrI",
        "Sfr274I",
        "EscI",
        "Sbi68I",
        "Sau3239I",
        "MavI",
        "CcrI",
        "BspAAI",
        "MlaAI",
        "XpaI",
        "BstVI",
        "XhoI"
      ],
      site: "ctcgag",
      forwardRegex: "ctcgag",
      reverseRegex: "ctcgag",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["MchI", "Mly113I", "NarI", "NunII", "SseAI", "NdaI"],
      site: "ggcgcc",
      forwardRegex: "g{2}cgc{2}",
      reverseRegex: "g{2}cgc{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["EgeI", "Eco78I", "DinI", "SfoI", "EheI"],
      site: "ggcgcc",
      forwardRegex: "g{2}cgc{2}",
      reverseRegex: "g{2}cgc{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "M.AtuCI",
        "HpyF72III",
        "HpyF38I",
        "HpyF44I",
        "HpyAIV",
        "M.BabI",
        "HpyF55II",
        "HpyF2II",
        "HpyIV",
        "NcaI",
        "NsiHI",
        "HpyF60I",
        "CviEI",
        "CviFI",
        "CviCI",
        "M.SmeI",
        "CviDI",
        "CviGI",
        "HpyF10II",
        "HpyF71III",
        "Hpy87AI",
        "HpyF18I",
        "NovII"
      ],
      site: "gantc",
      forwardRegex: "ga[abcdghkmnrstvwy]tc",
      reverseRegex: "ga[abcdghkmnrstvwy]tc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Bsp6I",
        "SatI",
        "Uur960I",
        "ItaI",
        "Fsp4HI",
        "Fnu4HI",
        "BisI",
        "FbrI",
        "GluI",
        "BsoFI"
      ],
      site: "gcngc",
      forwardRegex: "gc[abcdghkmnrstvwy]gc",
      reverseRegex: "gc[abcdghkmnrstvwy]gc",
      topSnipOffset: 2,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BsoDI", "Tsp504I", "TauII"],
      site: "cggccg",
      forwardRegex: "cg{2}c{2}g",
      reverseRegex: "cg{2}c{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Hpy178II", "TceI", "HpyAII", "HpyII"],
      site: "gaaga",
      forwardRegex: "ga{2}ga",
      reverseRegex: "tct{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PfeI", "TfiI"],
      site: "gawtc",
      forwardRegex: "ga[atw]tc",
      reverseRegex: "ga[atw]tc",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "NspIII",
        "BsoBI",
        "AvaI",
        "PunAI",
        "NspSAI",
        "BstSI",
        "BcoI",
        "BmeT110I",
        "PlaAI",
        "Bse15I",
        "OfoI",
        "AquI",
        "Eco88I",
        "BspLU4I",
        "Ama87I",
        "Eco27kI",
        "BsiHKCI"
      ],
      site: "cycgrg",
      forwardRegex: "c[cty]cg[agr]g",
      reverseRegex: "c[cty]cg[agr]g",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["SdeAI"],
      site: "cagrag",
      forwardRegex: "cag[agr]ag",
      reverseRegex: "ct[cty]ctg",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["BcoDI", "BsoMAI", "BsmAI", "Alw26I", "BstMAI"],
      site: "gtctc",
      forwardRegex: "gtctc",
      reverseRegex: "gagac",
      topSnipOffset: 6,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: [
        "SauHI",
        "Uba1294I",
        "BseG73I",
        "Uba1184II",
        "PxyMZI",
        "AsuSAI",
        "SecIII",
        "Bli643I",
        "Eco76I",
        "Bst29I",
        "Eco110kI",
        "BstZ6I",
        "Eco118I",
        "Bst30I",
        "EciCI",
        "Eco115I",
        "Uba1333I",
        "Uba1332I"
      ],
      site: "cctnagg",
      forwardRegex: "c{2}t[abcdghkmnrstvwy]ag{2}",
      reverseRegex: "c{2}t[abcdghkmnrstvwy]ag{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "HpyF44IV",
        "HpyCH4VI",
        "HpyF16II",
        "HpyF22III",
        "HpyF19III",
        "HpyNSH57II"
      ],
      site: "tcnnga",
      forwardRegex: "tc[abcdghkmnrstvwy]{2}ga",
      reverseRegex: "tc[abcdghkmnrstvwy]{2}ga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "OtuI",
        "MarI",
        "OtuNI",
        "Uba1433I",
        "Uba1441I",
        "Mho2111I",
        "BsaLI",
        "OxaI"
      ],
      site: "agct",
      forwardRegex: "agct",
      reverseRegex: "agct",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BfoI", "Bsp143II", "BstH2I", "AccB2I", "HaeII"],
      site: "rgcgcy",
      forwardRegex: "[agr]gcgc[cty]",
      reverseRegex: "[agr]gcgc[cty]",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco57I", "BspKT5I", "AcuI"],
      site: "ctgaag",
      forwardRegex: "ctga{2}g",
      reverseRegex: "ct{2}cag",
      topSnipOffset: 22,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: [
        "Uba1276I",
        "TdeII",
        "VpaO5I",
        "Bst158I",
        "UbaN7I",
        "BcrAI",
        "VpaKutEI",
        "VpaKutFI",
        "BsrEI",
        "Uba1192I",
        "BcoSI"
      ],
      site: "ctcttc",
      forwardRegex: "ctct{2}c",
      reverseRegex: "ga{2}gag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SsoII",
        "StyD4I",
        "BstSCI",
        "Eco137kI",
        "Ecl18kI",
        "BstMZ611I",
        "Eco13kI",
        "BssKI",
        "DsaV",
        "Eco21kI",
        "Kpn2kI"
      ],
      site: "ccngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BsmXI", "BsmDI", "BsmCI"],
      site: "acnnnnnctcc",
      forwardRegex: "ac[abcdghkmnrstvwy]{5}ctc{2}",
      reverseRegex: "g{2}ag[abcdghkmnrstvwy]{5}gt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Uba1426I",
        "Uba1420I",
        "TrsTII",
        "Uba1374I",
        "BscLI",
        "Uba1266I",
        "VfiI",
        "BsaFI",
        "Uba1313I",
        "Uba1312I",
        "Uba1299I",
        "Uba1331I",
        "Uba1443I",
        "Cfr92I"
      ],
      site: "cttaag",
      forwardRegex: "ct{2}a{2}g",
      reverseRegex: "ct{2}a{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "EcaI",
        "BstEII",
        "AspAI",
        "Eci125I",
        "BstT9I",
        "Bse64I",
        "AcrII",
        "BstPI",
        "BseT9I",
        "NspSAII",
        "BsiKI",
        "EcoO128I",
        "BstT10I",
        "Eco91I",
        "BseT10I",
        "EcoO65I",
        "PspEI"
      ],
      site: "ggtnacc",
      forwardRegex: "g{2}t[abcdghkmnrstvwy]ac{2}",
      reverseRegex: "g{2}t[abcdghkmnrstvwy]ac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 6
    },
    {
      aliases: ["HpyAV", "Hin4II"],
      site: "ccttc",
      forwardRegex: "c{2}t{2}c",
      reverseRegex: "ga{2}g{2}",
      topSnipOffset: 11,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["BseII", "BsaKI", "Uba1408II", "MwhI"],
      site: "gttaac",
      forwardRegex: "gt{2}a{2}c",
      reverseRegex: "gt{2}a{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Sse8387I", "SdaI", "SbfI"],
      site: "cctgcagg",
      forwardRegex: "c{2}tgcag{2}",
      reverseRegex: "c{2}tgcag{2}",
      topSnipOffset: 6,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "SacII",
        "CscI",
        "SpuI",
        "PaeAI",
        "GceI",
        "SchZI",
        "SstII",
        "Cfr42I",
        "PaeQI",
        "Eae46I",
        "Pae14kI",
        "RaqI",
        "Mpr154I",
        "GalI",
        "NgoAIII",
        "GceGLI",
        "Eco29kI",
        "Sfr303I",
        "Pae5kI",
        "NgoPIII",
        "SenPT14bI",
        "SgrBI",
        "KspI",
        "SexBI",
        "SexCI",
        "Kpn378I"
      ],
      site: "ccgcgg",
      forwardRegex: "c{2}gcg{2}",
      reverseRegex: "c{2}gcg{2}",
      topSnipOffset: 4,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BpuNI", "FinI", "BscWI"],
      site: "gggac",
      forwardRegex: "g{3}ac",
      reverseRegex: "gtc{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Uba1431I",
        "SseI",
        "Umi7I",
        "Uba1447I",
        "PovI",
        "CpeI",
        "BceDI",
        "BmeTI",
        "Bco102I",
        "AtuSI",
        "M.TaeII",
        "Bst77I",
        "BstKI",
        "BstGI",
        "SstIV",
        "Uba1282I",
        "CthI",
        "Uba1283I",
        "BstZ10II"
      ],
      site: "tgatca",
      forwardRegex: "tgatca",
      reverseRegex: "tgatca",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MaeIII"],
      site: "gtnac",
      forwardRegex: "gt[abcdghkmnrstvwy]ac",
      reverseRegex: "gt[abcdghkmnrstvwy]ac",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Eco646I",
        "Eco1341I",
        "Eco1413I",
        "Eco1432I",
        "Eco1424I",
        "Eco1422I",
        "Eco1383I"
      ],
      site: "ccannnnnnncttc",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{7}ct{2}c",
      reverseRegex: "ga{2}g[abcdghkmnrstvwy]{7}tg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "MvaI",
        "Bst1I",
        "Bst2I",
        "BsiLI",
        "CthII",
        "Sth302I",
        "BshGI",
        "BspNI",
        "TaqXI",
        "Bse17I",
        "Bse16I",
        "Bst2UI",
        "Bse24I",
        "Bst38I",
        "SslI",
        "BciBII",
        "AglI",
        "BthDI",
        "BthEI",
        "ApyI",
        "ZanI",
        "CbrI",
        "BstM6I",
        "BptI",
        "AorI",
        "ApaORI",
        "BseBI",
        "Fsp1604I",
        "AeuI",
        "Sth117I",
        "SniI",
        "Bst100I",
        "BstOI",
        "BstNI"
      ],
      site: "ccwgg",
      forwardRegex: "c{2}[atw]g{2}",
      reverseRegex: "c{2}[atw]g{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Bco27I",
        "CboI",
        "MspI",
        "BsuFI",
        "BsiSI",
        "Pde137I",
        "HpaII",
        "Sth134I",
        "Hin2I",
        "Bst40I",
        "HapII",
        "MnoI"
      ],
      site: "ccgg",
      forwardRegex: "c{2}g{2}",
      reverseRegex: "c{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Uba1368I",
        "Uba1156I",
        "Uba1157I",
        "Uba1202I",
        "EciEI",
        "Psp30I",
        "Uba1165I",
        "Uba1241I"
      ],
      site: "gggccc",
      forwardRegex: "g{3}c{3}",
      reverseRegex: "g{3}c{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SduI",
        "BsoCI",
        "BspLS2I",
        "MhlI",
        "Bsp1286I",
        "BmyI",
        "NspII",
        "AocII"
      ],
      site: "gdgchc",
      forwardRegex: "g[adgkrtw]gc[achmtwy]c",
      reverseRegex: "g[adgkrtw]gc[achmtwy]c",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["KspAI", "BstEZ359I", "BstHPI", "SsrI", "HpaI"],
      site: "gttaac",
      forwardRegex: "gt{2}a{2}c",
      reverseRegex: "gt{2}a{2}c",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["SfiI", "SdiI"],
      site: "ggccnnnnnggcc",
      forwardRegex: "g{2}c{2}[abcdghkmnrstvwy]{5}g{2}c{2}",
      reverseRegex: "g{2}c{2}[abcdghkmnrstvwy]{5}g{2}c{2}",
      topSnipOffset: 8,
      bottomSnipOffset: 5
    },
    {
      aliases: ["LlaG2I", "NheI", "PstNHI", "AsuNHI"],
      site: "gctagc",
      forwardRegex: "gctagc",
      reverseRegex: "gctagc",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["AluBI", "AluI", "MltI"],
      site: "agct",
      forwardRegex: "agct",
      reverseRegex: "agct",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "HpyF49V",
        "HpyF36III",
        "M.CviSI",
        "HpyF48III",
        "HpyJP26I",
        "HpyF38II",
        "HpyF45II",
        "HpyF67II",
        "Hpy26I"
      ],
      site: "tgca",
      forwardRegex: "tgca",
      reverseRegex: "tgca",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["DraRI"],
      site: "caagnac",
      forwardRegex: "ca{2}g[abcdghkmnrstvwy]ac",
      reverseRegex: "gt[abcdghkmnrstvwy]ct{2}g",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: [
        "Eco1265I",
        "Eco1441I",
        "Eco1443I",
        "Eco1447I",
        "Eco1158I",
        "Eco14444I",
        "EcoBI"
      ],
      site: "tgannnnnnnntgct",
      forwardRegex: "tga[abcdghkmnrstvwy]{8}tgct",
      reverseRegex: "agca[abcdghkmnrstvwy]{8}tca",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BbeAI", "PmnI", "McaAI", "NamI", "PatAI", "MsaI"],
      site: "ggcgcc",
      forwardRegex: "g{2}cgc{2}",
      reverseRegex: "g{2}cgc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BstC8I", "Cac8I"],
      site: "gcnngc",
      forwardRegex: "gc[abcdghkmnrstvwy]{2}gc",
      reverseRegex: "gc[abcdghkmnrstvwy]{2}gc",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["EsaBC3I"],
      site: "tcga",
      forwardRegex: "tcga",
      reverseRegex: "tcga",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "Pfr12I",
        "AmeI",
        "Bsp146I",
        "Uba1203I",
        "Pfl23I",
        "PliI",
        "AaqI",
        "DaqI",
        "ScoNI",
        "Uba1387I"
      ],
      site: "gtgcac",
      forwardRegex: "gtgcac",
      reverseRegex: "gtgcac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "AccIII",
        "PinBII",
        "CauB3I",
        "MroI",
        "Aor13HI",
        "BseAI",
        "Bsp13I",
        "Kpn2I",
        "PtaI",
        "BspEI",
        "Bsu23I",
        "BsiMI",
        "BlfI",
        "BbvAIII",
        "BspMII"
      ],
      site: "tccgga",
      forwardRegex: "tc{2}g{2}a",
      reverseRegex: "tc{2}g{2}a",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Eco1342I", "Eco1344I", "EcoKI", "Eco1394I"],
      site: "aacnnnnnngtgc",
      forwardRegex: "a{2}c[abcdghkmnrstvwy]{6}gtgc",
      reverseRegex: "gcac[abcdghkmnrstvwy]{6}gt{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "NgoJI",
        "NgoGI",
        "NgoMI",
        "HinHI",
        "NgoAI",
        "NgoBI",
        "M.NgoEI",
        "NgoCI",
        "NgoWI",
        "Bst16I",
        "Btu34II",
        "Bst1473II",
        "BsmHI"
      ],
      site: "rgcgcy",
      forwardRegex: "[agr]gcgc[cty]",
      reverseRegex: "[agr]gcgc[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MboII", "NcuI"],
      site: "gaaga",
      forwardRegex: "ga{2}ga",
      reverseRegex: "tct{2}c",
      topSnipOffset: 13,
      bottomSnipOffset: 12,
      isType2S: true
    },
    {
      aliases: [
        "Eco188I",
        "Eco98I",
        "Uba1435I",
        "Hin5III",
        "Uba1219I",
        "UbaN17I",
        "SpaPIV",
        "Eco231I",
        "BstZ1II",
        "Csp231I",
        "Eco65I",
        "HinbIII",
        "ChuEI",
        "Asp52I",
        "Asp3065I",
        "Uba83I",
        "HinfII",
        "MkiI",
        "HinJCII",
        "BsmGII",
        "Hin1076III",
        "HinSAFI",
        "Hin173I",
        "Uba1164II",
        "BseHI",
        "BbrAI",
        "Bst170II",
        "BpeI",
        "Cfr32I"
      ],
      site: "aagctt",
      forwardRegex: "a{2}gct{2}",
      reverseRegex: "a{2}gct{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["StsI"],
      site: "ggatg",
      forwardRegex: "g{2}atg",
      reverseRegex: "catc{2}",
      topSnipOffset: 15,
      bottomSnipOffset: 19,
      isType2S: true
    },
    {
      aliases: ["BstZ2I", "Uba1191I", "Uba1190I"],
      site: "gacnnnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{5}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{5}gtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Hin6I", "HinP1I", "HsoI", "HspAI", "SciNI", "BbtI"],
      site: "gcgc",
      forwardRegex: "gcgc",
      reverseRegex: "gcgc",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["PmdI"],
      site: "cctcagc",
      forwardRegex: "c{2}tcagc",
      reverseRegex: "gctgag{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BcefI"],
      site: "acggc",
      forwardRegex: "acg{2}c",
      reverseRegex: "gc{2}gt",
      topSnipOffset: 17,
      bottomSnipOffset: 18,
      isType2S: true
    },
    {
      aliases: [
        "Eco52I",
        "BstZI",
        "EagI",
        "XmaIII",
        "BseX3I",
        "EclXI",
        "AaaI",
        "SenPT16I"
      ],
      site: "cggccg",
      forwardRegex: "cg{2}c{2}g",
      reverseRegex: "cg{2}c{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BsaJI", "SecI", "BssECI", "BseDI"],
      site: "ccnngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]{2}g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["CciI", "RspXI", "BspHI", "PagI", "RcaI"],
      site: "tcatga",
      forwardRegex: "tcatga",
      reverseRegex: "tcatga",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["FseI", "RigI"],
      site: "ggccggcc",
      forwardRegex: "g{2}c{2}g{2}c{2}",
      reverseRegex: "g{2}c{2}g{2}c{2}",
      topSnipOffset: 6,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BstMWI", "HpyF10VI", "Bce4I", "BceCI", "BspWI", "MwoI"],
      site: "gcnnnnnnngc",
      forwardRegex: "gc[abcdghkmnrstvwy]{7}gc",
      reverseRegex: "gc[abcdghkmnrstvwy]{7}gc",
      topSnipOffset: 7,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "HpyF10III",
        "Uba1442I",
        "HpyF67IV",
        "BstZ10I",
        "BsoKI",
        "HpyF61II",
        "Hpy99IV"
      ],
      site: "ccnngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]{2}g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Aor51HI", "FunI", "Eco47III", "AitI", "AfeI"],
      site: "agcgct",
      forwardRegex: "agcgct",
      reverseRegex: "agcgct",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["MlyI", "SchI"],
      site: "gagtc",
      forwardRegex: "gagtc",
      reverseRegex: "gactc",
      topSnipOffset: 10,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["BseB631I", "VanI", "Bpu86I", "Tsp219I", "BsoJI"],
      site: "gccnnnnnggc",
      forwardRegex: "gc{2}[abcdghkmnrstvwy]{5}g{2}c",
      reverseRegex: "gc{2}[abcdghkmnrstvwy]{5}g{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bsp120I", "PspOMI"],
      site: "gggccc",
      forwardRegex: "g{3}c{3}",
      reverseRegex: "g{3}c{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Csp6I", "RsaNI", "CviRII", "CviQI"],
      site: "gtac",
      forwardRegex: "gtac",
      reverseRegex: "gtac",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "M.Phi3TI",
        "Cac824I",
        "Bpu1811I",
        "M.NgoBXII",
        "M.Rho11sI",
        "CcoP216I",
        "CcoP215I",
        "Bli1904II",
        "BssFI",
        "BssXI",
        "M.SPBetaI",
        "LlaDII"
      ],
      site: "gcngc",
      forwardRegex: "gc[abcdghkmnrstvwy]gc",
      reverseRegex: "gc[abcdghkmnrstvwy]gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "AflII",
        "MspCI",
        "Vha464I",
        "Bst98I",
        "BstAFI",
        "Esp4I",
        "BstPZ740I",
        "BfrI",
        "BspTI"
      ],
      site: "cttaag",
      forwardRegex: "ct{2}a{2}g",
      reverseRegex: "ct{2}a{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BthCI"],
      site: "gcngc",
      forwardRegex: "gc[abcdghkmnrstvwy]gc",
      reverseRegex: "gc[abcdghkmnrstvwy]gc",
      topSnipOffset: 4,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "TfiTok6A1I",
        "TspAK13D21I",
        "TspVil3I",
        "M.Rho11sII",
        "Hpy26II",
        "HpyF65II",
        "TflI",
        "HpyF16I",
        "TfiTok4A2I",
        "HpyF23I",
        "HpyV",
        "Tsp358I",
        "HpyF71I",
        "HpyF73II",
        "TfiA3I",
        "HpyF26III",
        "TspAK16D24I",
        "Tsc4aI",
        "HpyF42IV",
        "HpyF66IV",
        "TspVi4AI",
        "M.CviBIII",
        "TthRQI",
        "Tbr51I",
        "HpyF52I",
        "HpyF49I",
        "Tth24I",
        "M.Phi3TII",
        "HpyF64I",
        "CviSIII",
        "HpyF40II",
        "Taq20I",
        "Tsp505I",
        "HpyF35I",
        "HpyF62II",
        "HpyJP26II",
        "HpyF30I",
        "HpyF24I",
        "HpyF59III",
        "TspNI",
        "Tsp510I",
        "HpyF45I",
        "HpyF14III"
      ],
      site: "tcga",
      forwardRegex: "tcga",
      reverseRegex: "tcga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SthNI",
        "SthBI",
        "SthCI",
        "SthDI",
        "SthEI",
        "SthAI",
        "SthJI",
        "SthKI",
        "SthLI",
        "SthMI",
        "SthFI",
        "SthGI",
        "SthHI",
        "Uba1201I",
        "Uba76I",
        "Uba86I",
        "Uba85I",
        "Uba87I",
        "NmiI",
        "KpnK14I",
        "Eco149I",
        "MvsAI",
        "MvsDI",
        "MvsEI",
        "MvsBI",
        "MvsCI",
        "BspJ106I",
        "Sau10I",
        "Esp19I",
        "MvsI"
      ],
      site: "ggtacc",
      forwardRegex: "g{2}tac{2}",
      reverseRegex: "g{2}tac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["M.NgoBIX"],
      site: "gtannnnnctc",
      forwardRegex: "gta[abcdghkmnrstvwy]{5}ctc",
      reverseRegex: "gag[abcdghkmnrstvwy]{5}tac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Asp29HI",
        "HpyF65III",
        "HpyF21II",
        "HpyF59II",
        "Hpy303I",
        "HpyF10IV",
        "HpyF66III",
        "Hpy471I",
        "Hpy423I",
        "Hpy421I",
        "HpyHII",
        "Asp18HI",
        "CcoP73I",
        "HpyNSH57I",
        "Hpy312I",
        "HpyF53II",
        "Asp17HI",
        "HpyF44V",
        "Hpy401I",
        "HpyF13IV",
        "HpyF31I",
        "HpyF36II",
        "Asp16HI",
        "HpyF52III",
        "Hpy501I",
        "MjaV"
      ],
      site: "gtac",
      forwardRegex: "gtac",
      reverseRegex: "gtac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bsp19I", "NcoI"],
      site: "ccatgg",
      forwardRegex: "c{2}atg{2}",
      reverseRegex: "c{2}atg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Psp1406I", "AclI"],
      site: "aacgtt",
      forwardRegex: "a{2}cgt{2}",
      reverseRegex: "a{2}cgt{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "Uba1432I",
        "Asp17I",
        "Asp8HI",
        "AitII",
        "AitAI",
        "BpuGI",
        "Asp21HI",
        "Asp22I",
        "Asp1HI",
        "Asp14HI",
        "BscSI",
        "Asp6HI"
      ],
      site: "rgatcy",
      forwardRegex: "[agr]gatc[cty]",
      reverseRegex: "[agr]gatc[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["RpaB5I"],
      site: "cgrggac",
      forwardRegex: "cg[agr]g{2}ac",
      reverseRegex: "gtc{2}[cty]cg",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["LweI", "SfaNI", "BspST5I", "BmsI", "PhaI"],
      site: "gcatc",
      forwardRegex: "gcatc",
      reverseRegex: "gatgc",
      topSnipOffset: 10,
      bottomSnipOffset: 14,
      isType2S: true
    },
    {
      aliases: [
        "EcoA4I",
        "BspTNI",
        "EcoO44I",
        "Bso31I",
        "BsaI",
        "Eco31I",
        "Bli736I"
      ],
      isType2S: true,
      site: "ggtctc",
      forwardRegex: "g{2}tctc",
      reverseRegex: "gagac{2}",
      topSnipOffset: 7,
      bottomSnipOffset: 11
    },
    {
      aliases: ["Asi256I"],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Uba1362I",
        "TseAI",
        "Bka1125I",
        "HpyF36IV",
        "HpyF47I",
        "Mlu40I",
        "BstZ15I"
      ],
      site: "gdgchc",
      forwardRegex: "g[adgkrtw]gc[achmtwy]c",
      reverseRegex: "g[adgkrtw]gc[achmtwy]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Ppu21I", "BsaAI", "PsuAI", "BstBAI", "MspYI"],
      site: "yacgtr",
      forwardRegex: "[cty]acgt[agr]",
      reverseRegex: "[cty]acgt[agr]",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "Vsp2246I",
        "Eco50I",
        "Uba1127I",
        "Eco195I",
        "Bme05I",
        "Eco173I",
        "SspM1III",
        "Eco171I",
        "Esp25I",
        "Esp22I",
        "Esp21I",
        "Esp15I",
        "Esp9I",
        "Esp14I",
        "Esp13I",
        "Esp12I",
        "Esp11I",
        "Esp10I",
        "Esp1I",
        "Esp6I",
        "Pph14I",
        "Eco169I",
        "Eco168I"
      ],
      site: "ggyrcc",
      forwardRegex: "g{2}[cty][agr]c{2}",
      reverseRegex: "g{2}[cty][agr]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Mlu1106I"],
      site: "rggwccy",
      forwardRegex: "[agr]g{2}[atw]c{2}[cty]",
      reverseRegex: "[agr]g{2}[atw]c{2}[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Bst22I",
        "BsiYI",
        "BflI",
        "Bsc107I",
        "BseLI",
        "AfiI",
        "BslI",
        "Bsc4I"
      ],
      site: "ccnnnnnnngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]{7}g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]{7}g{2}",
      topSnipOffset: 7,
      bottomSnipOffset: 4
    },
    {
      aliases: ["BstD102I", "BsrBI", "MbiI", "AccBSI", "Bst31NI"],
      site: "ccgctc",
      forwardRegex: "c{2}gctc",
      reverseRegex: "gagcg{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BsrXI", "Msp23I", "BspLU11II"],
      site: "tctaga",
      forwardRegex: "tctaga",
      reverseRegex: "tctaga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AclNI", "BcuI", "SpeI", "AhlI"],
      site: "actagt",
      forwardRegex: "actagt",
      reverseRegex: "actagt",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["PunAII", "AvoI", "PauAI", "NspHI", "BstNSI", "NspI", "XceI"],
      site: "rcatgy",
      forwardRegex: "[agr]catg[cty]",
      reverseRegex: "[agr]catg[cty]",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MscI", "BalI", "MluNI", "MlsI", "Mlu31I", "Msp20I"],
      site: "tggcca",
      forwardRegex: "tg{2}c{2}a",
      reverseRegex: "tg{2}c{2}a",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BmgI"],
      site: "gkgccc",
      forwardRegex: "g[gkt]gc{3}",
      reverseRegex: "g{3}c[acm]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BglII", "NcrI", "Pae2kI", "Pae18kI", "NspMACI"],
      site: "agatct",
      forwardRegex: "agatct",
      reverseRegex: "agatct",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["FatII", "M.CviSII", "Hin8II"],
      site: "catg",
      forwardRegex: "catg",
      reverseRegex: "catg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CglI", "NgoFVII"],
      site: "gcsgc",
      forwardRegex: "gc[cgs]gc",
      reverseRegex: "gc[cgs]gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SspM1II", "NlaSII", "SspJII", "Uba1381I", "Hin8I", "SspM2II"],
      site: "grcgyc",
      forwardRegex: "g[agr]cg[cty]c",
      reverseRegex: "g[agr]cg[cty]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "VchO68I",
        "BscOI",
        "PaeCI",
        "Asp5HI",
        "Bsp121I",
        "Uba1226I",
        "Uba1162I",
        "CglAI",
        "BtgAII",
        "SpaXI"
      ],
      site: "gcatgc",
      forwardRegex: "gcatgc",
      reverseRegex: "gcatgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["XcaI", "BstZ17I", "BspM90I", "BssNAI", "BstBSI", "Bst1107I"],
      site: "gtatac",
      forwardRegex: "gtatac",
      reverseRegex: "gtatac",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["Bme1580I", "BstSLI", "BseSI", "BaeGI"],
      site: "gkgcmc",
      forwardRegex: "g[gkt]gc[acm]c",
      reverseRegex: "g[gkt]gc[acm]c",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "MthFI",
        "Rma500I",
        "Rma501I",
        "Rma503I",
        "FisI",
        "Rma509I",
        "Rma506I",
        "Rma510I",
        "MjaI",
        "Rma515I",
        "Rma516I",
        "Rma517I",
        "Rma518I",
        "Rma519I",
        "Rma496I",
        "Rma495I",
        "Rma522I",
        "Rma497I",
        "UbaN5I",
        "Rma490I",
        "Rma486I",
        "Rma485I"
      ],
      site: "ctag",
      forwardRegex: "ctag",
      reverseRegex: "ctag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SelI"],
      site: "cgcg",
      forwardRegex: "cgcg",
      reverseRegex: "cgcg",
      topSnipOffset: 0,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "Mlu9273I",
        "VchO70I",
        "Sna3286I",
        "SalDI",
        "PspDI",
        "Uba1117I",
        "Uba1386I",
        "AmaSI"
      ],
      site: "tcgcga",
      forwardRegex: "tcgcga",
      reverseRegex: "tcgcga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Hsp92I",
        "BbiII",
        "Msp17I",
        "HgiGI",
        "HgiDI",
        "AsuIII",
        "PamII",
        "BsaHI",
        "BstACI",
        "HgiHII",
        "AcyI",
        "BssNI",
        "Hin1I",
        "AhaII",
        "AstWI",
        "HgiI",
        "AosII"
      ],
      site: "grcgyc",
      forwardRegex: "g[agr]cg[cty]c",
      reverseRegex: "g[agr]cg[cty]c",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["BtgZI"],
      site: "gcgatg",
      forwardRegex: "gcgatg",
      reverseRegex: "catcgc",
      topSnipOffset: 16,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: ["Bme142I", "LpnI"],
      site: "rgcgcy",
      forwardRegex: "[agr]gcgc[cty]",
      reverseRegex: "[agr]gcgc[cty]",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["PlaAII", "HpyBI", "RsaI", "AfaI"],
      site: "gtac",
      forwardRegex: "gtac",
      reverseRegex: "gtac",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: [
        "Tru201I",
        "BloHI",
        "BstX2I",
        "MflI",
        "BstYI",
        "XhoII",
        "PsuI",
        "DsaIII"
      ],
      site: "rgatcy",
      forwardRegex: "[agr]gatc[cty]",
      reverseRegex: "[agr]gatc[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Eco252I",
        "Uba58I",
        "Van91II",
        "VchO2I",
        "Eco159I",
        "Hal22I",
        "Eco82I",
        "Eco228I",
        "Eco237I",
        "VchN100I"
      ],
      site: "gaattc",
      forwardRegex: "ga{2}t{2}c",
      reverseRegex: "ga{2}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MluB2I", "Bsp68I", "RruI", "SpoI", "NruI", "BtuMI", "Sbo13I"],
      site: "tcgcga",
      forwardRegex: "tcgcga",
      reverseRegex: "tcgcga",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "AlwXI",
        "Bst12I",
        "BseKI",
        "BbvI",
        "Bst71I",
        "BseXI",
        "BstV1I",
        "Bsp423I",
        "Lsp1109I"
      ],
      site: "gcagc",
      forwardRegex: "gcagc",
      reverseRegex: "gctgc",
      topSnipOffset: 13,
      bottomSnipOffset: 17,
      isType2S: true
    },
    {
      aliases: ["BspACI", "SsiI", "AciI"],
      site: "ccgc",
      forwardRegex: "c{2}gc",
      reverseRegex: "gcg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "EcoT38I",
        "PaeHI",
        "KoxII",
        "SacNI",
        "Eco24I",
        "BpuI",
        "FriOI",
        "Bsu1854I",
        "Eco75KI",
        "BanII",
        "BvuI",
        "HgiJII",
        "Bsp519I"
      ],
      site: "grgcyc",
      forwardRegex: "g[agr]gc[cty]c",
      reverseRegex: "g[agr]gc[cty]c",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PasI"],
      site: "cccwggg",
      forwardRegex: "c{3}[atw]g{3}",
      reverseRegex: "c{3}[atw]g{3}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["MluCI", "TseCI"],
      site: "aatt",
      forwardRegex: "a{2}t{2}",
      reverseRegex: "a{2}t{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "HpyF50I",
        "HpyF49III",
        "HpyF14II",
        "HpyF7III",
        "HpyF46III",
        "MjaIV"
      ],
      site: "gtnnac",
      forwardRegex: "gt[abcdghkmnrstvwy]{2}ac",
      reverseRegex: "gt[abcdghkmnrstvwy]{2}ac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Psp1009I", "Tsp8EI", "BglI"],
      site: "gccnnnnnggc",
      forwardRegex: "gc{2}[abcdghkmnrstvwy]{5}g{2}c",
      reverseRegex: "gc{2}[abcdghkmnrstvwy]{5}g{2}c",
      topSnipOffset: 7,
      bottomSnipOffset: 4
    },
    {
      aliases: ["SruI", "DraI", "PauAII", "AhaIII"],
      site: "tttaaa",
      forwardRegex: "t{3}a{3}",
      reverseRegex: "t{3}a{3}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["AccI", "XmiI", "FblI"],
      site: "gtmkac",
      forwardRegex: "gt[acm][gkt]ac",
      reverseRegex: "gt[acm][gkt]ac",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["PmeI", "MssI"],
      site: "gtttaaac",
      forwardRegex: "gt{3}a{3}c",
      reverseRegex: "gt{3}a{3}c",
      topSnipOffset: 4,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "PshDI",
        "PshCI",
        "PspBI",
        "Pgl34I",
        "Psp38I",
        "VpaK3AI",
        "VpaK3BI",
        "Bsp87I"
      ],
      site: "cacgtg",
      forwardRegex: "cacgtg",
      reverseRegex: "cacgtg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "AxyI",
        "AocI",
        "Lmu60I",
        "BspR7I",
        "OxaNI",
        "CvnI",
        "MstII",
        "Bsu36I",
        "Eco81I",
        "SshAI",
        "SauI",
        "BliHKI",
        "Bse21I"
      ],
      site: "cctnagg",
      forwardRegex: "c{2}t[abcdghkmnrstvwy]ag{2}",
      reverseRegex: "c{2}t[abcdghkmnrstvwy]ag{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["TsoI"],
      site: "tarcca",
      forwardRegex: "ta[agr]c{2}a",
      reverseRegex: "tg{2}[cty]ta",
      topSnipOffset: 17,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: [
        "PlaII",
        "LspI",
        "SspRFI",
        "BsiCI",
        "Bpu14I",
        "AcpI",
        "FspII",
        "MlaI",
        "AsuII",
        "Ssp1I",
        "Asp10HI",
        "NspV",
        "Bsp119I",
        "BspLAII",
        "SviI",
        "PpaAI",
        "SfuI",
        "CbiI",
        "Bim19I",
        "BstBI",
        "BimI",
        "Csp68KII",
        "Csp45I",
        "BspT104I"
      ],
      site: "ttcgaa",
      forwardRegex: "t{2}cga{2}",
      reverseRegex: "t{2}cga{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: [
        "EspHK26I",
        "Bla7920I",
        "Uba1375I",
        "BspH226I",
        "Cfr57I",
        "Tsp514I",
        "Bsp233I",
        "Uba1136I",
        "Uba1425I",
        "Tsp507I",
        "Bsp228I",
        "Uba1279I",
        "Bbf7411I",
        "BstZ3I",
        "Bsu22I",
        "BstZ1I",
        "BsiGI",
        "BsiOI",
        "Bsp508I"
      ],
      site: "tccgga",
      forwardRegex: "tc{2}g{2}a",
      reverseRegex: "tc{2}g{2}a",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpuEI", "Bce83I"],
      site: "cttgag",
      forwardRegex: "ct{2}gag",
      reverseRegex: "ctca{2}g",
      topSnipOffset: 22,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: [
        "AspS9I",
        "AsuI",
        "NspIV",
        "BsiZI",
        "Bsp1894I",
        "BspF4I",
        "Cfr13I",
        "BshKI",
        "BspBII",
        "Pde12I",
        "PspPI",
        "MaeK81II",
        "BavAII",
        "Nsp7121I",
        "BavBII",
        "Bal228I",
        "CcuI",
        "Sau96I",
        "AvcI",
        "Bsu54I",
        "Bce22I",
        "Bac36I"
      ],
      site: "ggncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: ["BstKTI", "BspKT6I"],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 3,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BfmI",
        "BdiSI",
        "Srl56DI",
        "BpcI",
        "BthP35I",
        "SfcI",
        "BstSFI",
        "LlaBI",
        "SfeI"
      ],
      site: "ctryag",
      forwardRegex: "ct[agr][cty]ag",
      reverseRegex: "ct[agr][cty]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["MseI", "Tru1I", "Tru9I", "SaqAI"],
      site: "ttaa",
      forwardRegex: "t{2}a{2}",
      reverseRegex: "t{2}a{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["Sau96mI", "Sau93I", "Sau98I", "Sau90I"],
      site: "ctyrag",
      forwardRegex: "ct[cty][agr]ag",
      reverseRegex: "ct[cty][agr]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TrsSII"],
      site: "gacnnnnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{6}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{6}gtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "ParI",
        "BsiQI",
        "BclI",
        "AbaI",
        "FbaI",
        "Ksp22I",
        "BstT7I",
        "BspXII"
      ],
      site: "tgatca",
      forwardRegex: "tgatca",
      reverseRegex: "tgatca",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Eco255I",
        "DpaI",
        "BmcAI",
        "ZrmI",
        "ScaI",
        "AssI",
        "Bpa34I",
        "Acc113I",
        "RflFII"
      ],
      site: "agtact",
      forwardRegex: "agtact",
      reverseRegex: "agtact",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: [
        "SplAII",
        "TteI",
        "TspI",
        "TrsKTII",
        "FsuI",
        "SmaAII",
        "NtaI",
        "SplII",
        "SpaPI",
        "TtrI"
      ],
      site: "gacnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{3}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{3}gtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AspLEI", "HhaI", "BspLAI", "CfoI", "BstHHI", "FnuDIII"],
      site: "gcgc",
      forwardRegex: "gcgc",
      reverseRegex: "gcgc",
      topSnipOffset: 3,
      bottomSnipOffset: 1
    },
    {
      aliases: ["StyLTI"],
      site: "cagag",
      forwardRegex: "cagag",
      reverseRegex: "ctctg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BsoEI",
        "Uba1289I",
        "Uba1290I",
        "BstWI",
        "Uba1309I",
        "Uba1308I",
        "Uba1310I",
        "Bpu1268I"
      ],
      site: "cctnnnnnagg",
      forwardRegex: "c{2}t[abcdghkmnrstvwy]{5}ag{2}",
      reverseRegex: "c{2}t[abcdghkmnrstvwy]{5}ag{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco826I", "Eco1455I"],
      site: "gcannnnnnctga",
      forwardRegex: "gca[abcdghkmnrstvwy]{6}ctga",
      reverseRegex: "tcag[abcdghkmnrstvwy]{6}tgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["ApaI", "PpeI"],
      site: "gggccc",
      forwardRegex: "g{3}c{3}",
      reverseRegex: "g{3}c{3}",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["KpnBI"],
      site: "caaannnnnnrtca",
      forwardRegex: "ca{3}[abcdghkmnrstvwy]{6}[agr]tca",
      reverseRegex: "tga[cty][abcdghkmnrstvwy]{6}t{3}g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UnbI"],
      site: "ggncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Uba1384I",
        "SmuCI",
        "AvaIII",
        "Uba1353I",
        "PxyJKI",
        "Uba1367I",
        "BfrCI",
        "SrlII"
      ],
      site: "atgcat",
      forwardRegex: "atgcat",
      reverseRegex: "atgcat",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "BspMKI",
        "XciI",
        "SalI",
        "HgiCIII",
        "Rtr63I",
        "Rrh4273I",
        "RflFI",
        "HgiDII",
        "NopI",
        "RtrI"
      ],
      site: "gtcgac",
      forwardRegex: "gtcgac",
      reverseRegex: "gtcgac",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["EcoR124I"],
      site: "gaannnnnnrtcg",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{6}[agr]tcg",
      reverseRegex: "cga[cty][abcdghkmnrstvwy]{6}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SynII", "Psc2I"],
      site: "gaannnnttc",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{4}t{2}c",
      reverseRegex: "ga{2}[abcdghkmnrstvwy]{4}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CspI", "Rsr2I", "RsrII", "CpoI"],
      site: "cggwccg",
      forwardRegex: "cg{2}[atw]c{2}g",
      reverseRegex: "cg{2}[atw]c{2}g",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["AscI", "PalAI", "SgsI"],
      site: "ggcgcgcc",
      forwardRegex: "g{2}cgcgc{2}",
      reverseRegex: "g{2}cgcgc{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: [
        "Uba69I",
        "TtmII",
        "BscEI",
        "BsrHI",
        "Kpn30I",
        "M.BssHIII",
        "BssBI",
        "Eco143I",
        "Eco152I",
        "Esp7I",
        "Esp8I",
        "CfrJ5I",
        "BsoPI"
      ],
      site: "gcgcgc",
      forwardRegex: "gcgcgc",
      reverseRegex: "gcgcgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "EclHKI",
        "BspOVI",
        "AhdI",
        "AspEI",
        "Eam1105I",
        "NruGI",
        "BmeRI",
        "DriI"
      ],
      site: "gacnnnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{5}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{5}gtc",
      topSnipOffset: 6,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Uba1222I", "Uba1221I", "BpuGCI", "Uba1320I", "Uba1284I"],
      site: "gctnagc",
      forwardRegex: "gct[abcdghkmnrstvwy]agc",
      reverseRegex: "gct[abcdghkmnrstvwy]agc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpuCI"],
      site: "ggcgga",
      forwardRegex: "g{2}cg{2}a",
      reverseRegex: "tc{2}gc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EspI", "BlpI", "Bsp1720I", "Bpu1102I", "CelII"],
      site: "gctnagc",
      forwardRegex: "gct[abcdghkmnrstvwy]agc",
      reverseRegex: "gct[abcdghkmnrstvwy]agc",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: [
        "Eco1476I",
        "Eco1427I",
        "Eco1430I",
        "Eco1323I",
        "Eco377I",
        "Eco1386I",
        "Eco37I",
        "Eco1344II",
        "Eco1456I"
      ],
      site: "ggannnnnnnnatgc",
      forwardRegex: "g{2}a[abcdghkmnrstvwy]{8}atgc",
      reverseRegex: "gcat[abcdghkmnrstvwy]{8}tc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MnnI", "Hin1160II", "ChuEII", "Hin1161II"],
      site: "gtyrac",
      forwardRegex: "gt[cty][agr]ac",
      reverseRegex: "gt[cty][agr]ac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SstI", "SacI", "Psp124BI"],
      site: "gagctc",
      forwardRegex: "gagctc",
      reverseRegex: "gagctc",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "SspD5II",
        "NsiI",
        "PinBI",
        "Asi372I",
        "Mph1103I",
        "Csp68KIII",
        "Zsp2I",
        "SepI",
        "EcoT22I",
        "BfrBI"
      ],
      site: "atgcat",
      forwardRegex: "atgcat",
      reverseRegex: "atgcat",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AsnI", "AseI", "VspI", "PshBI", "Sru4DI", "BpoAI"],
      site: "attaat",
      forwardRegex: "at{2}a{2}t",
      reverseRegex: "at{2}a{2}t",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["BmrFI", "Msp67I", "MspR9I", "ScrFI", "Bme1390I"],
      site: "ccngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]g{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 3
    },
    {
      aliases: ["McrI", "BsaOI", "BsiEI", "Bsh1285I", "BstMCI"],
      site: "cgrycg",
      forwardRegex: "cg[agr][cty]cg",
      reverseRegex: "cg[agr][cty]cg",
      topSnipOffset: 4,
      bottomSnipOffset: 2
    },
    {
      aliases: ["TspRI", "TscAI"],
      site: "castgnn",
      forwardRegex: "ca[cgs]tg[abcdghkmnrstvwy]{2}",
      reverseRegex: "[abcdghkmnrstvwy]{2}ca[cgs]tg",
      topSnipOffset: 7,
      bottomSnipOffset: 0
    },
    {
      aliases: ["BsmWI", "SmaAI", "SspKI", "SplAI", "PfuNI"],
      site: "cgtacg",
      forwardRegex: "cgtacg",
      reverseRegex: "cgtacg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CdiI"],
      site: "catcg",
      forwardRegex: "catcg",
      reverseRegex: "cgatg",
      topSnipOffset: 4,
      bottomSnipOffset: 4
    },
    {
      aliases: ["TrsKTIII"],
      site: "catatg",
      forwardRegex: "catatg",
      reverseRegex: "catatg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BseB631II"],
      site: "agatct",
      forwardRegex: "agatct",
      reverseRegex: "agatct",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Sth302II"],
      site: "ccgg",
      forwardRegex: "c{2}g{2}",
      reverseRegex: "c{2}g{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["PbuJKI", "Hpy178VI", "HpyF67III", "HinGUII", "HpyF6I"],
      site: "ggatg",
      forwardRegex: "g{2}atg",
      reverseRegex: "catc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaF13I"],
      site: "gagnnnnnnctgg",
      forwardRegex: "gag[abcdghkmnrstvwy]{6}ctg{2}",
      reverseRegex: "c{2}ag[abcdghkmnrstvwy]{6}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MreI", "Sse232I"],
      site: "cgccggcg",
      forwardRegex: "cgc{2}g{2}cg",
      reverseRegex: "cgc{2}g{2}cg",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: [
        "BsaGI",
        "HpyF7II",
        "Pph3215I",
        "Bfu1570I",
        "BsmPI",
        "HpyF46II",
        "Hpy8III"
      ],
      site: "gwgcwc",
      forwardRegex: "g[atw]gc[atw]c",
      reverseRegex: "g[atw]gc[atw]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BceSIII", "BceAI"],
      site: "acggc",
      forwardRegex: "acg{2}c",
      reverseRegex: "gc{2}gt",
      topSnipOffset: 17,
      bottomSnipOffset: 19,
      isType2S: true
    },
    {
      aliases: ["CstMI"],
      site: "aaggag",
      forwardRegex: "a{2}g{2}ag",
      reverseRegex: "ctc{2}t{2}",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["Acc65I", "Asp718I", "SthI", "AhaB8I"],
      site: "ggtacc",
      forwardRegex: "g{2}tac{2}",
      reverseRegex: "g{2}tac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["EacI", "BinI", "AlwI", "Bst31TI", "BspPI", "AclWI", "BstH9I"],
      site: "ggatc",
      forwardRegex: "g{2}atc",
      reverseRegex: "gatc{2}",
      topSnipOffset: 9,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["BspGI"],
      site: "ctggac",
      forwardRegex: "ctg{2}ac",
      reverseRegex: "gtc{2}ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BspCNI"],
      site: "ctcag",
      forwardRegex: "ctcag",
      reverseRegex: "ctgag",
      topSnipOffset: 14,
      bottomSnipOffset: 12,
      isType2S: true
    },
    {
      aliases: ["MunI", "MfeI"],
      site: "caattg",
      forwardRegex: "ca{2}t{2}g",
      reverseRegex: "ca{2}t{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["StySENI", "StySBLI"],
      site: "cgannnnnntacc",
      forwardRegex: "cga[abcdghkmnrstvwy]{6}tac{2}",
      reverseRegex: "g{2}ta[abcdghkmnrstvwy]{6}tcg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BfaI", "MthZI", "RmaI", "FspBI", "FgoI", "MaeI", "XspI"],
      site: "ctag",
      forwardRegex: "ctag",
      reverseRegex: "ctag",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BseYI"],
      site: "cccagc",
      forwardRegex: "c{3}agc",
      reverseRegex: "gctg{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["SmlI", "SmoI"],
      site: "ctyrag",
      forwardRegex: "ct[cty][agr]ag",
      reverseRegex: "ct[cty][agr]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Tsp509I", "Sse9I", "TspEI", "TasI"],
      site: "aatt",
      forwardRegex: "a{2}t{2}",
      reverseRegex: "a{2}t{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 4
    },
    {
      aliases: ["HgaI", "CseI"],
      site: "gacgc",
      forwardRegex: "gacgc",
      reverseRegex: "gcgtc",
      topSnipOffset: 10,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: ["PaeBI", "PspALI", "SmaI", "CfrJ4I"],
      site: "cccggg",
      forwardRegex: "c{3}g{3}",
      reverseRegex: "c{3}g{3}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["SnaBI", "Eco105I", "BstSNI"],
      site: "tacgta",
      forwardRegex: "tacgta",
      reverseRegex: "tacgta",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["Esp3I", "BstGZ53I", "BsmBI"],
      isType2S: true,
      site: "cgtctc",
      forwardRegex: "cgtctc",
      reverseRegex: "gagacg",
      topSnipOffset: 7,
      bottomSnipOffset: 11
    },
    {
      aliases: [
        "Bsp1591I",
        "Cfr19I",
        "Uba1291I",
        "SciAI",
        "KoxI",
        "BstDI",
        "Bse59I",
        "Bst31I",
        "Cfr7I"
      ],
      site: "ggtnacc",
      forwardRegex: "g{2}t[abcdghkmnrstvwy]ac{2}",
      reverseRegex: "g{2}t[abcdghkmnrstvwy]ac{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PstII"],
      site: "ctgatg",
      forwardRegex: "ctgatg",
      reverseRegex: "catcag",
      topSnipOffset: 31,
      bottomSnipOffset: 33,
      isType2S: true
    },
    {
      aliases: [
        "PflMI",
        "PflBI",
        "Asp10HII",
        "BasI",
        "Van91I",
        "AcpII",
        "Esp1396I",
        "AccB7I"
      ],
      site: "ccannnnntgg",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{5}tg{2}",
      reverseRegex: "c{2}a[abcdghkmnrstvwy]{5}tg{2}",
      topSnipOffset: 7,
      bottomSnipOffset: 4
    },
    {
      aliases: ["RceI"],
      site: "catcgac",
      forwardRegex: "catcgac",
      reverseRegex: "gtcgatg",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["BstDEI", "BstJZ301I", "HpyF3I", "DdeI"],
      site: "ctnag",
      forwardRegex: "ct[abcdghkmnrstvwy]ag",
      reverseRegex: "ct[abcdghkmnrstvwy]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: ["UbaN6I", "Bco631I", "Bco63I", "Bse631I"],
      site: "gatnnnnatc",
      forwardRegex: "gat[abcdghkmnrstvwy]{4}atc",
      reverseRegex: "gat[abcdghkmnrstvwy]{4}atc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["StySJI"],
      site: "gagnnnnnngtrc",
      forwardRegex: "gag[abcdghkmnrstvwy]{6}gt[agr]c",
      reverseRegex: "g[cty]ac[abcdghkmnrstvwy]{6}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BchI", "BsaUI", "BsrVI", "LfeI"],
      site: "gcagc",
      forwardRegex: "gcagc",
      reverseRegex: "gctgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BscAI", "Bst19I"],
      site: "gcatc",
      forwardRegex: "gcatc",
      reverseRegex: "gatgc",
      topSnipOffset: 9,
      bottomSnipOffset: 11,
      isType2S: true
    },
    {
      aliases: ["KteAI", "Uba1393I", "Uba1220I"],
      site: "cccggg",
      forwardRegex: "c{3}g{3}",
      reverseRegex: "c{3}g{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BctI"],
      site: "acggc",
      forwardRegex: "acg{2}c",
      reverseRegex: "gc{2}gt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BsePI", "PteI", "BssHII", "BstBZ153I", "PauI"],
      site: "gcgcgc",
      forwardRegex: "gcgcgc",
      reverseRegex: "gcgcgc",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["StyLTIII"],
      site: "gagnnnnnnrtayg",
      forwardRegex: "gag[abcdghkmnrstvwy]{6}[agr]ta[cty]g",
      reverseRegex: "c[agr]ta[cty][abcdghkmnrstvwy]{6}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["VpaK32I", "PciSI", "LguI", "BspQI", "SapI"],
      isType2S: true,
      site: "gctcttc",
      forwardRegex: "gctct{2}c",
      reverseRegex: "ga{2}gagc",
      topSnipOffset: 8,
      bottomSnipOffset: 11
    },
    {
      aliases: ["BniI"],
      site: "gcnngc",
      forwardRegex: "gc[abcdghkmnrstvwy]{2}gc",
      reverseRegex: "gc[abcdghkmnrstvwy]{2}gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoDR2"],
      site: "tcannnnnngtcg",
      forwardRegex: "tca[abcdghkmnrstvwy]{6}gtcg",
      reverseRegex: "cgac[abcdghkmnrstvwy]{6}tga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TssI"],
      site: "gagnnnctc",
      forwardRegex: "gag[abcdghkmnrstvwy]{3}ctc",
      reverseRegex: "gag[abcdghkmnrstvwy]{3}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Tth111II"],
      site: "caarca",
      forwardRegex: "ca{2}[agr]ca",
      reverseRegex: "tg[cty]t{2}g",
      topSnipOffset: 17,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: ["BbvCI", "AbeI"],
      site: "cctcagc",
      forwardRegex: "c{2}tcagc",
      reverseRegex: "gctgag{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["MluI", "Bbi24I"],
      site: "acgcgt",
      forwardRegex: "acgcgt",
      reverseRegex: "acgcgt",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["MnlI"],
      site: "cctc",
      forwardRegex: "c{2}tc",
      reverseRegex: "gag{2}",
      topSnipOffset: 11,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["SspD5I"],
      site: "ggtga",
      forwardRegex: "g{2}tga",
      reverseRegex: "tcac{2}",
      topSnipOffset: 13,
      bottomSnipOffset: 13,
      isType2S: true
    },
    {
      aliases: ["AspCNI"],
      site: "gccgc",
      forwardRegex: "gc{2}gc",
      reverseRegex: "gcg{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TauI", "BspUI"],
      site: "gcsgc",
      forwardRegex: "gc[cgs]gc",
      reverseRegex: "gc[cgs]gc",
      topSnipOffset: 4,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BinSII", "BbeI"],
      site: "ggcgcc",
      forwardRegex: "g{2}cgc{2}",
      reverseRegex: "g{2}cgc{2}",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpmI", "GsuI"],
      site: "ctggag",
      forwardRegex: "ctg{2}ag",
      reverseRegex: "ctc{2}ag",
      topSnipOffset: 22,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: [
        "NciI",
        "AhaI",
        "AseII",
        "Mgl14481I",
        "AsuC2I",
        "BpuMI",
        "HgiS22I",
        "CauII",
        "BcnI"
      ],
      site: "ccsgg",
      forwardRegex: "c{2}[cgs]g{2}",
      reverseRegex: "c{2}[cgs]g{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 3
    },
    {
      aliases: ["Eco1348I", "Eco777I", "Eco1412I"],
      site: "ggannnnnntatc",
      forwardRegex: "g{2}a[abcdghkmnrstvwy]{6}tatc",
      reverseRegex: "gata[abcdghkmnrstvwy]{6}tc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AgsI"],
      site: "ttsaa",
      forwardRegex: "t{2}[cgs]a{2}",
      reverseRegex: "t{2}[cgs]a{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 2
    },
    {
      aliases: ["Pfl18I", "Ssm4I", "Ssm5I", "NasSI", "ScoI", "Ecl137I"],
      site: "gagctc",
      forwardRegex: "gagctc",
      reverseRegex: "gagctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "CfrBI",
        "StyI",
        "ErhB9II",
        "Eco130I",
        "ErhI",
        "EcoT14I",
        "BsmSI",
        "BssT1I"
      ],
      site: "ccwwgg",
      forwardRegex: "c{2}[atw]{2}g{2}",
      reverseRegex: "c{2}[atw]{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["AlwFI"],
      site: "gaaaynnnnnrtg",
      forwardRegex: "ga{3}[cty][abcdghkmnrstvwy]{5}[agr]tg",
      reverseRegex: "ca[cty][abcdghkmnrstvwy]{5}[agr]t{3}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CviRI", "HpyCH4V", "HpyF44III"],
      site: "tgca",
      forwardRegex: "tgca",
      reverseRegex: "tgca",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["Bse19I", "AteI", "NspSAIII"],
      site: "ccatgg",
      forwardRegex: "c{2}atg{2}",
      reverseRegex: "c{2}atg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Srl65DI", "Srr17I", "Srl55DII", "CprJK722I", "Srl8DI", "PbuMZI"],
      site: "attaat",
      forwardRegex: "at{2}a{2}t",
      reverseRegex: "at{2}a{2}t",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "ClcII",
        "GspAII",
        "NspHIII",
        "Bco6I",
        "NspLI",
        "NspMI",
        "BsaTI",
        "CliII",
        "ApcTR183I",
        "AcaIII"
      ],
      site: "tgcgca",
      forwardRegex: "tgcgca",
      reverseRegex: "tgcgca",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CsiI", "MabI", "SexAI"],
      site: "accwggt",
      forwardRegex: "ac{2}[atw]g{2}t",
      reverseRegex: "ac{2}[atw]g{2}t",
      topSnipOffset: 1,
      bottomSnipOffset: 6
    },
    {
      aliases: ["HgiEII"],
      site: "accnnnnnnggt",
      forwardRegex: "ac{2}[abcdghkmnrstvwy]{6}g{2}t",
      reverseRegex: "ac{2}[abcdghkmnrstvwy]{6}g{2}t",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TseDI", "BscRI", "Bsp21I"],
      site: "rccggy",
      forwardRegex: "[agr]c{2}g{2}[cty]",
      reverseRegex: "[agr]c{2}g{2}[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bse23I", "BsmYI"],
      site: "ccnnnnnnngg",
      forwardRegex: "c{2}[abcdghkmnrstvwy]{7}g{2}",
      reverseRegex: "c{2}[abcdghkmnrstvwy]{7}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NdeI", "FauNDI", "PfaAII"],
      site: "catatg",
      forwardRegex: "catatg",
      reverseRegex: "catatg",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["VneAI", "Uba1326I"],
      site: "rggnccy",
      forwardRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      reverseRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SrlI", "NgoMIV", "SceIII", "NgoAIV", "MroNI", "Eco56I"],
      site: "gccggc",
      forwardRegex: "gc{2}g{2}c",
      reverseRegex: "gc{2}g{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["AsiSI", "SfaAI", "RgaI", "SgfI"],
      site: "gcgatcgc",
      forwardRegex: "gcgatcgc",
      reverseRegex: "gcgatcgc",
      topSnipOffset: 5,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BtsPI", "SaiI", "ShaI"],
      site: "gggtc",
      forwardRegex: "g{3}tc",
      reverseRegex: "gac{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Pfl1108I"],
      site: "tcgtag",
      forwardRegex: "tcgtag",
      reverseRegex: "ctacga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoHK31I", "Bfi89I", "EaeI", "CfrI", "AcoI"],
      site: "yggccr",
      forwardRegex: "[cty]g{2}c{2}[agr]",
      reverseRegex: "[cty]g{2}c{2}[agr]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["HphI", "AsuHPI"],
      site: "ggtga",
      forwardRegex: "g{2}tga",
      reverseRegex: "tcac{2}",
      topSnipOffset: 13,
      bottomSnipOffset: 12,
      isType2S: true
    },
    {
      aliases: ["Uba1303I", "BstZ5I", "BscNI"],
      site: "cgrycg",
      forwardRegex: "cg[agr][cty]cg",
      reverseRegex: "cg[agr][cty]cg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bsp6II", "FsfI", "BspD6II", "Eco112I", "Eco125I"],
      site: "ctgaag",
      forwardRegex: "ctga{2}g",
      reverseRegex: "ct{2}cag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BstXI", "BstHZ55I"],
      site: "ccannnnnntgg",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{6}tg{2}",
      reverseRegex: "c{2}a[abcdghkmnrstvwy]{6}tg{2}",
      topSnipOffset: 8,
      bottomSnipOffset: 4
    },
    {
      aliases: ["Ppu11I", "Ppu6I"],
      site: "yacgtr",
      forwardRegex: "[cty]acgt[agr]",
      reverseRegex: "[cty]acgt[agr]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "EcoT104I",
        "SblAI",
        "SblBI",
        "SblCI",
        "Uba1311I",
        "Eco208II",
        "Bst224I"
      ],
      site: "ccwwgg",
      forwardRegex: "c{2}[atw]{2}g{2}",
      reverseRegex: "c{2}[atw]{2}g{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoR124II"],
      site: "gaannnnnnnrtcg",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{7}[agr]tcg",
      reverseRegex: "cga[cty][abcdghkmnrstvwy]{7}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MamI", "BseJI", "Bse8I", "BsrBRI", "BsiBI", "BsaBI", "Bsh1365I"],
      site: "gatnnnnatc",
      forwardRegex: "gat[abcdghkmnrstvwy]{4}atc",
      reverseRegex: "gat[abcdghkmnrstvwy]{4}atc",
      topSnipOffset: 5,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Ssp5230I", "AatII"],
      site: "gacgtc",
      forwardRegex: "gacgtc",
      reverseRegex: "gacgtc",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: [
        "Uba1240I",
        "Bpu1831I",
        "SspM1I",
        "SspM2I",
        "EciAI",
        "SspJI",
        "Eco158II"
      ],
      site: "tacgta",
      forwardRegex: "tacgta",
      reverseRegex: "tacgta",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MaqI"],
      site: "crttgac",
      forwardRegex: "c[agr]t{2}gac",
      reverseRegex: "gtca{2}[cty]g",
      topSnipOffset: 28,
      bottomSnipOffset: 26,
      isType2S: true
    },
    {
      aliases: ["CjeNII"],
      site: "gagnnnnngt",
      forwardRegex: "gag[abcdghkmnrstvwy]{5}gt",
      reverseRegex: "ac[abcdghkmnrstvwy]{5}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["KpnAI"],
      site: "gaannnnnntgcc",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{6}tgc{2}",
      reverseRegex: "g{2}ca[abcdghkmnrstvwy]{6}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SleI", "AjnI", "Psp6I", "PspGI", "SspAI", "EcoRII"],
      site: "ccwgg",
      forwardRegex: "c{2}[atw]g{2}",
      reverseRegex: "c{2}[atw]g{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BstFZ438I", "Bme585I", "SmuI", "FauI"],
      site: "cccgc",
      forwardRegex: "c{3}gc",
      reverseRegex: "gcg{3}",
      topSnipOffset: 9,
      bottomSnipOffset: 11,
      isType2S: true
    },
    {
      aliases: ["HpyCH4IV", "MaeII"],
      site: "acgt",
      forwardRegex: "acgt",
      reverseRegex: "acgt",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["TaqII"],
      site: "caccca",
      forwardRegex: "cac{3}a",
      reverseRegex: "tg{3}tg",
      topSnipOffset: 17,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: ["UbaN9I"],
      site: "aacgtt",
      forwardRegex: "a{2}cgt{2}",
      reverseRegex: "a{2}cgt{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["DrdII"],
      site: "gaacca",
      forwardRegex: "ga{2}c{2}a",
      reverseRegex: "tg{2}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MalI", "DpnI", "CfuI"],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["AarI"],
      isType2S: true,
      site: "cacctgc",
      forwardRegex: "cac{2}tgc",
      reverseRegex: "gcag{2}tg",
      topSnipOffset: 11,
      bottomSnipOffset: 15
    },
    {
      aliases: ["SrfI"],
      site: "gcccgggc",
      forwardRegex: "gc{3}g{3}c",
      reverseRegex: "gc{3}g{3}c",
      topSnipOffset: 4,
      bottomSnipOffset: 4
    },
    {
      aliases: ["TatI"],
      site: "wgtacw",
      forwardRegex: "[atw]gtac[atw]",
      reverseRegex: "[atw]gtac[atw]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["EcoDXXI"],
      site: "tcannnnnnnrttc",
      forwardRegex: "tca[abcdghkmnrstvwy]{7}[agr]t{2}c",
      reverseRegex: "ga{2}[cty][abcdghkmnrstvwy]{7}tga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HindII", "HincII", "HinJCI"],
      site: "gtyrac",
      forwardRegex: "gt[cty][agr]ac",
      reverseRegex: "gt[cty][agr]ac",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BseMI", "Bse3DI", "BsrDI"],
      site: "gcaatg",
      forwardRegex: "gca{2}tg",
      reverseRegex: "cat{2}gc",
      topSnipOffset: 8,
      bottomSnipOffset: 6,
      isType2S: true
    },
    {
      aliases: [
        "HalI",
        "Srl32DII",
        "FunII",
        "Ppu111I",
        "EcoRI",
        "RsrI",
        "Kpn49kI",
        "SsoI",
        "Srl55DI"
      ],
      site: "gaattc",
      forwardRegex: "ga{2}t{2}c",
      reverseRegex: "ga{2}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Hpy166III"],
      site: "cctc",
      forwardRegex: "c{2}tc",
      reverseRegex: "gag{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["FspAI"],
      site: "rtgcgcay",
      forwardRegex: "[agr]tgcgca[cty]",
      reverseRegex: "[agr]tgcgca[cty]",
      topSnipOffset: 4,
      bottomSnipOffset: 4
    },
    {
      aliases: ["Eco585I"],
      site: "gccnnnnnntgcg",
      forwardRegex: "gc{2}[abcdghkmnrstvwy]{6}tgcg",
      reverseRegex: "cgca[abcdghkmnrstvwy]{6}g{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PlaDI"],
      site: "catcag",
      forwardRegex: "catcag",
      reverseRegex: "ctgatg",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["Hpy188I"],
      site: "tcnga",
      forwardRegex: "tc[abcdghkmnrstvwy]ga",
      reverseRegex: "tc[abcdghkmnrstvwy]ga",
      topSnipOffset: 3,
      bottomSnipOffset: 2
    },
    {
      aliases: ["PciI", "PscI", "BspLU11I"],
      site: "acatgt",
      forwardRegex: "acatgt",
      reverseRegex: "acatgt",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["VchO25I", "SnaI"],
      site: "gtatac",
      forwardRegex: "gtatac",
      reverseRegex: "gtatac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TseBI", "M.BbvSI", "TneI"],
      site: "gcwgc",
      forwardRegex: "gc[atw]gc",
      reverseRegex: "gc[atw]gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["OliI", "AleI"],
      site: "cacnnnngtg",
      forwardRegex: "cac[abcdghkmnrstvwy]{4}gtg",
      reverseRegex: "cac[abcdghkmnrstvwy]{4}gtg",
      topSnipOffset: 5,
      bottomSnipOffset: 5
    },
    {
      aliases: ["GlaI"],
      site: "gcgc",
      forwardRegex: "gcgc",
      reverseRegex: "gcgc",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BssGI", "BscJI", "BstTI"],
      site: "ccannnnnntgg",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{6}tg{2}",
      reverseRegex: "c{2}a[abcdghkmnrstvwy]{6}tg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Tsp4CI", "Bst4CI", "HpyCH4III", "TaaI"],
      site: "acngt",
      forwardRegex: "ac[abcdghkmnrstvwy]gt",
      reverseRegex: "ac[abcdghkmnrstvwy]gt",
      topSnipOffset: 3,
      bottomSnipOffset: 2
    },
    {
      aliases: ["AceIII"],
      site: "cagctc",
      forwardRegex: "cagctc",
      reverseRegex: "gagctg",
      topSnipOffset: 13,
      bottomSnipOffset: 17,
      isType2S: true
    },
    {
      aliases: ["BseNI", "BsrI", "Bse1I", "Tsp1I", "BsrSI", "Bst11I"],
      site: "actgg",
      forwardRegex: "actg{2}",
      reverseRegex: "c{2}agt",
      topSnipOffset: 6,
      bottomSnipOffset: 4,
      isType2S: true
    },
    {
      aliases: ["FnuAI", "HinfI", "CviBI", "HhaII", "SscL1I"],
      site: "gantc",
      forwardRegex: "ga[abcdghkmnrstvwy]tc",
      reverseRegex: "ga[abcdghkmnrstvwy]tc",
      topSnipOffset: 1,
      bottomSnipOffset: 4
    },
    {
      aliases: ["CjuI"],
      site: "caynnnnnrtg",
      forwardRegex: "ca[cty][abcdghkmnrstvwy]{5}[agr]tg",
      reverseRegex: "ca[cty][abcdghkmnrstvwy]{5}[agr]tg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HpyF2I", "Bco163I"],
      site: "ctryag",
      forwardRegex: "ct[agr][cty]ag",
      reverseRegex: "ct[agr][cty]ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AanI", "PsiI"],
      site: "ttataa",
      forwardRegex: "t{2}ata{2}",
      reverseRegex: "t{2}ata{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["StySPI"],
      site: "aacnnnnnngtrc",
      forwardRegex: "a{2}c[abcdghkmnrstvwy]{6}gt[agr]c",
      reverseRegex: "g[cty]ac[abcdghkmnrstvwy]{6}gt{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpuJI", "BstDZ247I", "BscGI"],
      site: "cccgt",
      forwardRegex: "c{3}gt",
      reverseRegex: "acg{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Hpy99I"],
      site: "cgwcg",
      forwardRegex: "cg[atw]cg",
      reverseRegex: "cg[atw]cg",
      topSnipOffset: 5,
      bottomSnipOffset: 0
    },
    {
      aliases: ["BceSI"],
      site: "mmcgaag",
      forwardRegex: "[acm]{2}cga{2}g",
      reverseRegex: "ct{2}cg[gkt]{2}",
      topSnipOffset: 32,
      bottomSnipOffset: 34,
      isType2S: true
    },
    {
      aliases: ["HaeI"],
      site: "wggccw",
      forwardRegex: "[atw]g{2}c{2}[atw]",
      reverseRegex: "[atw]g{2}c{2}[atw]",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["PspPRI"],
      site: "ccycag",
      forwardRegex: "c{2}[cty]cag",
      reverseRegex: "ctg[agr]g{2}",
      topSnipOffset: 21,
      bottomSnipOffset: 19,
      isType2S: true
    },
    {
      aliases: ["FokI"],
      site: "ggatg",
      forwardRegex: "g{2}atg",
      reverseRegex: "catc{2}",
      topSnipOffset: 14,
      bottomSnipOffset: 18,
      isType2S: true
    },
    {
      aliases: [
        "NgoBV",
        "NgoGV",
        "Bsp29I",
        "HpyF44II",
        "Uba1445I",
        "Uba1305I",
        "HpyF73I",
        "BsaEI",
        "BcrI",
        "Rlu3I",
        "BssI"
      ],
      site: "ggnncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]{2}c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]{2}c{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bce1247I"],
      site: "gcnnnnnnngc",
      forwardRegex: "gc[abcdghkmnrstvwy]{7}gc",
      reverseRegex: "gc[abcdghkmnrstvwy]{7}gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AasI", "DrdI", "DseDI"],
      site: "gacnnnnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{6}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{6}gtc",
      topSnipOffset: 7,
      bottomSnipOffset: 5
    },
    {
      aliases: ["M.SssI"],
      site: "cg",
      forwardRegex: "cg",
      reverseRegex: "cg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HpyF61III"],
      site: "cgwcg",
      forwardRegex: "cg[atw]cg",
      reverseRegex: "cg[atw]cg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AflIII"],
      site: "acrygt",
      forwardRegex: "ac[agr][cty]gt",
      reverseRegex: "ac[agr][cty]gt",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Asp700I", "BbvAI", "MroXI", "XmnI", "PdmI"],
      site: "gaannnnttc",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{4}t{2}c",
      reverseRegex: "ga{2}[abcdghkmnrstvwy]{4}t{2}c",
      topSnipOffset: 5,
      bottomSnipOffset: 5
    },
    {
      aliases: ["ChaI"],
      site: "gatc",
      forwardRegex: "gatc",
      reverseRegex: "gatc",
      topSnipOffset: 4,
      bottomSnipOffset: 0
    },
    {
      aliases: ["EcoEI"],
      site: "gagnnnnnnnatgc",
      forwardRegex: "gag[abcdghkmnrstvwy]{7}atgc",
      reverseRegex: "gcat[abcdghkmnrstvwy]{7}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BspAAII", "XbaI"],
      site: "tctaga",
      forwardRegex: "tctaga",
      reverseRegex: "tctaga",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Hpy188III", "Hpy178III"],
      site: "tcnnga",
      forwardRegex: "tc[abcdghkmnrstvwy]{2}ga",
      reverseRegex: "tc[abcdghkmnrstvwy]{2}ga",
      topSnipOffset: 2,
      bottomSnipOffset: 4
    },
    {
      aliases: ["McaTI"],
      site: "gcgcgc",
      forwardRegex: "gcgcgc",
      reverseRegex: "gcgcgc",
      topSnipOffset: 4,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BstZ9I", "Uba6I", "ApeI"],
      site: "acgcgt",
      forwardRegex: "acgcgt",
      reverseRegex: "acgcgt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BspNCI"],
      site: "ccaga",
      forwardRegex: "c{2}aga",
      reverseRegex: "tctg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoHI", "Eco1831I", "Kpn49kII"],
      site: "ccsgg",
      forwardRegex: "c{2}[cgs]g{2}",
      reverseRegex: "c{2}[cgs]g{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: ["PpsI", "PleI"],
      site: "gagtc",
      forwardRegex: "gagtc",
      reverseRegex: "gactc",
      topSnipOffset: 9,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["BfuI", "BciVI"],
      site: "gtatcc",
      forwardRegex: "gtatc{2}",
      reverseRegex: "g{2}atac",
      topSnipOffset: 12,
      bottomSnipOffset: 11,
      isType2S: true
    },
    {
      aliases: ["TthHB27I"],
      site: "caarca",
      forwardRegex: "ca{2}[agr]ca",
      reverseRegex: "tg[cty]t{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PspXI"],
      site: "vctcgagb",
      forwardRegex: "[acgmrsv]ctcgag[bcgksty]",
      reverseRegex: "[acgmrsv]ctcgag[bcgksty]",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["Lsp1270I"],
      site: "rcatgy",
      forwardRegex: "[agr]catg[cty]",
      reverseRegex: "[agr]catg[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HpyC1I", "BccI"],
      site: "ccatc",
      forwardRegex: "c{2}atc",
      reverseRegex: "gatg{2}",
      topSnipOffset: 9,
      bottomSnipOffset: 10,
      isType2S: true
    },
    {
      aliases: ["BseMII"],
      site: "ctcag",
      forwardRegex: "ctcag",
      reverseRegex: "ctgag",
      topSnipOffset: 15,
      bottomSnipOffset: 13,
      isType2S: true
    },
    {
      aliases: ["BstENI", "EcoNI", "XagI"],
      site: "cctnnnnnagg",
      forwardRegex: "c{2}t[abcdghkmnrstvwy]{5}ag{2}",
      reverseRegex: "c{2}t[abcdghkmnrstvwy]{5}ag{2}",
      topSnipOffset: 5,
      bottomSnipOffset: 6
    },
    {
      aliases: ["EcoAI", "Eco1446I"],
      site: "gagnnnnnnngtca",
      forwardRegex: "gag[abcdghkmnrstvwy]{7}gtca",
      reverseRegex: "tgac[abcdghkmnrstvwy]{7}ctc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MmeI"],
      site: "tccrac",
      forwardRegex: "tc{2}[agr]ac",
      reverseRegex: "gt[cty]g{2}a",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["AjiI", "BmgBI", "BtrI"],
      site: "cacgtc",
      forwardRegex: "cacgtc",
      reverseRegex: "gacgtg",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BlsI"],
      site: "gcngc",
      forwardRegex: "gc[abcdghkmnrstvwy]gc",
      reverseRegex: "gc[abcdghkmnrstvwy]gc",
      topSnipOffset: 3,
      bottomSnipOffset: 2
    },
    {
      aliases: ["Bst170I", "BsmGI"],
      site: "tgtaca",
      forwardRegex: "tgtaca",
      reverseRegex: "tgtaca",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HpyBII", "Hpy166II", "Hpy8I"],
      site: "gtnnac",
      forwardRegex: "gt[abcdghkmnrstvwy]{2}ac",
      reverseRegex: "gt[abcdghkmnrstvwy]{2}ac",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["StySKI"],
      site: "cgatnnnnnnngtta",
      forwardRegex: "cgat[abcdghkmnrstvwy]{7}gt{2}a",
      reverseRegex: "ta{2}c[abcdghkmnrstvwy]{7}atcg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Esp23I", "Esp16I"],
      site: "cgtctc",
      forwardRegex: "cgtctc",
      reverseRegex: "gagacg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BmgT120I"],
      site: "ggncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BcoAI", "BbrPI", "PmlI", "PspCI", "PmaCI", "Eco72I", "AcvI"],
      site: "cacgtg",
      forwardRegex: "cacgtg",
      reverseRegex: "cacgtg",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["CjeP338II", "BscUI", "BsmNI", "BhaI"],
      site: "gcatc",
      forwardRegex: "gcatc",
      reverseRegex: "gatgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["KasI", "SspDI"],
      site: "ggcgcc",
      forwardRegex: "g{2}cgc{2}",
      reverseRegex: "g{2}cgc{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["FmuI"],
      site: "ggncc",
      forwardRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      reverseRegex: "g{2}[abcdghkmnrstvwy]c{2}",
      topSnipOffset: 4,
      bottomSnipOffset: 1
    },
    {
      aliases: ["RseI", "MslI", "SmiMI"],
      site: "caynnnnrtg",
      forwardRegex: "ca[cty][abcdghkmnrstvwy]{4}[agr]tg",
      reverseRegex: "ca[cty][abcdghkmnrstvwy]{4}[agr]tg",
      topSnipOffset: 5,
      bottomSnipOffset: 5
    },
    {
      aliases: ["NmuCI", "Tsp45I", "Hpy51I"],
      site: "gtsac",
      forwardRegex: "gt[cgs]ac",
      reverseRegex: "gt[cgs]ac",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Psp5II", "PpuMI", "PpuXI", "Pfl27I", "PspPPI"],
      site: "rggwccy",
      forwardRegex: "[agr]g{2}[atw]c{2}[cty]",
      reverseRegex: "[agr]g{2}[atw]c{2}[cty]",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Bba179I", "Bst1473I", "UbaN10I"],
      site: "wccggw",
      forwardRegex: "[atw]c{2}g{2}[atw]",
      reverseRegex: "[atw]c{2}g{2}[atw]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco912I"],
      site: "cacnnnnntggc",
      forwardRegex: "cac[abcdghkmnrstvwy]{5}tg{2}c",
      reverseRegex: "gc{2}a[abcdghkmnrstvwy]{5}gtg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SsmI"],
      site: "ctgatg",
      forwardRegex: "ctgatg",
      reverseRegex: "catcag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EsaSSI"],
      site: "gaccac",
      forwardRegex: "gac{2}ac",
      reverseRegex: "gtg{2}tc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoDI"],
      site: "ttannnnnnngtcy",
      forwardRegex: "t{2}a[abcdghkmnrstvwy]{7}gtc[cty]",
      reverseRegex: "[agr]gac[abcdghkmnrstvwy]{7}ta{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BsoHI", "BscHI"],
      site: "actgg",
      forwardRegex: "actg{2}",
      reverseRegex: "c{2}agt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NmeBI"],
      site: "gacgc",
      forwardRegex: "gacgc",
      reverseRegex: "gcgtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NspBII", "MspA1I"],
      site: "cmgckg",
      forwardRegex: "c[acm]gc[gkt]g",
      reverseRegex: "c[acm]gc[gkt]g",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BmgAI"],
      site: "gkgcmc",
      forwardRegex: "g[gkt]gc[acm]c",
      reverseRegex: "g[gkt]gc[acm]c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NmeAIII"],
      site: "gccgag",
      forwardRegex: "gc{2}gag",
      reverseRegex: "ctcg{2}c",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["DrdIV"],
      site: "tacgac",
      forwardRegex: "tacgac",
      reverseRegex: "gtcgta",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["BscQII"],
      site: "gtctc",
      forwardRegex: "gtctc",
      reverseRegex: "gagac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AbsI"],
      site: "cctcgagg",
      forwardRegex: "c{2}tcgag{2}",
      reverseRegex: "c{2}tcgag{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["Psp03I"],
      site: "ggwcc",
      forwardRegex: "g{2}[atw]c{2}",
      reverseRegex: "g{2}[atw]c{2}",
      topSnipOffset: 4,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BmtI", "BspOI", "AceII"],
      site: "gctagc",
      forwardRegex: "gctagc",
      reverseRegex: "gctagc",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["GsaI"],
      site: "cccagc",
      forwardRegex: "c{3}agc",
      reverseRegex: "gctg{3}",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaF9I"],
      site: "tacnnnnnrtgt",
      forwardRegex: "tac[abcdghkmnrstvwy]{5}[agr]tgt",
      reverseRegex: "aca[cty][abcdghkmnrstvwy]{5}gta",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Hin1II", "NlaIII", "FaeI", "Hsp92II", "HpyCH4I"],
      site: "catg",
      forwardRegex: "catg",
      reverseRegex: "catg",
      topSnipOffset: 4,
      bottomSnipOffset: 0
    },
    {
      aliases: ["Bbr7I"],
      site: "gaagac",
      forwardRegex: "ga{2}gac",
      reverseRegex: "gtct{2}c",
      topSnipOffset: 13,
      bottomSnipOffset: 17,
      isType2S: true
    },
    {
      aliases: ["Kaz48kI", "PssI"],
      site: "rggnccy",
      forwardRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      reverseRegex: "[agr]g{2}[abcdghkmnrstvwy]c{2}[cty]",
      topSnipOffset: 5,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BoxI", "BstPAI", "PshAI"],
      site: "gacnnnngtc",
      forwardRegex: "gac[abcdghkmnrstvwy]{4}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{4}gtc",
      topSnipOffset: 5,
      bottomSnipOffset: 5
    },
    {
      aliases: ["SgrDI"],
      site: "cgtcgacg",
      forwardRegex: "cgtcgacg",
      reverseRegex: "cgtcgacg",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["BssIMI", "SimI"],
      site: "gggtc",
      forwardRegex: "g{3}tc",
      reverseRegex: "gac{3}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["RleAI"],
      site: "cccaca",
      forwardRegex: "c{3}aca",
      reverseRegex: "tgtg{3}",
      topSnipOffset: 18,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: ["EciI"],
      site: "ggcgga",
      forwardRegex: "g{2}cg{2}a",
      reverseRegex: "tc{2}gc{2}",
      topSnipOffset: 17,
      bottomSnipOffset: 15,
      isType2S: true
    },
    {
      aliases: ["Eco57MI"],
      site: "ctgrag",
      forwardRegex: "ctg[agr]ag",
      reverseRegex: "ct[cty]cag",
      topSnipOffset: 22,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: ["AspJI", "Ppu1253I"],
      site: "gacgtc",
      forwardRegex: "gacgtc",
      reverseRegex: "gacgtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaF11I"],
      site: "tcgta",
      forwardRegex: "tcgta",
      reverseRegex: "tacga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SetI"],
      site: "asst",
      forwardRegex: "a[cgs]{2}t",
      reverseRegex: "a[cgs]{2}t",
      topSnipOffset: 4,
      bottomSnipOffset: 0
    },
    {
      aliases: ["PspOMII"],
      site: "cgcccar",
      forwardRegex: "cgc{3}a[agr]",
      reverseRegex: "[cty]tg{3}cg",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["BsxI"],
      site: "actggg",
      forwardRegex: "actg{3}",
      reverseRegex: "c{3}agt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco394I"],
      site: "gacnnnnnrtaay",
      forwardRegex: "gac[abcdghkmnrstvwy]{5}[agr]ta{2}[cty]",
      reverseRegex: "[agr]t{2}a[cty][abcdghkmnrstvwy]{5}gtc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["ApyPI"],
      site: "atcgac",
      forwardRegex: "atcgac",
      reverseRegex: "gtcgat",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["AlwNI", "CaiI"],
      site: "cagnnnctg",
      forwardRegex: "cag[abcdghkmnrstvwy]{3}ctg",
      reverseRegex: "cag[abcdghkmnrstvwy]{3}ctg",
      topSnipOffset: 6,
      bottomSnipOffset: 3
    },
    {
      aliases: ["TsuI"],
      site: "gcgac",
      forwardRegex: "gcgac",
      reverseRegex: "gtcgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Bca77I", "BsaWI", "BetI"],
      site: "wccggw",
      forwardRegex: "[atw]c{2}g{2}[atw]",
      reverseRegex: "[atw]c{2}g{2}[atw]",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["EcoDR3"],
      site: "tcannnnnnnatcg",
      forwardRegex: "tca[abcdghkmnrstvwy]{7}atcg",
      reverseRegex: "cgat[abcdghkmnrstvwy]{7}tga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SgrAI"],
      site: "crccggyg",
      forwardRegex: "c[agr]c{2}g{2}[cty]g",
      reverseRegex: "c[agr]c{2}g{2}[cty]g",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["M.NgoMXV"],
      site: "gcchr",
      forwardRegex: "gc{2}[achmtwy][agr]",
      reverseRegex: "[cty][adgkrtw]g{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["EcoRD2"],
      site: "gaannnnnnrttc",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{6}[agr]t{2}c",
      reverseRegex: "ga{2}[cty][abcdghkmnrstvwy]{6}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TspGWI"],
      site: "acgga",
      forwardRegex: "acg{2}a",
      reverseRegex: "tc{2}gt",
      topSnipOffset: 16,
      bottomSnipOffset: 14,
      isType2S: true
    },
    {
      aliases: ["CviAII"],
      site: "catg",
      forwardRegex: "catg",
      reverseRegex: "catg",
      topSnipOffset: 1,
      bottomSnipOffset: 3
    },
    {
      aliases: ["XcmI"],
      site: "ccannnnnnnnntgg",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{9}tg{2}",
      reverseRegex: "c{2}a[abcdghkmnrstvwy]{9}tg{2}",
      topSnipOffset: 8,
      bottomSnipOffset: 7
    },
    {
      aliases: ["EcoRD3"],
      site: "gaannnnnnnrttc",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{7}[agr]t{2}c",
      reverseRegex: "ga{2}[cty][abcdghkmnrstvwy]{7}t{2}c",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SpoDI"],
      site: "gcggrag",
      forwardRegex: "gcg{2}[agr]ag",
      reverseRegex: "ct[cty]c{2}gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaN12I"],
      site: "cacgag",
      forwardRegex: "cacgag",
      reverseRegex: "ctcgtg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PspFI"],
      site: "cccagc",
      forwardRegex: "c{3}agc",
      reverseRegex: "gctg{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PfoI"],
      site: "tccngga",
      forwardRegex: "tc{2}[abcdghkmnrstvwy]g{2}a",
      reverseRegex: "tc{2}[abcdghkmnrstvwy]g{2}a",
      topSnipOffset: 1,
      bottomSnipOffset: 6
    },
    {
      aliases: ["Sse8647I"],
      site: "aggwcct",
      forwardRegex: "ag{2}[atw]c{2}t",
      reverseRegex: "ag{2}[atw]c{2}t",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["KflI", "Sse1825I", "SanDI"],
      site: "gggwccc",
      forwardRegex: "g{3}[atw]c{3}",
      reverseRegex: "g{3}[atw]c{3}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["Sth132I"],
      site: "cccg",
      forwardRegex: "c{3}g",
      reverseRegex: "cg{3}",
      topSnipOffset: 8,
      bottomSnipOffset: 12,
      isType2S: true
    },
    {
      aliases: ["CdpI"],
      site: "gcggag",
      forwardRegex: "gcg{2}ag",
      reverseRegex: "ctc{2}gc",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["Asp90I"],
      site: "acrygt",
      forwardRegex: "ac[agr][cty]gt",
      reverseRegex: "ac[agr][cty]gt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["M.CviPI"],
      site: "gc",
      forwardRegex: "gc",
      reverseRegex: "gc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["MauBI"],
      site: "cgcgcgcg",
      forwardRegex: "cgcgcgcg",
      reverseRegex: "cgcgcgcg",
      topSnipOffset: 2,
      bottomSnipOffset: 6
    },
    {
      aliases: ["CfrAI"],
      site: "gcannnnnnnngtgg",
      forwardRegex: "gca[abcdghkmnrstvwy]{8}gtg{2}",
      reverseRegex: "c{2}ac[abcdghkmnrstvwy]{8}tgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Eco851I"],
      site: "gtcannnnnntgay",
      forwardRegex: "gtca[abcdghkmnrstvwy]{6}tga[cty]",
      reverseRegex: "[agr]tca[abcdghkmnrstvwy]{6}tgac",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BsgI"],
      site: "gtgcag",
      forwardRegex: "gtgcag",
      reverseRegex: "ctgcac",
      topSnipOffset: 22,
      bottomSnipOffset: 20,
      isType2S: true
    },
    {
      aliases: ["AquIV"],
      site: "grggaag",
      forwardRegex: "g[agr]g{2}a{2}g",
      reverseRegex: "ct{2}c{2}[cty]c",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["SciI"],
      site: "ctcgag",
      forwardRegex: "ctcgag",
      reverseRegex: "ctcgag",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["VpaK11AI"],
      site: "ggwcc",
      forwardRegex: "g{2}[atw]c{2}",
      reverseRegex: "g{2}[atw]c{2}",
      topSnipOffset: 0,
      bottomSnipOffset: 5
    },
    {
      aliases: ["CviKI", "CviJI", "CviKI-1"],
      site: "rgcy",
      forwardRegex: "[agr]gc[cty]",
      reverseRegex: "[agr]gc[cty]",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["SnoI", "VneI", "ApaLI", "Alw44I"],
      site: "gtgcac",
      forwardRegex: "gtgcac",
      reverseRegex: "gtgcac",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["BspD6I"],
      site: "gactc",
      forwardRegex: "gactc",
      reverseRegex: "gagtc",
      topSnipOffset: 9,
      bottomSnipOffset: 11,
      isType2S: true
    },
    {
      aliases: ["FatI"],
      site: "catg",
      forwardRegex: "catg",
      reverseRegex: "catg",
      topSnipOffset: 0,
      bottomSnipOffset: 4
    },
    {
      aliases: ["ZraI"],
      site: "gacgtc",
      forwardRegex: "gacgtc",
      reverseRegex: "gacgtc",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["HineI", "HinfIII"],
      site: "cgaat",
      forwardRegex: "cga{2}t",
      reverseRegex: "at{2}cg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaF12I"],
      site: "ctacnnngtc",
      forwardRegex: "ctac[abcdghkmnrstvwy]{3}gtc",
      reverseRegex: "gac[abcdghkmnrstvwy]{3}gtag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Ppu10I"],
      site: "atgcat",
      forwardRegex: "atgcat",
      reverseRegex: "atgcat",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["ApaBI"],
      site: "gcannnnntgc",
      forwardRegex: "gca[abcdghkmnrstvwy]{5}tgc",
      reverseRegex: "gca[abcdghkmnrstvwy]{5}tgc",
      topSnipOffset: 8,
      bottomSnipOffset: 3
    },
    {
      aliases: ["NhaXI"],
      site: "caagrag",
      forwardRegex: "ca{2}g[agr]ag",
      reverseRegex: "ct[cty]ct{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["PabI"],
      site: "gtac",
      forwardRegex: "gtac",
      reverseRegex: "gtac",
      topSnipOffset: 3,
      bottomSnipOffset: 1
    },
    {
      aliases: ["HindI"],
      site: "cac",
      forwardRegex: "cac",
      reverseRegex: "gtg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["M.PhiMx8I"],
      site: "ctssag",
      forwardRegex: "ct[cgs]{2}ag",
      reverseRegex: "ct[cgs]{2}ag",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["RhcI"],
      site: "tcatga",
      forwardRegex: "tcatga",
      reverseRegex: "tcatga",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["KpnI"],
      site: "ggtacc",
      forwardRegex: "g{2}tac{2}",
      reverseRegex: "g{2}tac{2}",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BpuDI", "Bpu10I"],
      site: "cctnagc",
      forwardRegex: "c{2}t[abcdghkmnrstvwy]agc",
      reverseRegex: "gct[abcdghkmnrstvwy]ag{2}",
      topSnipOffset: 2,
      bottomSnipOffset: 5
    },
    {
      aliases: ["EcoP15I"],
      site: "cagcag",
      forwardRegex: "cagcag",
      reverseRegex: "ctgctg",
      topSnipOffset: 31,
      bottomSnipOffset: 33,
      isType2S: true
    },
    {
      aliases: ["Nli3877I"],
      site: "cycgrg",
      forwardRegex: "c[cty]cg[agr]g",
      reverseRegex: "c[cty]cg[agr]g",
      topSnipOffset: 5,
      bottomSnipOffset: 1
    },
    {
      aliases: ["StySEAI"],
      site: "acannnnnntyca",
      forwardRegex: "aca[abcdghkmnrstvwy]{6}t[cty]ca",
      reverseRegex: "tg[agr]a[abcdghkmnrstvwy]{6}tgt",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["M.CviAIV"],
      site: "rgcb",
      forwardRegex: "[agr]gc[bcgksty]",
      reverseRegex: "[acgmrsv]gc[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["Msp16I"],
      site: "tggcca",
      forwardRegex: "tg{2}c{2}a",
      reverseRegex: "tg{2}c{2}a",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["SasI"],
      site: "gaggag",
      forwardRegex: "gag{2}ag",
      reverseRegex: "ctc{2}tc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["AquIII"],
      site: "gaggag",
      forwardRegex: "gag{2}ag",
      reverseRegex: "ctc{2}tc",
      topSnipOffset: 26,
      bottomSnipOffset: 24,
      isType2S: true
    },
    {
      aliases: ["FaiI"],
      site: "yatr",
      forwardRegex: "[cty]at[agr]",
      reverseRegex: "[cty]at[agr]",
      topSnipOffset: 2,
      bottomSnipOffset: 2
    },
    {
      aliases: ["BsbI"],
      site: "caacac",
      forwardRegex: "ca{2}cac",
      reverseRegex: "gtgt{2}g",
      topSnipOffset: 27,
      bottomSnipOffset: 25,
      isType2S: true
    },
    {
      aliases: ["NgoAV"],
      site: "gcannnnnnnntgc",
      forwardRegex: "gca[abcdghkmnrstvwy]{8}tgc",
      reverseRegex: "gca[abcdghkmnrstvwy]{8}tgc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["BstAPI"],
      site: "gcannnnntgc",
      forwardRegex: "gca[abcdghkmnrstvwy]{5}tgc",
      reverseRegex: "gca[abcdghkmnrstvwy]{5}tgc",
      topSnipOffset: 7,
      bottomSnipOffset: 4
    },
    {
      aliases: ["BsmEI"],
      site: "gagtc",
      forwardRegex: "gagtc",
      reverseRegex: "gactc",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NcuII"],
      site: "cccg",
      forwardRegex: "c{3}g",
      reverseRegex: "cg{3}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["CviMI", "CviNI", "CviLI", "CviOI"],
      site: "rgcy",
      forwardRegex: "[agr]gc[cty]",
      reverseRegex: "[agr]gc[cty]",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["StySGI"],
      site: "taannnnnnrtcg",
      forwardRegex: "ta{2}[abcdghkmnrstvwy]{6}[agr]tcg",
      reverseRegex: "cga[cty][abcdghkmnrstvwy]{6}t{2}a",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaF14I"],
      site: "ccannnnntcg",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{5}tcg",
      reverseRegex: "cga[abcdghkmnrstvwy]{5}tg{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["UbaPI"],
      site: "cgaacg",
      forwardRegex: "cga{2}cg",
      reverseRegex: "cgt{2}cg",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["TspDTI"],
      site: "atgaa",
      forwardRegex: "atga{2}",
      reverseRegex: "t{2}cat",
      topSnipOffset: 16,
      bottomSnipOffset: 14,
      isType2S: true
    },
    {
      aliases: ["SspI"],
      site: "aatatt",
      forwardRegex: "a{2}tat{2}",
      reverseRegex: "a{2}tat{2}",
      topSnipOffset: 3,
      bottomSnipOffset: 3
    },
    {
      aliases: ["GdiII"],
      site: "cggccr",
      forwardRegex: "cg{2}c{2}[agr]",
      reverseRegex: "[cty]g{2}c{2}g",
      topSnipOffset: 1,
      bottomSnipOffset: 5
    },
    {
      aliases: ["StySQI"],
      site: "aacnnnnnnrtayg",
      forwardRegex: "a{2}c[abcdghkmnrstvwy]{6}[agr]ta[cty]g",
      reverseRegex: "c[agr]ta[cty][abcdghkmnrstvwy]{6}gt{2}",
      topSnipOffset: 1,
      bottomSnipOffset: 1
    },
    {
      aliases: ["NlaCI"],
      site: "catcac",
      forwardRegex: "catcac",
      reverseRegex: "gtgatg",
      topSnipOffset: 25,
      bottomSnipOffset: 23,
      isType2S: true
    },
    {
      aliases: ["PacI"],
      site: "ttaattaa",
      forwardRegex: "t{2}a{2}t{2}a{2}",
      reverseRegex: "t{2}a{2}t{2}a{2}",
      topSnipOffset: 5,
      bottomSnipOffset: 3
    },
    {
      aliases: ["BarI"],
      isType2S: true,
      site: "gaagnnnnnntac",
      forwardRegex: "ga{2}g[abcdghkmnrstvwy]{6}tac",
      reverseRegex: "gta[abcdghkmnrstvwy]{6}ct{2}c",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20
    },
    {
      aliases: ["CspCI"],
      isType2S: true,
      site: "caannnnngtgg",
      forwardRegex: "ca{2}[abcdghkmnrstvwy]{5}gtg{2}",
      reverseRegex: "c{2}ac[abcdghkmnrstvwy]{5}t{2}g",
      topSnipOffset: 24,
      bottomSnipOffset: 22,
      cutType: 1,
      usForward: 24,
      usReverse: 22
    },
    {
      aliases: ["NmeDI"],
      site: "rccggy",
      forwardRegex: "[agr]c{2}g{2}[cty]",
      reverseRegex: "[agr]c{2}g{2}[cty]",
      topSnipOffset: 13,
      bottomSnipOffset: 18,
      cutType: 1,
      usForward: 13,
      usReverse: 18,
      isType2S: true
    },
    {
      aliases: ["CjePI"],
      site: "ccannnnnnntc",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{7}tc",
      reverseRegex: "ga[abcdghkmnrstvwy]{7}tg{2}",
      topSnipOffset: 26,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 26,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["CjeI"],
      site: "ccannnnnngt",
      forwardRegex: "c{2}a[abcdghkmnrstvwy]{6}gt",
      reverseRegex: "ac[abcdghkmnrstvwy]{6}tg{2}",
      topSnipOffset: 26,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 26,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["PsrI"],
      site: "gaacnnnnnntac",
      forwardRegex: "ga{2}c[abcdghkmnrstvwy]{6}tac",
      reverseRegex: "gta[abcdghkmnrstvwy]{6}gt{2}c",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["ArsI"],
      site: "gacnnnnnnttyg",
      forwardRegex: "gac[abcdghkmnrstvwy]{6}t{2}[cty]g",
      reverseRegex: "c[agr]a{2}[abcdghkmnrstvwy]{6}gtc",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["TstI"],
      site: "cacnnnnnntcc",
      forwardRegex: "cac[abcdghkmnrstvwy]{6}tc{2}",
      reverseRegex: "g{2}a[abcdghkmnrstvwy]{6}gtg",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["Bsp24I"],
      site: "gacnnnnnntgg",
      forwardRegex: "gac[abcdghkmnrstvwy]{6}tg{2}",
      reverseRegex: "c{2}a[abcdghkmnrstvwy]{6}gtc",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["AloI"],
      site: "gaacnnnnnntcc",
      forwardRegex: "ga{2}c[abcdghkmnrstvwy]{6}tc{2}",
      reverseRegex: "g{2}a[abcdghkmnrstvwy]{6}gt{2}c",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["FalI"],
      site: "aagnnnnnctt",
      forwardRegex: "a{2}g[abcdghkmnrstvwy]{5}ct{2}",
      reverseRegex: "a{2}g[abcdghkmnrstvwy]{5}ct{2}",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["AjuI"],
      site: "gaannnnnnnttgg",
      forwardRegex: "ga{2}[abcdghkmnrstvwy]{7}t{2}g{2}",
      reverseRegex: "c{2}a{2}[abcdghkmnrstvwy]{7}t{2}c",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["AlfI"],
      site: "gcannnnnntgc",
      forwardRegex: "gca[abcdghkmnrstvwy]{6}tgc",
      reverseRegex: "gca[abcdghkmnrstvwy]{6}tgc",
      topSnipOffset: 24,
      bottomSnipOffset: 22,
      cutType: 1,
      usForward: 24,
      usReverse: 22,
      isType2S: true
    },
    {
      aliases: ["NgoAVIII"],
      site: "gacnnnnntga",
      forwardRegex: "gac[abcdghkmnrstvwy]{5}tga",
      reverseRegex: "tca[abcdghkmnrstvwy]{5}gtc",
      topSnipOffset: 24,
      bottomSnipOffset: 22,
      cutType: 1,
      usForward: 24,
      usReverse: 22,
      isType2S: true
    },
    {
      aliases: ["HaeIV"],
      site: "gaynnnnnrtc",
      forwardRegex: "ga[cty][abcdghkmnrstvwy]{5}[agr]tc",
      reverseRegex: "ga[cty][abcdghkmnrstvwy]{5}[agr]tc",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["BdaI"],
      site: "tgannnnnntca",
      forwardRegex: "tga[abcdghkmnrstvwy]{6}tca",
      reverseRegex: "tga[abcdghkmnrstvwy]{6}tca",
      topSnipOffset: 24,
      bottomSnipOffset: 22,
      cutType: 1,
      usForward: 24,
      usReverse: 22,
      isType2S: true
    },
    {
      aliases: ["PpiI"],
      site: "gaacnnnnnctc",
      forwardRegex: "ga{2}c[abcdghkmnrstvwy]{5}ctc",
      reverseRegex: "gag[abcdghkmnrstvwy]{5}gt{2}c",
      topSnipOffset: 25,
      bottomSnipOffset: 20,
      cutType: 1,
      usForward: 25,
      usReverse: 20,
      isType2S: true
    },
    {
      aliases: ["BcgI"],
      site: "cgannnnnntgc",
      forwardRegex: "cga[abcdghkmnrstvwy]{6}tgc",
      reverseRegex: "gca[abcdghkmnrstvwy]{6}tcg",
      topSnipOffset: 24,
      bottomSnipOffset: 22,
      cutType: 1,
      usForward: 24,
      usReverse: 22,
      isType2S: true
    },
    {
      aliases: ["BplI"],
      site: "gagnnnnnctc",
      forwardRegex: "gag[abcdghkmnrstvwy]{5}ctc",
      reverseRegex: "gag[abcdghkmnrstvwy]{5}ctc",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["BsaXI"],
      site: "acnnnnnctcc",
      forwardRegex: "ac[abcdghkmnrstvwy]{5}ctc{2}",
      reverseRegex: "g{2}ag[abcdghkmnrstvwy]{5}gt",
      topSnipOffset: 21,
      bottomSnipOffset: 18,
      cutType: 1,
      usForward: 21,
      usReverse: 18,
      isType2S: true
    },
    {
      aliases: ["Hin4I"],
      site: "gaynnnnnvtc",
      forwardRegex: "ga[cty][abcdghkmnrstvwy]{5}[acgmrsv]tc",
      reverseRegex: "ga[bcgksty][abcdghkmnrstvwy]{5}[agr]tc",
      topSnipOffset: 24,
      bottomSnipOffset: 19,
      cutType: 1,
      usForward: 24,
      usReverse: 19,
      isType2S: true
    },
    {
      aliases: ["BaeI"],
      site: "acnnnngtayc",
      forwardRegex: "ac[abcdghkmnrstvwy]{4}gta[cty]c",
      reverseRegex: "g[agr]tac[abcdghkmnrstvwy]{4}gt",
      topSnipOffset: 23,
      bottomSnipOffset: 18,
      cutType: 1,
      usForward: 23,
      usReverse: 18,
      isType2S: true
    },
    {
      aliases: ["SdeOSI"],
      site: "gacnnnnrtga",
      forwardRegex: "gac[abcdghkmnrstvwy]{4}[agr]tga",
      reverseRegex: "tca[cty][abcdghkmnrstvwy]{4}gtc",
      topSnipOffset: 23,
      bottomSnipOffset: 21,
      cutType: 1,
      usForward: 23,
      usReverse: 21,
      isType2S: true
    }
  ];
  const aliasedEnzymesByName = {};
  aliasedEnzymes.forEach((enz) => {
    enz.aliases.forEach((name) => {
      aliasedEnzymesByName[name.toLowerCase()] = __spreadProps(__spreadValues({}, enz), { name });
    });
  });
  function guessIfSequenceIsDnaAndNotProtein(seq, options = {}) {
    const { threshold = 0.9, loose } = options;
    const dnaLetters = options.dnaLetters || loose ? [...ambiguous_dna_letters.split(""), "U"] : ["G", "A", "T", "C", "U"];
    const dnaLetterMap = dnaLetters.reduce((acc, letter) => {
      acc[letter.toUpperCase()] = true;
      return acc;
    }, {});
    let count = 0;
    if (!seq || !seq.length)
      return true;
    for (let index = 0; index < seq.length; index++) {
      const letter = seq[index];
      if (dnaLetterMap[letter.toUpperCase()]) {
        count = count + 1;
      }
    }
    if (count / seq.length > threshold) {
      return true;
    }
    return false;
  }
  __name(guessIfSequenceIsDnaAndNotProtein, "guessIfSequenceIsDnaAndNotProtein");
  function convertAACaretPositionOrRangeToDna(rangeOrCaret) {
    if (typeof rangeOrCaret === "object" && rangeOrCaret !== null) {
      return convertAARangeToDnaRange(__spreadProps(__spreadValues({}, rangeOrCaret), {
        locations: rangeOrCaret.locations ? rangeOrCaret.locations.map(convertAARangeToDnaRange) : void 0
      }));
    } else {
      return convertAACaretPositionToDnaCaretPosition(rangeOrCaret);
    }
  }
  __name(convertAACaretPositionOrRangeToDna, "convertAACaretPositionOrRangeToDna");
  function convertAACaretPositionToDnaCaretPosition(caret) {
    return caret * 3;
  }
  __name(convertAACaretPositionToDnaCaretPosition, "convertAACaretPositionToDnaCaretPosition");
  function convertAARangeToDnaRange(range) {
    return __spreadProps(__spreadValues({}, range), {
      start: range.start > -1 ? range.start * 3 : range.start,
      end: range.end > -1 ? range.end * 3 + 2 : range.end
    });
  }
  __name(convertAARangeToDnaRange, "convertAARangeToDnaRange");
  lodashExports.invert(aminoAcidToDegenerateRnaMap);
  getFeatureTypes();
  getFeatureToColorMap();
  const pragmasAndTypes = [
    {
      //primers don't need a pragma because they already have a feature type of primer_bind
      type: "primers"
    },
    {
      pragma: "Teselagen_Part",
      type: "parts"
    },
    {
      pragma: "j5_warning",
      type: "warnings"
    },
    {
      pragma: "j5_assembly_piece",
      type: "assemblyPieces"
    },
    {
      pragma: "j5_lineage_annotation",
      type: "lineageAnnotations"
    }
  ];
  function unmangleUrls(str) {
    if (!str)
      return str;
    if (typeof str !== "string")
      return str;
    const urlRegex = /%%TG%%_(.*?)_%%TG%%/g;
    return str.replace(urlRegex, function(outer, innerUrl) {
      if (innerUrl) {
        return `${decodeURIComponent(innerUrl)}`;
      }
      return outer;
    });
  }
  __name(unmangleUrls, "unmangleUrls");
  function mangleOrStripUrls(str, { mangleUrls, doNotMangleOrStripUrls } = {}) {
    if (!str)
      return str;
    const urlRegex = /(((https?:\/\/)|(www\.))[^\s]+)/g;
    if (mangleUrls || doNotMangleOrStripUrls) {
      if (doNotMangleOrStripUrls) {
        return str;
      }
      return str.replace(urlRegex, function(url) {
        return `%%TG%%_${encodeURIComponent(url)}_%%TG%%`;
      });
    }
    return str.replace(urlRegex, function() {
      return ``;
    });
  }
  __name(mangleOrStripUrls, "mangleOrStripUrls");
  const reformatName = /* @__PURE__ */ __name(function(pName) {
    return pName.toString().replace(/ /g, "_");
  }, "reformatName");
  function validateSequence(sequence, options = {}) {
    const {
      guessIfProtein,
      guessIfProteinOptions,
      reformatSeqName,
      inclusive1BasedStart,
      inclusive1BasedEnd,
      additionalValidChars,
      allowOverflowAnnotations,
      coerceFeatureTypes
    } = options;
    [
      "isDNA",
      "isOligo",
      "isRNA",
      "isDoubleStrandedDNA",
      "isSingleStrandedDNA",
      "isDoubleStrandedRNA",
      "isProtein"
    ].forEach((k) => {
      if (options[k] !== void 0 && sequence[k] === void 0) {
        sequence[k] = options[k];
      }
    });
    const response = {
      validatedAndCleanedSequence: {},
      messages: []
    };
    if (!sequence || typeof sequence !== "object") {
      throw new Error("Invalid sequence");
    }
    if (!sequence.name) {
      sequence.name = "";
    }
    if (!sequence.extraLines) {
      sequence.extraLines = [];
    }
    if (!sequence.comments) {
      sequence.comments = [];
    }
    if (sequence.description) {
      sequence.description = unmangleUrls(sequence.description);
    }
    const oldName = sequence.name;
    if (reformatSeqName) {
      sequence.name = reformatName(sequence.name);
    }
    if (oldName !== sequence.name) {
      response.messages.push(
        "Name (" + oldName + ") reformatted to " + sequence.name
      );
    }
    if (Array.isArray(sequence.sequence)) {
      sequence.sequence = sequence.sequence.join("");
    }
    if (!sequence.sequence) {
      response.messages.push("No sequence detected");
      sequence.sequence = "";
    }
    if (sequence.isProtein === void 0 && guessIfProtein) {
      sequence.isProtein = !guessIfSequenceIsDnaAndNotProtein(
        sequence.sequence,
        guessIfProteinOptions
      );
    }
    if (sequence.isProtein) {
      const [validChars, warnings] = filterSequenceString(sequence.sequence, {
        name: sequence.name,
        isProtein: true,
        additionalValidChars
      });
      if (validChars !== sequence.sequence) {
        sequence.sequence = validChars;
        response.messages.push(...warnings);
      }
      sequence.type = "PROTEIN";
      sequence.isProtein = true;
      if (!sequence.proteinSequence) {
        sequence.proteinSequence = sequence.sequence;
      }
      sequence.proteinSize = sequence.proteinSequence.length;
    } else {
      const temp = sequence.sequence;
      if (temp !== sequence.sequence && !sequence.isDNA && !sequence.isProtein && sequence.isRNA !== false) {
        sequence.type = "RNA";
        sequence.sequence = temp;
      } else {
        sequence.type = "DNA";
      }
      const [validChars, warnings] = filterSequenceString(sequence.sequence, __spreadValues({
        additionalValidChars
      }, sequence));
      if (validChars !== sequence.sequence) {
        sequence.sequence = validChars;
        response.messages.push(...warnings);
      }
    }
    if (!sequence.size) {
      sequence.size = sequence.isProtein ? sequence.proteinSequence.length * 3 : sequence.sequence.length;
    }
    let circularityExplicitlyDefined;
    if (sequence.circular === false || sequence.circular === "false" || sequence.circular === -1) {
      sequence.circular = false;
      circularityExplicitlyDefined = true;
    } else if (!sequence.circular) {
      sequence.circular = false;
      circularityExplicitlyDefined = circularityExplicitlyDefined || false;
    } else {
      sequence.circular = true;
    }
    if (!sequence.features || !Array.isArray(sequence.features)) {
      response.messages.push("No valid features detected");
      sequence.features = [];
    }
    sequence.features = sequence.features.filter(function(feature) {
      if (!feature || typeof feature !== "object") {
        response.messages.push("Invalid feature detected and removed");
        return false;
      }
      feature.start = parseInt(feature.start, 10);
      feature.end = parseInt(feature.end, 10);
      if (!feature.name || typeof feature.name !== "string") {
        response.messages.push(
          'Unable to detect valid name for feature, setting name to "Untitled Feature"'
        );
        feature.name = "Untitled Feature";
      }
      if (!allowOverflowAnnotations && (!areNonNegativeIntegers([feature.start]) || feature.start > sequence.size - (inclusive1BasedStart ? 0 : 1))) {
        response.messages.push(
          "Invalid feature start: " + feature.start + " detected for " + feature.name + " and set to 1"
        );
        feature.start = 0;
      }
      if (!allowOverflowAnnotations && (!areNonNegativeIntegers([feature.end]) || feature.end > sequence.size - (inclusive1BasedEnd ? 0 : 1))) {
        feature.end = Math.max(sequence.size - 1, inclusive1BasedEnd ? 0 : 1);
        response.messages.push(
          "Invalid feature end:  " + feature.end + " detected for " + feature.name + " and set to " + (feature.end + 1)
        );
      }
      if (feature.start - (inclusive1BasedStart ? 0 : 1) > feature.end - (inclusive1BasedEnd ? 0 : 1) && sequence.circular === false) {
        if (circularityExplicitlyDefined) {
          response.messages.push(
            "Invalid circular feature detected in explicitly linear sequence. " + feature.name + ". start set to 1"
          );
          feature.start = 0;
        } else {
          response.messages.push(
            "Circular feature detected in implicitly linear sequence. Setting sequence to be circular."
          );
          sequence.circular = true;
        }
      }
      feature.strand = parseInt(feature.strand, 10);
      if (feature.strand === -1 || feature.strand === false || feature.strand === "false" || feature.strand === "-") {
        feature.strand = -1;
      } else {
        feature.strand = 1;
      }
      let invalidFeatureType;
      if (feature.type && typeof feature.type === "string" && feature.type.toLowerCase() === "primer") {
        feature.type = "primer_bind";
      }
      if (!feature.type || typeof feature.type !== "string" || !getFeatureTypes({ includeHidden: true }).some(function(featureType) {
        if (featureType.toLowerCase() === feature.type.toLowerCase()) {
          feature.type = featureType;
          return true;
        }
        return false;
      })) {
        if (coerceFeatureTypes || !feature.type) {
          response.messages.push(
            'Invalid feature type detected:  "' + feature.type + '" within ' + feature.name + ". set type to misc_feature"
          );
          if (typeof feature.type === "string") {
            invalidFeatureType = feature.type;
          }
          feature.type = "misc_feature";
        }
      }
      if (!feature.notes) {
        feature.notes = {};
      }
      if (invalidFeatureType) {
        if (!feature.notes.featureType) {
          feature.notes.featureType = [];
        }
        feature.notes.featureType.push(invalidFeatureType);
      }
      if (feature.notes.label) {
        delete feature.notes.label;
      } else if (feature.notes.gene) {
        delete feature.notes.gene;
      } else if (feature.notes.name) {
        delete feature.notes.name;
      }
      if (feature.notes.color) {
        feature.color = feature.notes.color[0] || feature.color;
        delete feature.notes.color;
      }
      if (feature.notes.labelColor) {
        feature.labelColor = feature.notes.labelColor[0] || feature.labelColor;
        delete feature.notes.labelColor;
      }
      if (feature.notes.pragma && lodashExports.some(feature.notes.pragma, (p) => p === "overlapsSelf")) {
        feature.overlapsSelf = true;
        feature.notes.pragma = lodashExports.filter(
          feature.notes.pragma,
          (p) => p !== "overlapsSelf"
        );
      }
      feature.notes.note && lodashExports.some(feature.notes.note, (n) => {
        if (n && typeof n === "string" && n.toLowerCase().includes("sequence:")) {
          feature.notes.note = lodashExports.filter(
            feature.notes.note,
            (p) => p && !p.toLowerCase().includes("sequence:")
          );
          if (feature.notes.note.length === 0) {
            delete feature.notes.note;
          }
          const match = n.match(/sequence:[ \r\n.]*[a-zA-Z]*/i);
          if (match && match[0])
            feature.bases = match[0].replace(/\s/g, "").replace("sequence:", "");
          return true;
        }
      });
      feature.notes.primerBindsOn && lodashExports.some(feature.notes.primerBindsOn, (n) => {
        if (n) {
          feature.primerBindsOn = n;
          delete feature.notes.primerBindsOn;
        }
      });
      for (const { pragma, type } of pragmasAndTypes) {
        if (options[`accept${lodashExports.upperFirst(type)}`] !== false && //acceptParts, acceptWarnings,
        feature.notes.pragma && lodashExports.some(feature.notes.pragma, (p) => p === pragma)) {
          if (!sequence[type]) {
            sequence[type] = [];
          }
          feature.type = type.slice(0, -1);
          delete feature.notes.pragma;
          sequence[type].push(feature);
          return false;
        }
      }
      lodashExports.forEach(feature.notes, (noteArray, key) => {
        feature.notes[key] = lodashExports.map(noteArray, (note) => {
          return unmangleUrls(note);
        });
      });
      return true;
    });
    response.validatedAndCleanedSequence = sequence;
    return response;
  }
  __name(validateSequence, "validateSequence");
  function validateSequenceArray(parsingResultArray, options) {
    if (parsingResultArray) {
      if (!Array.isArray(parsingResultArray)) {
        parsingResultArray = [parsingResultArray];
      }
      parsingResultArray.forEach(function(parsingResult) {
        if (parsingResult.success) {
          const res = validateSequence(parsingResult.parsedSequence, options);
          parsingResult.messages = parsingResult.messages.concat(res.messages);
          parsingResult.parsedSequence = res.validatedAndCleanedSequence;
        }
      });
    }
    return parsingResultArray;
  }
  __name(validateSequenceArray, "validateSequenceArray");
  function fastaToJson(fileString, options = {}) {
    const ext = extractFileExtension(options.fileName);
    if (/^(faa)$/.test(ext)) {
      options.isProtein = true;
    }
    let resultArray = [];
    let result = null;
    try {
      const lines = splitStringIntoLines(fileString);
      for (let i = 0; i < lines.length; i++) {
        parseLine(lines[i]);
      }
      if (result) {
        resultArray.push(result);
        result = null;
      }
    } catch (e) {
      console.error("error:", e);
      console.error("error.stack: ", e.stack);
      resultArray = [
        {
          success: false,
          messages: ["Import Error: Invalid File"]
        }
      ];
    }
    return validateSequenceArray(resultArray, options);
    function parseLine(line) {
      line = line.trim();
      if (";" === line[0]) {
        if (result) {
          return;
        }
        result = createInitialSequence(options);
        parseTitle(line);
      } else if (">" === line[0]) {
        if (result) {
          resultArray.push(result);
          result = null;
        }
        result = createInitialSequence(options);
        parseTitle(line);
      } else {
        if (!result) {
          result = createInitialSequence(options);
        }
        if ("*" === line[line.length - 1]) {
          parseSequenceLine(line.substring(0, line.length - 1));
          resultArray.push(result);
          result = null;
        } else {
          parseSequenceLine(line);
        }
      }
      if (options && options.parseFastaAsCircular) {
        result.parsedSequence.circular = true;
      }
    }
    function parseTitle(line) {
      if (options && "parseName" in options && !options.parseName) {
        result.parsedSequence.name = line.slice(1);
        return;
      }
      const pipeIndex = line.indexOf("|");
      if (pipeIndex > -1) {
        result.parsedSequence.name = line.slice(1, pipeIndex);
        result.parsedSequence.description = line.slice(pipeIndex + 1);
      } else {
        result.parsedSequence.name = line.slice(1);
      }
    }
    function parseSequenceLine(line) {
      result.parsedSequence.sequence += line;
    }
  }
  __name(fastaToJson, "fastaToJson");
  function convertOldSequenceDataToNewDataType(oldTeselagenJson, opts) {
    if (opts && opts.splitLocations) {
      oldTeselagenJson && oldTeselagenJson.features.forEach(function(feature) {
        if (feature.locations && feature.locations[0]) {
          if (feature.locations.length > 1) {
            for (let i = 1; i < feature.locations.length; i++) {
              const location = feature.locations[i];
              const clonedFeature = JSON.parse(JSON.stringify(feature));
              clonedFeature.start = location.start;
              clonedFeature.end = location.end;
              delete clonedFeature.locations;
              oldTeselagenJson.features.push(clonedFeature);
            }
          }
          feature.start = feature.locations[0].start;
          feature.end = feature.locations[0].end;
        }
        delete feature.locations;
      });
    } else {
      oldTeselagenJson && oldTeselagenJson.features.forEach(function(feature) {
        if (feature.locations && feature.locations[0]) {
          feature.start = feature.locations[0].start;
          feature.end = feature.locations[feature.locations.length - 1].end;
          if (feature.locations.length > 1) {
            const locationError = feature.locations.some((location) => {
              return !isRangeWithinRange(
                location,
                feature,
                oldTeselagenJson.sequence.length
              );
            });
            if (locationError) {
              delete feature.locations;
            }
          } else {
            delete feature.locations;
          }
        }
      });
    }
    if (Array.isArray(oldTeselagenJson.sequence)) {
      oldTeselagenJson.sequence = oldTeselagenJson.sequence.join("");
    }
  }
  __name(convertOldSequenceDataToNewDataType, "convertOldSequenceDataToNewDataType");
  function flattenSequenceArray(parsingResultArray, opts) {
    if (parsingResultArray) {
      if (!Array.isArray(parsingResultArray)) {
        parsingResultArray = [parsingResultArray];
      }
      parsingResultArray.forEach(function(parsingResult) {
        if (parsingResult.success) {
          convertOldSequenceDataToNewDataType(parsingResult.parsedSequence, opts);
        }
      });
    }
    return parsingResultArray;
  }
  __name(flattenSequenceArray, "flattenSequenceArray");
  function parseFeatureLocation(locStr, isProtein, inclusive1BasedStart, inclusive1BasedEnd, isCircular, sequenceLength) {
    locStr = locStr.trim();
    const locArr = [];
    locStr.replace(/(\d+)/g, function(string, match) {
      locArr.push(match);
    });
    const locArray = [];
    for (let i = 0; i < locArr.length; i += 2) {
      const start = parseInt(locArr[i], 10) - (inclusive1BasedStart ? 0 : 1);
      let end = parseInt(locArr[i + 1], 10) - (inclusive1BasedEnd ? 0 : 1);
      if (isNaN(end)) {
        end = start;
      }
      const location = {
        start,
        end
      };
      locArray.push(
        isProtein ? convertAACaretPositionOrRangeToDna(location) : location
      );
    }
    if (isCircular) {
      for (let i = 0; i < locArray.length; i += 2) {
        const firstFeature = locArray[i];
        const secondFeature = locArray[i + 1];
        if (firstFeature.end === sequenceLength - (inclusive1BasedEnd ? 0 : 1) && secondFeature.start === 1 - (inclusive1BasedStart ? 0 : 1)) {
          locArray[i] = {
            start: firstFeature.start,
            end: secondFeature.end
          };
          locArray.splice(i + 1, 1);
        }
      }
    }
    return locArray;
  }
  __name(parseFeatureLocation, "parseFeatureLocation");
  function genbankToJson(string, options = {}) {
    const {
      inclusive1BasedStart,
      inclusive1BasedEnd
      //these are also valid options:
      // primersAsFeatures,
      // sequenceTypeFromLocus,
      // isProtein,
    } = options;
    const resultsArray = [];
    let result;
    let currentFeatureNote;
    const genbankAnnotationKey = {
      LOCUS_TAG: "LOCUS",
      DEFINITION_TAG: "DEFINITION",
      ACCESSION_TAG: "ACCESSION",
      VERSION_TAG: "VERSION",
      KEYWORDS_TAG: "KEYWORDS",
      //SEGMENT_TAG:"SEGMENT"
      SOURCE_TAG: "SOURCE",
      ORGANISM_TAG: "ORGANISM",
      REFERENCE_TAG: "REFERENCE",
      AUTHORS_TAG: "AUTHORS",
      CONSORTIUM_TAG: "CONSRTM",
      TITLE_TAG: "TITLE",
      JOURNAL_TAG: "JOURNAL",
      PUBMED_TAG: "PUBMED",
      REMARK_TAG: "REMARK",
      COMMENT_TAG: "COMMENT",
      FEATURES_TAG: "FEATURES",
      BASE_COUNT_TAG: "BASE COUNT",
      //CONTIG_TAG: "CONTIG"
      ORIGIN_TAG: "ORIGIN",
      END_SEQUENCE_TAG: "//"
    };
    let hasFoundLocus = false;
    let featureLocationIndentation;
    try {
      const lines = splitStringIntoLines(string);
      let LINETYPE = false;
      if (lines === null) {
        addMessage("Import Error: Sequence file is empty");
      }
      lines.some(function(line) {
        if (line === null) {
          return true;
        }
        const key = getLineKey(line);
        const val2 = getLineVal(line);
        const isKeyRunon = isKeywordRunon(line);
        const isSubKey = isSubKeyword(line);
        const isKey = isKeyword(line);
        if (!isKeyRunon) {
          if (key === "LOCUS") {
            LINETYPE = key;
          } else if (key === "REFERENCE") {
            LINETYPE = key;
          } else if (key === "FEATURES") {
            LINETYPE = key;
          } else if (key === "ORIGIN") {
            LINETYPE = key;
          } else if (key === "//") {
            LINETYPE = key;
          } else if (isKey === true) {
            LINETYPE = key;
          }
        }
        if (line.trim() === "" || key === ";") {
          return false;
        }
        if (!hasFoundLocus && LINETYPE !== genbankAnnotationKey.LOCUS_TAG) {
          return true;
        }
        switch (LINETYPE) {
          case genbankAnnotationKey.LOCUS_TAG:
            if (hasFoundLocus) {
              line = hasFoundLocus + line;
            }
            parseLocus(line);
            hasFoundLocus = line;
            break;
          case genbankAnnotationKey.FEATURES_TAG:
            if (val2 === "") {
              addMessage(
                "Warning: The feature '" + key + "'' has no location specified. This line has been ignored: line" + line
              );
              break;
            }
            parseFeatures(line, key, val2);
            break;
          case genbankAnnotationKey.ORIGIN_TAG:
            parseOrigin(line, key);
            break;
          case genbankAnnotationKey.END_SEQUENCE_TAG:
            endSeq();
            break;
          case genbankAnnotationKey.DEFINITION_TAG:
            line = line.replace(/DEFINITION/, "");
            line = line.trim();
            if (result.parsedSequence) {
              if (result.parsedSequence.definition) {
                result.parsedSequence.definition += " " + line;
              } else {
                result.parsedSequence.definition = line;
              }
              if (result.parsedSequence.description) {
                result.parsedSequence.description += " " + line;
              } else {
                result.parsedSequence.description = line;
              }
            } else {
              throw new Error(
                "no sequence yet created upon which to extract an extra line!"
              );
            }
            break;
          case genbankAnnotationKey.ACCESSION_TAG:
            line = line.replace(/ACCESSION/, "");
            line = line.trim();
            if (result.parsedSequence) {
              result.parsedSequence.accession = line;
            }
            break;
          case genbankAnnotationKey.VERSION_TAG:
            line = line.replace(/VERSION/, "");
            line = line.trim();
            if (result.parsedSequence) {
              result.parsedSequence.version = line;
            }
            break;
          case "COMMENT":
            line = line.replace(/COMMENT/, "");
            line = line.trim();
            if (result.parsedSequence) {
              if (!result.parsedSequence.comments) {
                result.parsedSequence.comments = [];
              }
              if (line.indexOf("teselagen_unique_id:") > -1) {
                result.parsedSequence.teselagen_unique_id = line.replace(/ /g, "").replace("teselagen_unique_id:", "");
              } else if (line.indexOf("library:") > -1) {
                result.parsedSequence.library = line.replace(/ /g, "").replace("library:", "");
              } else {
                result.parsedSequence.comments.push(line);
              }
            } else {
              throw new Error(
                "no sequence yet created upon which to extract an extra line!"
              );
            }
            break;
          default:
            extractExtraLine(line);
            if (key === "BASE") {
              addMessage(
                "Warning: This BaseCount line has been ignored: " + line
              );
              break;
            } else if (isKey) {
            } else if (isSubKey) {
            } else if (isKeyRunon) {
            } else {
              addMessage("Warning: This line has been ignored: " + line);
            }
        }
        return false;
      });
    } catch (e) {
      console.error("Error trying to parse file as .gb:", e);
      result = {
        success: false,
        messages: ["Import Error: Invalid File"]
      };
    }
    if (!result || result.success && resultsArray[resultsArray.length - 1] !== result) {
      endSeq();
    }
    const results = validateSequenceArray(
      flattenSequenceArray(resultsArray, options),
      options
    );
    results.forEach((result2) => {
      if (result2.success) {
        const sequence = result2.parsedSequence;
        sequence.features.forEach((feat) => {
          if (feat.type === "primer") {
            feat.type = "primer_bind";
          }
        });
        if (!options.primersAsFeatures) {
          sequence.primers = sequence.features.filter(
            (feat) => feat.type === "primer_bind"
          );
          sequence.features = sequence.features.filter(
            (feat) => feat.type !== "primer_bind"
          );
        }
      }
    });
    return results;
    function endSeq() {
      hasFoundLocus = false;
      postProcessCurSeq();
      resultsArray.push(result || { success: false });
    }
    function getCurrentFeature() {
      return result.parsedSequence.features[result.parsedSequence.features.length - 1];
    }
    function addMessage(msg) {
      if (result.messages.indexOf(msg === -1)) {
        return result.messages.push(msg);
      }
    }
    function postProcessCurSeq() {
      if (result && result.parsedSequence && result.parsedSequence.features) {
        for (let i = 0; i < result.parsedSequence.features.length; i++) {
          result.parsedSequence.features[i] = postProcessGenbankFeature(
            result.parsedSequence.features[i]
          );
        }
      }
    }
    function parseOrigin(line, key) {
      if (key !== genbankAnnotationKey.ORIGIN_TAG) {
        const new_line = line.replace(/[\s]*[0-9]*/g, "");
        result.parsedSequence.sequence += new_line;
      }
    }
    function parseLocus(line) {
      result = createInitialSequence(options);
      let circular;
      let gbDivision;
      let date;
      const lineArr = line.split(/[\s]+/g);
      if (lineArr.length <= 1) {
        console.warn(
          "Parsing GenBank File: WARNING! Locus line contains no values!"
        );
        addMessage("Import Warning: Locus line contains no values: " + line);
      }
      const locusName = lineArr[1];
      for (let i = 1; i < lineArr.length; i++) {
        if (lineArr[i].match(/circular/gi)) {
          circular = true;
        } else if (lineArr[i].match(/linear/gi)) {
          circular = false;
        }
      }
      for (let j = 1; j < lineArr.length; j++) {
        const item = lineArr[j];
        if (item.match(/-[A-Z]{3}-/g)) {
          date = item;
        }
        if (j === 3 && item.match(/aa/i)) {
          options.sequenceTypeFromLocus = item;
          options.isProtein = true;
        }
        if (j === 4 && (item.match(/ds-dna/i) || item.match(/ss-dna/i) || item.match(/dna/i) || item.match(/rna/i))) {
          if (options.isProtein === void 0) {
            options.isProtein = false;
          }
          options.sequenceTypeFromLocus = item;
          if (item.match(/ss-dna/i)) {
            options.isDNA = true;
            options.isSingleStrandedDNA = true;
          } else if (item.match(/rna/i)) {
            options.isRna = true;
          } else if (item.match(/ds-dna/i) || item.match(/dna/i)) {
            options.isDNA = true;
            options.isDoubleStrandedDNA = true;
          }
          if (item.match(/rna/i) && !item.match(/ss-rna/i)) {
            options.isDoubleStrandedRNA = true;
          }
        }
        if (typeof lineArr[j] === "string" && gbDivisions[lineArr[j].toUpperCase()]) {
          gbDivision = lineArr[j].toUpperCase();
        }
      }
      if (locusName !== "Exported" || result.parsedSequence.name === untitledSequenceName) {
        result.parsedSequence.name = locusName;
      }
      result.parsedSequence.gbDivision = gbDivision;
      result.parsedSequence.sequenceTypeFromLocus = options.sequenceTypeFromLocus;
      result.parsedSequence.isDNA = options.isDNA;
      result.parsedSequence.isDoubleStrandedDNA = options.isDoubleStrandedDNA;
      result.parsedSequence.isSingleStrandedDNA = options.isSingleStrandedDNA;
      result.parsedSequence.isRna = options.isRna;
      result.parsedSequence.isDoubleStrandedRNA = options.isDoubleStrandedRNA;
      result.parsedSequence.date = date;
      result.parsedSequence.circular = circular;
    }
    function extractExtraLine(line) {
      if (result.parsedSequence) {
        if (!result.parsedSequence.extraLines) {
          result.parsedSequence.extraLines = [];
        }
        result.parsedSequence.extraLines.push(line);
      } else {
        throw new Error(
          "no sequence yet created upon which to extract an extra line!"
        );
      }
    }
    var lastLineWasFeaturesTag;
    var lastLineWasLocation;
    function parseFeatures(line, key, val2) {
      let strand;
      if (key === genbankAnnotationKey.FEATURES_TAG) {
        lastLineWasFeaturesTag = true;
        return;
      }
      if (lastLineWasFeaturesTag) {
        featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
        lastLineWasFeaturesTag = false;
      }
      if (isFeatureLineRunon(line, featureLocationIndentation)) {
        if (lastLineWasLocation) {
          const feat = getCurrentFeature();
          feat.locations = feat.locations.concat(
            parseFeatureLocation(
              line.trim(),
              options.isProtein,
              inclusive1BasedStart,
              inclusive1BasedEnd,
              result.parsedSequence.circular,
              result.parsedSequence.sequence.length
            )
          );
          lastLineWasLocation = true;
        } else {
          if (currentFeatureNote) {
            currentFeatureNote[currentFeatureNote.length - 1] += line.trimLeft().replace(/"/g, "");
          }
          lastLineWasLocation = false;
        }
      } else {
        if (isNote(line)) {
          if (getCurrentFeature()) {
            parseFeatureNote(line);
            lastLineWasLocation = false;
          } else {
            return;
          }
        } else {
          if (val2.match(/complement/g)) {
            strand = -1;
          } else {
            strand = 1;
          }
          newFeature();
          const feat = getCurrentFeature();
          feat.type = key;
          feat.strand = strand;
          feat.locations = feat.locations.concat(
            parseFeatureLocation(
              val2,
              options.isProtein,
              inclusive1BasedStart,
              inclusive1BasedEnd,
              result.parsedSequence.circular,
              result.parsedSequence.sequence.length
            )
          );
          lastLineWasLocation = true;
        }
      }
    }
    function newFeature() {
      result.parsedSequence.features.push({
        locations: [],
        notes: {}
      });
    }
    function isNote(line) {
      let qual = false;
      if (line.trim().charAt(0).match(/\//)) {
        qual = true;
      } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
        qual = true;
      }
      return qual;
    }
    function parseFeatureNote(line) {
      let newLine;
      newLine = line.trimLeft();
      newLine = newLine.replace(/^\/|"$/g, "");
      const lineArr = newLine.split(/="|=/);
      let val2 = lineArr.slice(1).join("=");
      if (val2) {
        val2 = val2.replace(/\\/g, " ");
        if (line.match(/="/g)) {
          val2 = val2.replace(/".*/g, "");
        } else if (val2.match(/^\d+$/g)) {
          val2 = parseInt(val2, 10);
        }
      }
      const key = lineArr[0];
      const currentNotes = getCurrentFeature().notes;
      if (currentNotes[key]) {
        currentNotes[key].push(val2);
      } else {
        currentNotes[key] = [val2];
      }
      currentFeatureNote = currentNotes[key];
    }
    function getLineKey(line) {
      let arr;
      line = line.replace(/^[\s]*/, "");
      if (line.indexOf("=") < 0) {
        arr = line.split(/[\s]+/);
      } else {
        arr = line.split(/=/);
      }
      return arr[0];
    }
    function getLineVal(line) {
      let arr;
      if (line.indexOf("=") < 0) {
        line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, "");
        line = line.trim();
        return line;
      } else {
        arr = line.split(/=/);
        return arr.slice(1).join("");
      }
    }
    function isKeyword(line) {
      let isKey = false;
      if (line.substr(0, 10).match(/^[\S]+/)) {
        isKey = true;
      }
      return isKey;
    }
    function isSubKeyword(line) {
      let isSubKey = false;
      if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
        isSubKey = true;
      }
      return isSubKey;
    }
    function isKeywordRunon(line) {
      let runon;
      if (line.substr(0, 10).match(/[\s]{10}/)) {
        runon = true;
      } else {
        runon = false;
      }
      return runon;
    }
    function postProcessGenbankFeature(feat) {
      if (feat.notes.label) {
        feat.name = feat.notes.label[0];
      } else if (feat.notes.gene) {
        feat.name = feat.notes.gene[0];
      } else if (feat.notes.ApEinfo_label) {
        feat.name = feat.notes.ApEinfo_label[0];
      } else if (feat.notes.name) {
        feat.name = feat.notes.name[0];
      } else if (feat.notes.organism) {
        feat.name = feat.notes.organism[0];
      } else if (feat.notes.locus_tag) {
        feat.name = feat.notes.locus_tag[0];
      } else if (feat.notes.note) {
        feat.name = feat.notes.note[0].substr(0, 100);
      } else {
        feat.name = "Untitled Feature";
      }
      feat.name = typeof feat.name === "string" ? feat.name : String(feat.name);
      if (feat.name !== 0 && !feat.name) {
        feat.name = "Untitled Feature";
      }
      if (feat.name.length > 100) {
        const oldName = feat.name;
        feat.name = feat.name.substr(0, 100);
        addMessage(
          `Warning: Shortening name of feature ${oldName} (max 100 chars)`
        );
      }
      if (feat.notes.direction) {
        feat.arrowheadType = feat.notes.direction[0].toUpperCase() === "BOTH" ? "BOTH" : feat.notes.direction[0].toUpperCase() === "NONE" ? "NONE" : void 0;
        delete feat.notes.direction;
      }
      return feat;
    }
  }
  __name(genbankToJson, "genbankToJson");
  function isFeatureLineRunon(line, featureLocationIndentation) {
    const indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
    if (featureLocationIndentation === indentationOfLine) {
      return false;
    }
    const trimmed = line.trim();
    if (trimmed.charAt(0).match(/\//)) {
      return false;
    }
    return true;
  }
  __name(isFeatureLineRunon, "isFeatureLineRunon");
  function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
    const match = /^\s*/.exec(string);
    if (match !== null) {
      return match[0].length;
    } else {
      return 0;
    }
  }
  __name(getLengthOfWhiteSpaceBeforeStartOfLetters, "getLengthOfWhiteSpaceBeforeStartOfLetters");
  const _Match = class _Match {
    constructor(props) {
      Object.assign(this, props);
      this.value = this.obj[this.prop];
    }
    toString() {
      const { path, type } = this;
      return `${path} -> (${type}) ${this.logValue()}`;
    }
    logValue() {
      const val2 = this.value;
      const isPrimitive = /* @__PURE__ */ __name((x) => Object(x) !== x, "isPrimitive");
      return isPrimitive(val2) || Array.isArray(val2) ? val2 : {}.toString.call(val2);
    }
    log() {
      console.info(this.toString());
    }
  };
  __name(_Match, "Match");
  let Match = _Match;
  const GLOBAL = typeof window == "object" ? window : global;
  function searchWholeObjByName(what, where) {
    const searchBy = /* @__PURE__ */ __name((what2, where2, prop) => what2 == prop, "searchBy");
    let data;
    let alreadySeen;
    const path = where == GLOBAL ? "GLOBAL" : "SRC";
    const queue = [{ where, path }];
    const seen = [];
    const matches = [];
    matches.log = function() {
      this.forEach((m) => m.log());
    };
    while (data = queue.pop()) {
      const { where: where2, path: path2 } = data;
      for (const prop in where2) {
        try {
          if (where2.hasOwnProperty(prop)) {
            if ([where2[prop]] == "[object Object]") {
              for (let i = -1; seen[++i] && !(alreadySeen = lodashExports.isEqual(seen[i].where, where2[prop]) && seen[i]); )
                ;
              if (!alreadySeen) {
                data = { where: where2[prop], path: `${path2}.${prop}` };
                queue.push(data);
                seen.push(data);
              }
            }
            if (searchBy(what, where2, prop)) {
              const type = alreadySeen ? `<${alreadySeen.path}>` : typeof where2[prop];
              const match = new Match({
                path: `${path2}.${prop}`,
                obj: where2,
                prop,
                type
              });
              matches.push(match);
            }
          }
        } catch (e) {
        }
      }
    }
    return matches;
  }
  __name(searchWholeObjByName, "searchWholeObjByName");
  function searchWholeObjByNameSimple(what, where) {
    var _a3, _b3, _c;
    return (_c = (_b3 = (_a3 = searchWholeObjByName(what, where)) == null ? void 0 : _a3[0]) == null ? void 0 : _b3.value) == null ? void 0 : _c[0];
  }
  __name(searchWholeObjByNameSimple, "searchWholeObjByNameSimple");
  function searchWholeObjByNameSimpleArray(what, where) {
    var _a3, _b3;
    return (_b3 = (_a3 = searchWholeObjByName(what, where)) == null ? void 0 : _a3[0]) == null ? void 0 : _b3.value;
  }
  __name(searchWholeObjByNameSimpleArray, "searchWholeObjByNameSimpleArray");
  var validator$2 = {};
  var util$4 = {};
  (function(exports) {
    const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    const nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    const regexName = new RegExp("^" + nameRegexp + "$");
    const getAllMatches = /* @__PURE__ */ __name(function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    }, "getAllMatches");
    const isName = /* @__PURE__ */ __name(function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    }, "isName");
    exports.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a, arrayMode) {
      if (a) {
        const keys = Object.keys(a);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a[keys[i]]];
          } else {
            target[keys[i]] = a[keys[i]];
          }
        }
      }
    };
    exports.getValue = function(v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  })(util$4);
  const util$3 = util$4;
  const defaultOptions$2 = {
    allowBooleanAttributes: false,
    //A tag can have attributes without any value
    unpairedTags: []
  };
  validator$2.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions$2, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i = 0; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
        i += 2;
        i = readPI(xmlData, i);
        if (i.err)
          return i;
      } else if (xmlData[i] === "<") {
        let tagStartPos = i;
        i++;
        if (xmlData[i] === "!") {
          i = readCommentAndCDATA(xmlData, i);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i] === "/") {
            closingTag = true;
            i++;
          }
          let tagName = "";
          for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
            tagName += xmlData[i];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
          }
          const result = readAttributeStr(xmlData, i);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
          }
          let attrStr = result.value;
          i = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid2 = validateAttributeString(attrStr, options);
            if (isValid2 === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject(
                  "InvalidTag",
                  "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                  getLineNumberForPosition(xmlData, tagStartPos)
                );
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid2 = validateAttributeString(attrStr, options);
            if (isValid2 !== true) {
              return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid2.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
            } else if (options.unpairedTags.indexOf(tagName) !== -1)
              ;
            else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i++; i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              if (xmlData[i + 1] === "!") {
                i++;
                i = readCommentAndCDATA(xmlData, i);
                continue;
              } else if (xmlData[i + 1] === "?") {
                i = readPI(xmlData, ++i);
                if (i.err)
                  return i;
              } else {
                break;
              }
            } else if (xmlData[i] === "&") {
              const afterAmp = validateAmpersand(xmlData, i);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
              i = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
              }
            }
          }
          if (xmlData[i] === "<") {
            i--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  function isWhiteSpace(char) {
    return char === " " || char === "	" || char === "\n" || char === "\r";
  }
  __name(isWhiteSpace, "isWhiteSpace");
  function readPI(xmlData, i) {
    const start = i;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] == "?" || xmlData[i] == " ") {
        const tagname = xmlData.substr(start, i - start);
        if (i > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
        } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
          i++;
          break;
        } else {
          continue;
        }
      }
    }
    return i;
  }
  __name(readPI, "readPI");
  function readCommentAndCDATA(xmlData, i) {
    if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
      for (i += 3; i < xmlData.length; i++) {
        if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
      let angleBracketsCount = 1;
      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    }
    return i;
  }
  __name(readCommentAndCDATA, "readCommentAndCDATA");
  const doubleQuote = '"';
  const singleQuote = "'";
  function readAttributeStr(xmlData, i) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i];
        } else if (startChar !== xmlData[i])
          ;
        else {
          startChar = "";
        }
      } else if (xmlData[i] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i,
      tagClosed
    };
  }
  __name(readAttributeStr, "readAttributeStr");
  const validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  function validateAttributeString(attrStr, options) {
    const matches = util$3.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i = 0; i < matches.length; i++) {
      if (matches[i][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
      }
      const attrName = matches[i][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
      }
    }
    return true;
  }
  __name(validateAttributeString, "validateAttributeString");
  function validateNumberAmpersand(xmlData, i) {
    let re = /\d/;
    if (xmlData[i] === "x") {
      i++;
      re = /[\da-fA-F]/;
    }
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === ";")
        return i;
      if (!xmlData[i].match(re))
        break;
    }
    return -1;
  }
  __name(validateNumberAmpersand, "validateNumberAmpersand");
  function validateAmpersand(xmlData, i) {
    i++;
    if (xmlData[i] === ";")
      return -1;
    if (xmlData[i] === "#") {
      i++;
      return validateNumberAmpersand(xmlData, i);
    }
    let count = 0;
    for (; i < xmlData.length; i++, count++) {
      if (xmlData[i].match(/\w/) && count < 20)
        continue;
      if (xmlData[i] === ";")
        break;
      return -1;
    }
    return i;
  }
  __name(validateAmpersand, "validateAmpersand");
  function getErrorObject(code2, message, lineNumber) {
    return {
      err: {
        code: code2,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  __name(getErrorObject, "getErrorObject");
  function validateAttrName(attrName) {
    return util$3.isName(attrName);
  }
  __name(validateAttrName, "validateAttrName");
  function validateTagName(tagname) {
    return util$3.isName(tagname);
  }
  __name(validateTagName, "validateTagName");
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      // column number is last line's length + 1, because column numbering starts at 1:
      col: lines[lines.length - 1].length + 1
    };
  }
  __name(getLineNumberForPosition, "getLineNumberForPosition");
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
  __name(getPositionFromMatch, "getPositionFromMatch");
  var OptionsBuilder = {};
  const defaultOptions$1 = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false,
    //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val2) {
      return val2;
    },
    attributeValueProcessor: function(attrName, val2) {
      return val2;
    },
    stopNodes: [],
    //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
    // skipEmptyListItem: false
  };
  const buildOptions$1 = /* @__PURE__ */ __name(function(options) {
    return Object.assign({}, defaultOptions$1, options);
  }, "buildOptions$1");
  OptionsBuilder.buildOptions = buildOptions$1;
  OptionsBuilder.defaultOptions = defaultOptions$1;
  const _XmlNode = class _XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val2) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val2 });
    }
    addChild(node) {
      if (node.tagname === "__proto__")
        node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
      } else {
        this.child.push({ [node.tagname]: node.child });
      }
    }
  };
  __name(_XmlNode, "XmlNode");
  let XmlNode = _XmlNode;
  var xmlNode$1 = XmlNode;
  const util$2 = util$4;
  function readDocType$1(xmlData, i) {
    const entities = {};
    if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
      i = i + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i)) {
            i += 7;
            [entityName, val, i] = readEntityExp(xmlData, i + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i))
            i += 8;
          else if (hasBody && isAttlist(xmlData, i))
            i += 8;
          else if (hasBody && isNotation(xmlData, i))
            i += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i] === ">") {
          if (comment) {
            if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i };
  }
  __name(readDocType$1, "readDocType$1");
  function readEntityExp(xmlData, i) {
    let entityName2 = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
      entityName2 += xmlData[i];
    }
    entityName2 = entityName2.trim();
    if (entityName2.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i++];
    let val2 = "";
    for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
      val2 += xmlData[i];
    }
    return [entityName2, val2, i];
  }
  __name(readEntityExp, "readEntityExp");
  function isComment(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")
      return true;
    return false;
  }
  __name(isComment, "isComment");
  function isEntity(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
      return true;
    return false;
  }
  __name(isEntity, "isEntity");
  function isElement(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
      return true;
    return false;
  }
  __name(isElement, "isElement");
  function isAttlist(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
      return true;
    return false;
  }
  __name(isAttlist, "isAttlist");
  function isNotation(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
      return true;
    return false;
  }
  __name(isNotation, "isNotation");
  function validateEntityName(name) {
    if (util$2.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  __name(validateEntityName, "validateEntityName");
  var DocTypeReader = readDocType$1;
  const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  const consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
    //skipLike: /regex/
  };
  function toNumber$1(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
      return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  __name(toNumber$1, "toNumber$1");
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  __name(trimZeros, "trimZeros");
  var strnum = toNumber$1;
  const util$1 = util$4;
  const xmlNode = xmlNode$1;
  const readDocType = DocTypeReader;
  const toNumber = strnum;
  "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util$1.nameRegexp);
  let OrderedObjParser$1 = (_a = class {
    constructor(options) {
      this.options = options;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
        "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
        "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
        "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        "space": { regex: /&(nbsp|#160);/g, val: " " },
        // "lt" : { regex: /&(lt|#60);/g, val: "<" },
        // "gt" : { regex: /&(gt|#62);/g, val: ">" },
        // "amp" : { regex: /&(amp|#38);/g, val: "&" },
        // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
        // "apos" : { regex: /&(apos|#39);/g, val: "'" },
        "cent": { regex: /&(cent|#162);/g, val: "Â¢" },
        "pound": { regex: /&(pound|#163);/g, val: "Â£" },
        "yen": { regex: /&(yen|#165);/g, val: "Â¥" },
        "euro": { regex: /&(euro|#8364);/g, val: "â‚¬" },
        "copyright": { regex: /&(copy|#169);/g, val: "Â©" },
        "reg": { regex: /&(reg|#174);/g, val: "Â®" },
        "inr": { regex: /&(inr|#8377);/g, val: "â‚¹" }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue$1;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
    }
  }, __name(_a, "OrderedObjParser"), _a);
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i = 0; i < entKeys.length; i++) {
      const ent = entKeys[i];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  __name(addExternalEntities, "addExternalEntities");
  function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val2 !== void 0) {
      if (this.options.trimValues && !dontTrim) {
        val2 = val2.trim();
      }
      if (val2.length > 0) {
        if (!escapeEntities)
          val2 = this.replaceEntitiesValue(val2);
        const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === void 0) {
          return val2;
        } else if (typeof newval !== typeof val2 || newval !== val2) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val2.trim();
          if (trimmedVal === val2) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val2;
          }
        }
      }
    }
  }
  __name(parseTextData, "parseTextData");
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  __name(resolveNameSpace, "resolveNameSpace");
  const attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (!this.options.ignoreAttributes && typeof attrStr === "string") {
      const matches = util$1.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i = 0; i < len; i++) {
        const attrName = this.resolveNameSpace(matches[i][1]);
        let oldVal = matches[i][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== void 0) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === void 0) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(
                oldVal,
                this.options.parseAttributeValue,
                this.options.numberParseOptions
              );
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  __name(buildAttributesMap, "buildAttributesMap");
  const parseXml = /* @__PURE__ */ __name(function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      const ch = xmlData[i];
      if (ch === "<") {
        if (xmlData[i + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i = closeIndex;
        } else if (xmlData[i + 1] === "?") {
          let tagData = readTagExp(xmlData, i, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags)
            ;
          else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i = tagData.closeIndex + 1;
        } else if (xmlData.substr(i + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i = endIndex;
        } else if (xmlData.substr(i + 1, 2) === "!D") {
          const result = readDocType(xmlData, i);
          this.docTypeEntities = result.entities;
          i = result.i;
        } else if (xmlData.substr(i + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
            if (val2 == void 0)
              val2 = "";
            currentNode.add(this.options.textNodeName, val2);
          }
          i = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
          let tagName = result.tagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              i = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${tagName}`);
              i = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i = closeIndex;
          }
        }
      } else {
        textData += xmlData[i];
      }
    }
    return xmlObj.child;
  }, "parseXml");
  function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false)
      ;
    else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  __name(addChild, "addChild");
  const replaceEntitiesValue$1 = /* @__PURE__ */ __name(function(val2) {
    if (this.options.processEntities) {
      for (let entityName2 in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName2];
        val2 = val2.replace(entity.regx, entity.val);
      }
      for (let entityName2 in this.lastEntities) {
        const entity = this.lastEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName2 in this.htmlEntities) {
          const entity = this.htmlEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
      }
      val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val2;
  }, "replaceEntitiesValue$1");
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === void 0)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(
        textData,
        currentNode.tagname,
        jPath,
        false,
        currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
        isLeafNode
      );
      if (textData !== void 0 && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  __name(saveTextToParentTag, "saveTextToParentTag");
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  __name(isItStopNode, "isItStopNode");
  function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i; index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "	") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  __name(tagExpWithClosingIndex, "tagExpWithClosingIndex");
  function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  __name(findClosingIndex, "findClosingIndex");
  function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
      tagExp = tagExp.substr(separatorIndex + 1);
    }
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent
    };
  }
  __name(readTagExp, "readTagExp");
  function readStopNodeData(xmlData, tagName, i) {
    const startIndex = i;
    let openTagCount = 1;
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        if (xmlData[i + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i: closeIndex
              };
            }
          }
          i = closeIndex;
        } else if (xmlData[i + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i = tagData.closeIndex;
          }
        }
      }
    }
  }
  __name(readStopNodeData, "readStopNodeData");
  function parseValue(val2, shouldParse, options) {
    if (shouldParse && typeof val2 === "string") {
      const newval = val2.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val2, options);
    } else {
      if (util$1.isExist(val2)) {
        return val2;
      } else {
        return "";
      }
    }
  }
  __name(parseValue, "parseValue");
  var OrderedObjParser_1 = OrderedObjParser$1;
  var node2json = {};
  function prettify$1(node, options) {
    return compress(node, options);
  }
  __name(prettify$1, "prettify$1");
  function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for (let i = 0; i < arr.length; i++) {
      const tagObj = arr[i];
      const property = propName$1(tagObj);
      let newJpath = "";
      if (jPath === void 0)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text === void 0)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === void 0) {
        continue;
      } else if (tagObj[property]) {
        let val2 = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val2, options);
        if (tagObj[":@"]) {
          assignAttributes(val2, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
          val2 = val2[options.textNodeName];
        } else if (Object.keys(val2).length === 0) {
          if (options.alwaysCreateTextNode)
            val2[options.textNodeName] = "";
          else
            val2 = "";
        }
        if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val2);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val2];
          } else {
            compressedObj[property] = val2;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options.textNodeName] = text;
    } else if (text !== void 0)
      compressedObj[options.textNodeName] = text;
    return compressedObj;
  }
  __name(compress, "compress");
  function propName$1(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== ":@")
        return key;
    }
  }
  __name(propName$1, "propName$1");
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const atrrName = keys[i];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  __name(assignAttributes, "assignAttributes");
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  __name(isLeafTag, "isLeafTag");
  node2json.prettify = prettify$1;
  const { buildOptions } = OptionsBuilder;
  const OrderedObjParser = OrderedObjParser_1;
  const { prettify } = node2json;
  const validator$1 = validator$2;
  let XMLParser$1 = (_b = class {
    constructor(options) {
      this.externalEntities = {};
      this.options = buildOptions(options);
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string")
        ;
      else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator$1.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === void 0)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }, __name(_b, "XMLParser"), _b);
  var XMLParser_1 = XMLParser$1;
  const EOL = "\n";
  function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
  }
  __name(toXml, "toXml");
  function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i = 0; i < arr.length; i++) {
      const tagObj = arr[i];
      const tagName = propName(tagObj);
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options)) {
          tagText = options.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
      if (options.unpairedTags.indexOf(tagName) !== -1) {
        if (options.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  __name(arrToStr, "arrToStr");
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== ":@")
        return key;
    }
  }
  __name(propName, "propName");
  function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
      for (let attr in attrMap) {
        let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options);
        if (attrVal === true && options.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  __name(attr_to_str, "attr_to_str");
  function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
      if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  }
  __name(isStopNode, "isStopNode");
  function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
      for (let i = 0; i < options.entities.length; i++) {
        const entity = options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  __name(replaceEntitiesValue, "replaceEntitiesValue");
  var orderedJs2Xml = toXml;
  const buildFromOrderedJs = orderedJs2Xml;
  const defaultOptions = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
      return a;
    },
    attributeValueProcessor: function(attrName, a) {
      return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      //it must be on top
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("'", "g"), val: "&apos;" },
      { regex: new RegExp('"', "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    // transformTagName: false,
    // transformAttributeName: false,
    oneListGroup: false
  };
  function Builder(options) {
    this.options = Object.assign({}, defaultOptions, options);
    if (this.options.ignoreAttributes || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = ">\n";
      this.newLine = "\n";
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  __name(Builder, "Builder");
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level) {
    let attrStr = "";
    let val2 = "";
    for (let key in jObj) {
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val2 += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val2 += "";
        } else if (key[0] === "?") {
          val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val2 += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val2 += this.replaceEntitiesValue(newval);
          } else {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        for (let j = 0; j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === "undefined")
            ;
          else if (item === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              listTagVal += this.j2x(item, level + 1).val;
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level);
            }
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, "", level);
        }
        val2 += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;
          for (let j = 0; j < L; j++) {
            attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
          }
        } else {
          val2 += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }
    return { attrStr, val: val2 };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val2) {
    val2 = this.options.attributeValueProcessor(attrName, "" + val2);
    val2 = this.replaceEntitiesValue(val2);
    if (this.options.suppressBooleanAttributes && val2 === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val2 + '"';
  };
  function processTextOrObjNode(object, key, level) {
    const result = this.j2x(object, level + 1);
    if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
      return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  }
  __name(processTextOrObjNode, "processTextOrObjNode");
  Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
    if (val2 === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val2);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i = 0; i < this.options.entities.length; i++) {
        const entity = this.options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  __name(indentate, "indentate");
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  __name(isAttribute, "isAttribute");
  var json2xml = Builder;
  const validator = validator$2;
  const XMLParser = XMLParser_1;
  const XMLBuilder = json2xml;
  var fxp = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
  function sbolXmlToJson(string, options) {
    return __async(this, null, function* () {
      options = options || {};
      const onFileParsed = /* @__PURE__ */ __name(function(sequences) {
        return validateSequenceArray(sequences, options);
      }, "onFileParsed");
      let response = {
        parsedSequence: null,
        messages: [],
        success: true
      };
      try {
        const result = new fxp.XMLParser({
          isArray: () => true,
          ignoreAttributes: false
        }).parse(string);
        const sbolJsonMatches = searchWholeObjByName("DnaComponent", result);
        if (sbolJsonMatches[0]) {
          const resultArray = [];
          for (let i = 0; i < sbolJsonMatches[0].value.length; i++) {
            try {
              response = {
                parsedSequence: null,
                messages: [],
                success: true
              };
              response.parsedSequence = parseSbolJson(
                sbolJsonMatches[0].value[i],
                options
              );
            } catch (e) {
              console.error("error:", e);
              console.error("error.stack: ", e.stack);
              resultArray.push({
                success: false,
                messages: ["Error while parsing Sbol format"]
              });
            }
            if (response.parsedSequence.features.length > 0) {
              response.messages.push(
                "SBOL feature types are stored in feature notes"
              );
            }
            resultArray.push(response);
          }
          return onFileParsed(resultArray);
        } else {
          return onFileParsed({
            success: false,
            messages: ["Error: XML is not valid Jbei or Sbol format"]
          });
        }
      } catch (e) {
        return onFileParsed({
          success: false,
          messages: ["Error parsing XML to JSON"]
        });
      }
    });
  }
  __name(sbolXmlToJson, "sbolXmlToJson");
  function parseSbolJson(sbolJson, options) {
    let name;
    if (lodashExports.get(sbolJson, "name[0]")) {
      name = lodashExports.get(sbolJson, "name[0]");
    } else {
      name = lodashExports.get(sbolJson, "displayId[0]");
    }
    return {
      // circular: get(sbolJson, "seq:circular[0]"), //tnrtodo this needs to be changed
      circular: false,
      sequence: lodashExports.get(sbolJson, "dnaSequence[0].DnaSequence[0].nucleotides"),
      name,
      features: lodashExports.flatMap(sbolJson.annotation, function(annotation) {
        const feature = lodashExports.get(annotation, "SequenceAnnotation[0]");
        if (feature) {
          const notes = searchWholeObjByNameSimpleArray("@_ns2:about", feature);
          const otherNotes = searchWholeObjByNameSimpleArray(
            "@_ns2:resource",
            feature
          );
          const newNotes = {};
          [...notes, ...otherNotes].forEach(function(note) {
            if (note) {
              if (!newNotes.about)
                newNotes.about = [];
              newNotes.about.push(note);
            }
          });
          const featureName = searchWholeObjByNameSimple("name", feature) || searchWholeObjByNameSimple("displayId", feature);
          return {
            name: featureName,
            notes: newNotes,
            type: "misc_feature",
            // sbol represents the feature type in what we are parsing as notes as the URL is difficult to follow
            // type: feature['seq:label'], //tnrtodo: figure out if an annotation type is passed
            // id: feature['seq:label'],
            start: parseInt(
              lodashExports.get(feature, "bioStart[0]") - (options.inclusive1BasedStart ? 0 : 1)
            ),
            end: parseInt(
              lodashExports.get(feature, "bioEnd[0]") - (options.inclusive1BasedEnd ? 0 : 1)
            ),
            strand: lodashExports.get(feature, "strand[0]")
            //+ or -
            // notes: feature['seq:label'],
          };
        }
      })
    };
  }
  __name(parseSbolJson, "parseSbolJson");
  /*!
   *  Copyright 2008 Fair Oaks Labs, Inc.
   *  All rights reserved.
   */
  function BufferPack() {
    var el, bBE = false, m = this;
    m._DeArray = function(a, p, l) {
      return [a.slice(p, p + l)];
    };
    m._EnArray = function(a, p, l, v) {
      for (var i = 0; i < l; a[p + i] = v[i] ? v[i] : 0, i++)
        ;
    };
    m._DeChar = function(a, p) {
      return String.fromCharCode(a[p]);
    };
    m._EnChar = function(a, p, v) {
      a[p] = v.charCodeAt(0);
    };
    m._DeInt = function(a, p) {
      var lsb = bBE ? el.len - 1 : 0, nsb = bBE ? -1 : 1, stop = lsb + nsb * el.len, rv, i, f;
      for (rv = 0, i = lsb, f = 1; i != stop; rv += a[p + i] * f, i += nsb, f *= 256)
        ;
      if (el.bSigned && rv & Math.pow(2, el.len * 8 - 1)) {
        rv -= Math.pow(2, el.len * 8);
      }
      return rv;
    };
    m._EnInt = function(a, p, v) {
      var lsb = bBE ? el.len - 1 : 0, nsb = bBE ? -1 : 1, stop = lsb + nsb * el.len, i;
      v = v < el.min ? el.min : v > el.max ? el.max : v;
      for (i = lsb; i != stop; a[p + i] = v & 255, i += nsb, v >>= 8)
        ;
    };
    m._DeString = function(a, p, l) {
      for (var rv = new Array(l), i = 0; i < l; rv[i] = String.fromCharCode(a[p + i]), i++)
        ;
      return rv.join("");
    };
    m._EnString = function(a, p, l, v) {
      for (var t, i = 0; i < l; a[p + i] = (t = v.charCodeAt(i)) ? t : 0, i++)
        ;
    };
    m._DeNullString = function(a, p, l, v) {
      var str = m._DeString(a, p, l, v);
      return str.substring(0, str.length - 1);
    };
    m._De754 = function(a, p) {
      var s, e, m2, i, d, nBits, mLen, eLen, eBias, eMax;
      mLen = el.mLen, eLen = el.len * 8 - el.mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1;
      i = bBE ? 0 : el.len - 1;
      d = bBE ? 1 : -1;
      s = a[p + i];
      i += d;
      nBits = -7;
      for (e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = e * 256 + a[p + i], i += d, nBits -= 8)
        ;
      for (m2 = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m2 = m2 * 256 + a[p + i], i += d, nBits -= 8)
        ;
      switch (e) {
        case 0:
          e = 1 - eBias;
          break;
        case eMax:
          return m2 ? NaN : (s ? -1 : 1) * Infinity;
        default:
          m2 = m2 + Math.pow(2, mLen);
          e = e - eBias;
          break;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    m._En754 = function(a, p, v) {
      var s, e, m2, i, d, c, mLen, eLen, eBias, eMax;
      mLen = el.mLen, eLen = el.len * 8 - el.mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1;
      s = v < 0 ? 1 : 0;
      v = Math.abs(v);
      if (isNaN(v) || v == Infinity) {
        m2 = isNaN(v) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(v) / Math.LN2);
        if (v * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          v += el.rt / c;
        } else {
          v += el.rt * Math.pow(2, 1 - eBias);
        }
        if (v * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (v * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = v * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (i = bBE ? el.len - 1 : 0, d = bBE ? -1 : 1; mLen >= 8; a[p + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8)
        ;
      for (e = e << mLen | m2, eLen += mLen; eLen > 0; a[p + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      a[p + i - d] |= s * 128;
    };
    m._sPattern = "(\\d+)?([AxcbBhHsSfdiIlL])(\\(([a-zA-Z0-9]+)\\))?";
    m._lenLut = {
      "A": 1,
      "x": 1,
      "c": 1,
      "b": 1,
      "B": 1,
      "h": 2,
      "H": 2,
      "s": 1,
      "S": 1,
      "f": 4,
      "d": 8,
      "i": 4,
      "I": 4,
      "l": 4,
      "L": 4
    };
    m._elLut = {
      "A": { en: m._EnArray, de: m._DeArray },
      "s": { en: m._EnString, de: m._DeString },
      "S": { en: m._EnString, de: m._DeNullString },
      "c": { en: m._EnChar, de: m._DeChar },
      "b": { en: m._EnInt, de: m._DeInt, len: 1, bSigned: true, min: -Math.pow(2, 7), max: Math.pow(2, 7) - 1 },
      "B": { en: m._EnInt, de: m._DeInt, len: 1, bSigned: false, min: 0, max: Math.pow(2, 8) - 1 },
      "h": { en: m._EnInt, de: m._DeInt, len: 2, bSigned: true, min: -Math.pow(2, 15), max: Math.pow(2, 15) - 1 },
      "H": { en: m._EnInt, de: m._DeInt, len: 2, bSigned: false, min: 0, max: Math.pow(2, 16) - 1 },
      "i": { en: m._EnInt, de: m._DeInt, len: 4, bSigned: true, min: -Math.pow(2, 31), max: Math.pow(2, 31) - 1 },
      "I": { en: m._EnInt, de: m._DeInt, len: 4, bSigned: false, min: 0, max: Math.pow(2, 32) - 1 },
      "l": { en: m._EnInt, de: m._DeInt, len: 4, bSigned: true, min: -Math.pow(2, 31), max: Math.pow(2, 31) - 1 },
      "L": { en: m._EnInt, de: m._DeInt, len: 4, bSigned: false, min: 0, max: Math.pow(2, 32) - 1 },
      "f": { en: m._En754, de: m._De754, len: 4, mLen: 23, rt: Math.pow(2, -24) - Math.pow(2, -77) },
      "d": { en: m._En754, de: m._De754, len: 8, mLen: 52, rt: 0 }
    };
    m._UnpackSeries = function(n, s, a, p) {
      for (var fxn = el.de, rv = [], i = 0; i < n; rv.push(fxn(a, p + i * s)), i++)
        ;
      return rv;
    };
    m._PackSeries = function(n, s, a, p, v, i) {
      for (var fxn = el.en, o = 0; o < n; fxn(a, p + o * s, v[i + o]), o++)
        ;
    };
    m._zip = function(keys, values) {
      var result = {};
      for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = values[i];
      }
      return result;
    };
    m.unpack = function(fmt, a, p) {
      bBE = fmt.charAt(0) != "<";
      p = p ? p : 0;
      var re = new RegExp(this._sPattern, "g");
      var m2;
      var n;
      var s;
      var rk = [];
      var rv = [];
      while (m2 = re.exec(fmt)) {
        n = m2[1] == void 0 || m2[1] == "" ? 1 : parseInt(m2[1]);
        if (m2[2] === "S") {
          n = 0;
          while (a[p + n] !== 0) {
            n++;
          }
          n++;
        }
        s = this._lenLut[m2[2]];
        if (p + n * s > a.length) {
          return void 0;
        }
        switch (m2[2]) {
          case "A":
          case "s":
          case "S":
            rv.push(this._elLut[m2[2]].de(a, p, n));
            break;
          case "c":
          case "b":
          case "B":
          case "h":
          case "H":
          case "i":
          case "I":
          case "l":
          case "L":
          case "f":
          case "d":
            el = this._elLut[m2[2]];
            rv.push(this._UnpackSeries(n, s, a, p));
            break;
        }
        rk.push(m2[4]);
        p += n * s;
      }
      rv = Array.prototype.concat.apply([], rv);
      if (rk.indexOf(void 0) !== -1) {
        return rv;
      } else {
        return this._zip(rk, rv);
      }
    };
    m.packTo = function(fmt, a, p, values) {
      bBE = fmt.charAt(0) != "<";
      var re = new RegExp(this._sPattern, "g");
      var m2;
      var n;
      var s;
      var i = 0;
      var j;
      while (m2 = re.exec(fmt)) {
        n = m2[1] == void 0 || m2[1] == "" ? 1 : parseInt(m2[1]);
        if (m2[2] === "S") {
          n = values[i].length + 1;
        }
        s = this._lenLut[m2[2]];
        if (p + n * s > a.length) {
          return false;
        }
        switch (m2[2]) {
          case "A":
          case "s":
          case "S":
            if (i + 1 > values.length) {
              return false;
            }
            this._elLut[m2[2]].en(a, p, n, values[i]);
            i += 1;
            break;
          case "c":
          case "b":
          case "B":
          case "h":
          case "H":
          case "i":
          case "I":
          case "l":
          case "L":
          case "f":
          case "d":
            el = this._elLut[m2[2]];
            if (i + n > values.length) {
              return false;
            }
            this._PackSeries(n, s, a, p, values, i);
            i += n;
            break;
          case "x":
            for (j = 0; j < n; j++) {
              a[p + j] = 0;
            }
            break;
        }
        p += n * s;
      }
      return a;
    };
    m.pack = function(fmt, values) {
      return this.packTo(fmt, new Buffer(this.calcLength(fmt, values)), 0, values);
    };
    m.calcLength = function(format2, values) {
      var re = new RegExp(this._sPattern, "g"), m2, sum = 0, i = 0;
      while (m2 = re.exec(format2)) {
        var n = (m2[1] == void 0 || m2[1] == "" ? 1 : parseInt(m2[1])) * this._lenLut[m2[2]];
        if (m2[2] === "S") {
          n = values[i].length + 1;
        }
        sum += n;
        i++;
      }
      return sum;
    };
  }
  __name(BufferPack, "BufferPack");
  var bufferpack = new BufferPack();
  const bufferpack$1 = /* @__PURE__ */ getDefaultExportFromCjs(bufferpack);
  var string_decoder = {};
  var safeBuffer = { exports: {} };
  var buffer$2 = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
    lookup[i$1] = code[i$1];
    revLookup[code.charCodeAt(i$1)] = i$1;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  __name(getLens, "getLens");
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  __name(byteLength, "byteLength");
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  __name(_byteLength, "_byteLength");
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  __name(toByteArray, "toByteArray");
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  __name(tripletToBase64, "tripletToBase64");
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  __name(encodeChunk, "encodeChunk");
  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  __name(fromByteArray, "fromByteArray");
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports) {
    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer2, "Buffer");
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength2(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer2.isBuffer = /* @__PURE__ */ __name(function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    }, "isBuffer");
    Buffer2.compare = /* @__PURE__ */ __name(function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    }, "compare");
    Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer2.concat = /* @__PURE__ */ __name(function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    }, "concat");
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength2, "byteLength");
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    __name(swap, "swap");
    Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    }, "swap16");
    Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    }, "swap32");
    Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    }, "swap64");
    Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    }, "equals");
    Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
      var str = "";
      var max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer2, val2, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val2 === "string") {
        val2 = Buffer2.from(val2, encoding);
      }
      if (Buffer2.isBuffer(val2)) {
        if (val2.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val2, byteOffset, encoding, dir);
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val2, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val2, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val2], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val2.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val2.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      __name(read, "read");
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val2, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
    }, "indexOf");
    Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer2.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      return val2;
    }, "readUIntLE");
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val2 = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength3] * mul;
      }
      return val2;
    }, "readUIntBE");
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    }, "readIntLE");
    Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i = byteLength3;
      var mul = 1;
      var val2 = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val2 += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    }, "readIntBE");
    Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    }, "readInt16LE");
    Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    }, "readInt16BE");
    Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max2, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntLE");
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntBE");
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntLE");
    Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntBE");
    Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    function checkIEEE754(buf, value, offset, ext, max2, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val2.length === 1) {
          var code2 = val2.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val2 = code2;
          }
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      } else if (typeof val2 === "boolean") {
        val2 = Number(val2);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      var i;
      if (typeof val2 === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val2;
        }
      } else {
        var bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    }, "fill");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      var alphabet2 = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet2[i] + alphabet2[j];
        }
      }
      return table;
    }();
  })(buffer$2);
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  (function(module, exports) {
    var buffer2 = buffer$2;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  var safeBufferExports = safeBuffer.exports;
  var Buffer$2 = safeBufferExports.Buffer;
  var isEncoding = Buffer$2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  __name(_normalizeEncoding, "_normalizeEncoding");
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer$2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  __name(normalizeEncoding, "normalizeEncoding");
  var StringDecoder_1 = string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer$2.allocUnsafe(nb);
  }
  __name(StringDecoder, "StringDecoder");
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  __name(utf8CheckByte, "utf8CheckByte");
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  __name(utf8CheckIncomplete, "utf8CheckIncomplete");
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "ï¿½";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "ï¿½";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "ï¿½";
        }
      }
    }
  }
  __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  __name(utf8FillLast, "utf8FillLast");
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  __name(utf8Text, "utf8Text");
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "ï¿½";
    return r;
  }
  __name(utf8End, "utf8End");
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  __name(utf16Text, "utf16Text");
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  __name(utf16End, "utf16End");
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  __name(base64Text, "base64Text");
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  __name(base64End, "base64End");
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  __name(simpleWrite, "simpleWrite");
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  __name(simpleEnd, "simpleEnd");
  var buffer$1 = {};
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports) {
    const base64 = base64Js;
    const ieee754$1 = ieee754;
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer2, "Buffer");
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer2.isBuffer = /* @__PURE__ */ __name(function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    }, "isBuffer");
    Buffer2.compare = /* @__PURE__ */ __name(function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    }, "compare");
    Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer2.concat = /* @__PURE__ */ __name(function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    }, "concat");
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength2, "byteLength");
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    __name(swap, "swap");
    Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    }, "swap16");
    Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    }, "swap32");
    Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    }, "swap64");
    Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    }, "equals");
    Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer2, val2, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val2 === "string") {
        val2 = Buffer2.from(val2, encoding);
      }
      if (Buffer2.isBuffer(val2)) {
        if (val2.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val2, byteOffset, encoding, dir);
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val2, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val2, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val2], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val2.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val2.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      __name(read, "read");
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val2, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
    }, "indexOf");
    Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer2.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val2 = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      return val2;
    }, "readUIntLE");
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val2 = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength3] * mul;
      }
      return val2;
    }, "readUIntBE");
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
      const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"));
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"));
    Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val2 = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength3 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    }, "readIntLE");
    Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let i = byteLength3;
      let mul = 1;
      let val2 = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val2 += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength3);
      return val2;
    }, "readIntBE");
    Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    }, "readInt16LE");
    Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    }, "readInt16BE");
    Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val2 = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
      return (BigInt(val2) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
    }, "readBigInt64LE"));
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val2 = (first << 24) + // Overflow
      this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      return (BigInt(val2) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
    }, "readBigInt64BE"));
    Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max2, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntLE");
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength3;
    }, "writeUIntBE");
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max2) {
      checkIntBI(value, min, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max2) {
      checkIntBI(value, min, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntLE");
    Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    }, "writeIntBE");
    Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max2, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val2.length === 1) {
          const code2 = val2.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val2 = code2;
          }
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      } else if (typeof val2 === "boolean") {
        val2 = Number(val2);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      let i;
      if (typeof val2 === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val2;
        }
      } else {
        const bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    }, "fill");
    const errors = {};
    function E(sym, getMessage, Base) {
      var _a3;
      errors[sym] = (_a3 = class extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      }, __name(_a3, "NodeError"), _a3);
    }
    __name(E, "E");
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val2) {
      let res = "";
      let i = val2.length;
      const start = val2[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val2.slice(i - 3, i)}${res}`;
      }
      return `${val2.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    function checkIntBI(value, min, max2, buf, offset, byteLength3) {
      if (value > max2 || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength3 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max2}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    __name(checkIntBI, "checkIntBI");
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    const hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet2[i] + alphabet2[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  })(buffer$1);
  const buffer = /* @__PURE__ */ getDefaultExportFromCjs(buffer$1);
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function getArrayBufferFromFile(file) {
    if (!isBrowser) {
      return toArrayBuffer(buffer$1.Buffer.isBuffer(file) ? file : file.buffer || file);
    }
    const reader = new window.FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = (e) => {
        resolve(e.target.result);
      };
      reader.onerror = (err2) => {
        console.error("err:", err2);
        reject(err2);
      };
      reader.readAsArrayBuffer(
        buffer$1.Buffer.isBuffer(file) ? file : file.buffer || file
      );
    });
  }
  __name(getArrayBufferFromFile, "getArrayBufferFromFile");
  function toArrayBuffer(buffer2) {
    const ab = new ArrayBuffer(buffer2.length);
    const view = new Uint8Array(ab);
    for (let i = 0; i < buffer2.length; ++i) {
      view[i] = buffer2[i];
    }
    return ab;
  }
  __name(toArrayBuffer, "toArrayBuffer");
  const Buffer$1 = buffer.Buffer;
  function snapgeneToJson(_0) {
    return __async(this, arguments, function* (fileObj, options = {}) {
      try {
        let read = function(size, fmt) {
          const buffer2 = Buffer$1.from(arrayBuffer.slice(offset, size + offset));
          offset += size;
          if (fmt) {
            const decoder = new StringDecoder_1(fmt);
            const toRet = decoder.write(buffer2);
            return toRet;
          } else {
            return buffer2;
          }
        };
        __name(read, "read");
        const returnVal = createInitialSequence(options);
        const arrayBuffer = yield getArrayBufferFromFile(fileObj);
        const ext = extractFileExtension(options.fileName);
        let isProtein = options.isProtein;
        if (ext && /^(prot)$/.test(ext)) {
          isProtein = true;
          options.isProtein = true;
        }
        let offset = 0;
        function unpack(size, mode) {
          return __async(this, null, function* () {
            const buffer2 = yield read(size);
            const unpacked = yield bufferpack$1.unpack(">" + mode, buffer2);
            if (unpacked === void 0)
              return void 0;
            return yield unpacked[0];
          });
        }
        __name(unpack, "unpack");
        yield read(1);
        const length = yield unpack(4, "I");
        const title = yield read(8, "ascii");
        if (length !== 14 || title !== "SnapGene") {
          throw new Error("Wrong format for a SnapGene file !");
        }
        const data = yield __spreadProps(__spreadValues({}, returnVal.parsedSequence), {
          isProtein,
          isDNA: !!(yield unpack(2, "H")) && !isProtein,
          exportVersion: yield unpack(2, "H"),
          importVersion: yield unpack(2, "H"),
          features: []
        });
        while (offset <= arrayBuffer.byteLength) {
          const next_byte = yield read(1);
          const block_size = yield unpack(4, "I");
          if (ord(next_byte) === 21 || ord(next_byte) === 0) {
            const props = yield unpack(1, "b");
            const binaryRep = dec2bin(props);
            data.circular = isFirstBitA1(binaryRep);
            const size = block_size - 1;
            if (size < 0)
              return;
            data.size = isProtein ? size * 3 : size;
            data.sequence = yield read(size, "utf8");
          } else if (ord(next_byte) === 10) {
            const strand_dict = {
              // [strand, arrowheadType]
              0: [1, "NONE"],
              // non-directional feature (in that case, the attribute is generally absent altogether)
              1: [1, "TOP"],
              // forward strand
              2: [-1, "BOTTOM"],
              // reverse strand
              3: [1, "BOTH"]
              // bi-directional feature
            };
            const xml = yield read(block_size, "utf8");
            const b = new fxp.XMLParser({
              ignoreAttributes: false,
              attributeNamePrefix: "",
              isArray: (name) => name === "Feature" || name === "Segment"
            }).parse(xml);
            const { Features: { Feature = [] } = {} } = b;
            data.features = [];
            Feature.forEach((feat) => {
              const { directionality, Segment = [], name, type } = feat;
              let maxStart = 0;
              let maxEnd = 0;
              const locations = Segment && Segment.map((seg) => {
                if (!seg)
                  throw new Error("invalid feature definition");
                const { range } = seg;
                let { start, end } = getStartAndEndFromRangeString(range);
                start = isProtein ? start * 3 : start;
                end = isProtein ? end * 3 + 2 : end;
                maxStart = Math.max(maxStart, start);
                maxEnd = Math.max(maxEnd, end);
                return {
                  start,
                  end
                };
              });
              data.features.push(__spreadProps(__spreadValues({
                name,
                type
              }, (locations == null ? void 0 : locations.length) > 1 && { locations }), {
                strand: directionality ? strand_dict[directionality][0] : 1,
                arrowheadType: directionality ? strand_dict[directionality][1] : "NONE",
                start: maxStart,
                end: maxEnd
                // color,
              }));
            });
          } else if (ord(next_byte) === 6) {
            const xml = yield read(block_size, "utf8");
            const b = new fxp.XMLParser({}).parse(xml);
            const name = lodashExports.get(b, "Notes.CustomMapLabel");
            if (name) {
              data.name = name;
            }
            const description = lodashExports.get(b, "Notes.Description");
            if (description && typeof description === "string") {
              data.description = description.replace("<html><body>", "").replace("</body></html>", "");
            }
          } else {
            yield read(block_size);
          }
        }
        returnVal.parsedSequence = data;
        return validateSequenceArray(
          flattenSequenceArray([returnVal], options),
          options
        );
      } catch (e) {
        console.error("Error trying to parse file as snapgene:", e);
        return [
          {
            success: false,
            messages: ["Import Error: Invalid File"]
          }
        ];
      }
    });
  }
  __name(snapgeneToJson, "snapgeneToJson");
  function getStartAndEndFromRangeString(rangestring) {
    const [start, end] = rangestring.split("-");
    return {
      start: start - 1,
      end: end - 1
    };
  }
  __name(getStartAndEndFromRangeString, "getStartAndEndFromRangeString");
  function ord(string) {
    const str = string + "";
    const code2 = str.charCodeAt(0);
    if (code2 >= 55296 && code2 <= 56319) {
      const hi = code2;
      if (str.length === 1) {
        return code2;
      }
      const low = str.charCodeAt(1);
      return (hi - 55296) * 1024 + (low - 56320) + 65536;
    }
    if (code2 >= 56320 && code2 <= 57343) {
      return code2;
    }
    return code2;
  }
  __name(ord, "ord");
  function dec2bin(dec) {
    return (dec >>> 0).toString(2);
  }
  __name(dec2bin, "dec2bin");
  function isFirstBitA1(num) {
    return Number(num.toString().split("").pop()) === 1;
  }
  __name(isFirstBitA1, "isFirstBitA1");
  function ab1ToJson(_0) {
    return __async(this, arguments, function* (fileObj, options = {}) {
      const arrayBuffer = yield getArrayBufferFromFile(fileObj);
      const dataview = new DataView(arrayBuffer);
      const converter = new abConverter(dataview);
      const chromatogramData = converter.getTraceData();
      const returnVal = createInitialSequence(options);
      returnVal.parsedSequence = __spreadProps(__spreadValues({}, returnVal.parsedSequence), {
        sequence: chromatogramData.baseCalls.join(""),
        chromatogramData
      });
      return [returnVal];
    });
  }
  __name(ab1ToJson, "ab1ToJson");
  function abConverter(inputArrayBuffer) {
    const dirLocation = inputArrayBuffer.getInt32(26);
    const numElements = inputArrayBuffer.getInt32(18);
    const lastEntry = dirLocation + numElements * 28;
    this.getNumber = (inOffset, numEntries) => {
      const retArray = [];
      for (let counter2 = 0; counter2 < numEntries; counter2 += 1) {
        retArray.push(inputArrayBuffer.getInt8(inOffset + counter2));
      }
      return retArray;
    };
    this.getChar = (inOffset, numEntries) => {
      const retArray = [];
      for (let counter2 = 0; counter2 < numEntries; counter2 += 1) {
        retArray.push(
          String.fromCharCode(inputArrayBuffer.getInt8(inOffset + counter2))
        );
      }
      return retArray;
    };
    this.getShort = (inOffset, numEntries) => {
      const retArray = [];
      for (let counter2 = 0; counter2 < numEntries; counter2 += 2) {
        retArray.push(inputArrayBuffer.getInt16(inOffset + counter2));
      }
      return retArray;
    };
    this.getTagName = (inOffset) => {
      let name = "";
      for (let loopOffset = inOffset; loopOffset < inOffset + 4; loopOffset++) {
        name += String.fromCharCode(inputArrayBuffer.getInt8(loopOffset));
      }
      return name;
    };
    this.getDataTag = function(inTag) {
      let output;
      let curElem = dirLocation;
      do {
        const currTagName = this.getTagName(curElem);
        const tagNum = inputArrayBuffer.getInt32(curElem + 4);
        if (currTagName == inTag.tagName && tagNum === inTag.tagNum) {
          const numEntries = inputArrayBuffer.getInt32(curElem + 16);
          const entryOffset = inputArrayBuffer.getInt32(curElem + 20);
          output = this[inTag.typeToReturn](entryOffset, numEntries);
        }
        curElem += 28;
      } while (curElem < lastEntry);
      return output;
    };
    this.getTraceData = function() {
      const traceData = {};
      traceData.aTrace = this.getDataTag(tagDict.colorDataA);
      traceData.tTrace = this.getDataTag(tagDict.colorDataT);
      traceData.gTrace = this.getDataTag(tagDict.colorDataG);
      traceData.cTrace = this.getDataTag(tagDict.colorDataC);
      traceData.basePos = this.getDataTag(tagDict.peakLocations);
      traceData.baseCalls = this.getDataTag(tagDict.baseCalls2);
      traceData.qualNums = this.getDataTag(tagDict.qualNums);
      if (traceData.qualNums) {
        if (!traceData.qualNums.filter((q) => q !== 1 && q !== 0).length) {
          delete traceData.qualNums;
        }
      }
      return convertBasePosTraceToPerBpTrace(traceData);
    };
    this.getFirstEntry = () => {
      let output = "";
      for (let curElem = dirLocation; curElem < lastEntry; curElem += 28) {
        let name = "";
        for (let offset = curElem; offset < curElem + 4; offset++) {
          name += String.fromCharCode(inputArrayBuffer.getInt8(offset));
        }
        output += ` - ${name}`;
      }
      return output;
    };
  }
  __name(abConverter, "abConverter");
  const tagDict = {
    baseCalls1: { tagName: "PBAS", tagNum: 1, typeToReturn: "getChar" },
    baseCalls2: { tagName: "PBAS", tagNum: 2, typeToReturn: "getChar" },
    qualNums: { tagName: "PCON", tagNum: 2, typeToReturn: "getNumber" },
    peakLocations: { tagName: "PLOC", tagNum: 2, typeToReturn: "getShort" },
    peakDev: { tagName: "P1RL", tagNum: 1, typeToReturn: "getShort" },
    peakOneAmp: { tagName: "P1AM", tagNum: 1, typeToReturn: "getShort" },
    colorDataA: { tagName: "DATA", tagNum: 10, typeToReturn: "getShort" },
    colorDataT: { tagName: "DATA", tagNum: 11, typeToReturn: "getShort" },
    colorDataG: { tagName: "DATA", tagNum: 9, typeToReturn: "getShort" },
    colorDataC: { tagName: "DATA", tagNum: 12, typeToReturn: "getShort" }
  };
  const correctionAmount = 3;
  function convertBasePosTraceToPerBpTrace(chromData) {
    const { basePos, aTrace } = chromData;
    const traceLength = aTrace.length;
    let startPos = 0;
    let nextBasePos = basePos[1];
    let endPos;
    function setEndPos() {
      if (nextBasePos) {
        endPos = startPos + Math.ceil((nextBasePos - startPos) / 2);
      } else {
        endPos = traceLength;
      }
    }
    __name(setEndPos, "setEndPos");
    setEndPos();
    const baseTraces = [];
    for (let i = 0; i < basePos.length; i++) {
      const tracesForType = {
        aTrace: [],
        tTrace: [],
        gTrace: [],
        cTrace: []
      };
      baseTraces[i] = tracesForType;
      [
        "aTrace",
        "tTrace",
        "gTrace",
        "cTrace"
        // eslint-disable-next-line no-loop-func
      ].forEach((type) => {
        const traceForType = tracesForType[type];
        const traceData = chromData[type];
        for (let j = startPos; j < endPos + correctionAmount; j++) {
          traceForType.push(traceData[j] || 0);
        }
      });
      if (i !== basePos.length - 1) {
        startPos = endPos + correctionAmount;
        nextBasePos = basePos[i + 2];
        setEndPos();
      }
    }
    return __spreadValues({
      baseTraces
    }, chromData);
  }
  __name(convertBasePosTraceToPerBpTrace, "convertBasePosTraceToPerBpTrace");
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var inherits_browser = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser.exports = /* @__PURE__ */ __name(function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    }, "inherits");
  } else {
    inherits_browser.exports = /* @__PURE__ */ __name(function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = /* @__PURE__ */ __name(function() {
        }, "TempCtor");
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    }, "inherits");
  }
  var inherits_browserExports = inherits_browser.exports;
  var streamBrowser;
  var hasRequiredStreamBrowser;
  function requireStreamBrowser() {
    if (hasRequiredStreamBrowser)
      return streamBrowser;
    hasRequiredStreamBrowser = 1;
    streamBrowser = require$$0.EventEmitter;
    return streamBrowser;
  }
  __name(requireStreamBrowser, "requireStreamBrowser");
  var buffer_list;
  var hasRequiredBuffer_list;
  function requireBuffer_list() {
    if (hasRequiredBuffer_list)
      return buffer_list;
    hasRequiredBuffer_list = 1;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var _require = buffer$2, Buffer2 = _require.Buffer;
    var _require2 = require$$0, inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    __name(copyBuffer, "copyBuffer");
    buffer_list = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      __name(BufferList, "BufferList");
      _createClass(BufferList, [{
        key: "push",
        value: /* @__PURE__ */ __name(function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }, "push")
      }, {
        key: "unshift",
        value: /* @__PURE__ */ __name(function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }, "unshift")
      }, {
        key: "shift",
        value: /* @__PURE__ */ __name(function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }, "shift")
      }, {
        key: "clear",
        value: /* @__PURE__ */ __name(function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }, "clear")
      }, {
        key: "join",
        value: /* @__PURE__ */ __name(function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }, "join")
      }, {
        key: "concat",
        value: /* @__PURE__ */ __name(function concat2(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }, "concat")
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: /* @__PURE__ */ __name(function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }, "consume")
      }, {
        key: "first",
        value: /* @__PURE__ */ __name(function first() {
          return this.head.data;
        }, "first")
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: /* @__PURE__ */ __name(function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }, "_getString")
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: /* @__PURE__ */ __name(function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }, "_getBuffer")
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: /* @__PURE__ */ __name(function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }, "value")
      }]);
      return BufferList;
    }();
    return buffer_list;
  }
  __name(requireBuffer_list, "requireBuffer_list");
  var destroy_1;
  var hasRequiredDestroy;
  function requireDestroy() {
    if (hasRequiredDestroy)
      return destroy_1;
    hasRequiredDestroy = 1;
    function destroy(err2, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err2);
        } else if (err2) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err2);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err2);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err2 || null, function(err3) {
        if (!cb && err3) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err3);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err3);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err3);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    __name(destroy, "destroy");
    function emitErrorAndCloseNT(self2, err2) {
      emitErrorNT(self2, err2);
      emitCloseNT(self2);
    }
    __name(emitErrorAndCloseNT, "emitErrorAndCloseNT");
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    __name(undestroy, "undestroy");
    function emitErrorNT(self2, err2) {
      self2.emit("error", err2);
    }
    __name(emitErrorNT, "emitErrorNT");
    function errorOrDestroy(stream, err2) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err2);
      else
        stream.emit("error", err2);
    }
    __name(errorOrDestroy, "errorOrDestroy");
    destroy_1 = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return destroy_1;
  }
  __name(requireDestroy, "requireDestroy");
  var errorsBrowser = {};
  var hasRequiredErrorsBrowser;
  function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
      return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    __name(_inheritsLoose, "_inheritsLoose");
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      __name(getMessage, "getMessage");
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        __name(NodeError2, "NodeError");
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    __name(createErrorType, "createErrorType");
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    __name(oneOf, "oneOf");
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    __name(startsWith, "startsWith");
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    __name(endsWith, "endsWith");
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    __name(includes, "includes");
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    errorsBrowser.codes = codes;
    return errorsBrowser;
  }
  __name(requireErrorsBrowser, "requireErrorsBrowser");
  var state;
  var hasRequiredState;
  function requireState() {
    if (hasRequiredState)
      return state;
    hasRequiredState = 1;
    var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    __name(highWaterMarkFrom, "highWaterMarkFrom");
    function getHighWaterMark(state2, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state2.objectMode ? 16 : 16 * 1024;
    }
    __name(getHighWaterMark, "getHighWaterMark");
    state = {
      getHighWaterMark
    };
    return state;
  }
  __name(requireState, "requireState");
  var browser;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser)
      return browser;
    hasRequiredBrowser = 1;
    browser = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      __name(deprecated, "deprecated");
      return deprecated;
    }
    __name(deprecate, "deprecate");
    function config(name) {
      try {
        if (!commonjsGlobal.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val2 = commonjsGlobal.localStorage[name];
      if (null == val2)
        return false;
      return String(val2).toLowerCase() === "true";
    }
    __name(config, "config");
    return browser;
  }
  __name(requireBrowser, "requireBrowser");
  var _stream_writable;
  var hasRequired_stream_writable;
  function require_stream_writable() {
    if (hasRequired_stream_writable)
      return _stream_writable;
    hasRequired_stream_writable = 1;
    _stream_writable = Writable;
    function CorkedRequest(state2) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state2);
      };
    }
    __name(CorkedRequest, "CorkedRequest");
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: requireBrowser()
    };
    var Stream2 = requireStreamBrowser();
    var Buffer2 = buffer$2.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    inherits_browserExports(Writable, Stream2);
    function nop() {
    }
    __name(nop, "nop");
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    __name(WritableState, "WritableState");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    }, "getBuffer");
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(/* @__PURE__ */ __name(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: /* @__PURE__ */ __name(function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }, "value")
      });
    } else {
      realHasInstance = /* @__PURE__ */ __name(function realHasInstance2(object) {
        return object instanceof this;
      }, "realHasInstance");
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    __name(Writable, "Writable");
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    __name(writeAfterEnd, "writeAfterEnd");
    function validChunk(stream, state2, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    __name(validChunk, "validChunk");
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      var ret = false;
      var isBuf = !state2.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state2.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state2.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state2, chunk, cb)) {
        state2.pendingcb++;
        ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state2 = this._writableState;
      if (state2.corked) {
        state2.corked--;
        if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
          clearBuffer(this, state2);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    function decodeChunk(state2, chunk, encoding) {
      if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    __name(decodeChunk, "decodeChunk");
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state2, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state2.objectMode ? 1 : chunk.length;
      state2.length += len;
      var ret = state2.length < state2.highWaterMark;
      if (!ret)
        state2.needDrain = true;
      if (state2.writing || state2.corked) {
        var last = state2.lastBufferedRequest;
        state2.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state2.lastBufferedRequest;
        } else {
          state2.bufferedRequest = state2.lastBufferedRequest;
        }
        state2.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state2, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
      state2.writelen = len;
      state2.writecb = cb;
      state2.writing = true;
      state2.sync = true;
      if (state2.destroyed)
        state2.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state2.onwrite);
      else
        stream._write(chunk, encoding, state2.onwrite);
      state2.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state2, sync, er, cb) {
      --state2.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state2);
      }
    }
    __name(onwriteError, "onwriteError");
    function onwriteStateUpdate(state2) {
      state2.writing = false;
      state2.writecb = null;
      state2.length -= state2.writelen;
      state2.writelen = 0;
    }
    __name(onwriteStateUpdate, "onwriteStateUpdate");
    function onwrite(stream, er) {
      var state2 = stream._writableState;
      var sync = state2.sync;
      var cb = state2.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state2);
      if (er)
        onwriteError(stream, state2, sync, er, cb);
      else {
        var finished = needFinish(state2) || stream.destroyed;
        if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
          clearBuffer(stream, state2);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state2, finished, cb);
        } else {
          afterWrite(stream, state2, finished, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWrite(stream, state2, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state2);
      state2.pendingcb--;
      cb();
      finishMaybe(stream, state2);
    }
    __name(afterWrite, "afterWrite");
    function onwriteDrain(stream, state2) {
      if (state2.length === 0 && state2.needDrain) {
        state2.needDrain = false;
        stream.emit("drain");
      }
    }
    __name(onwriteDrain, "onwriteDrain");
    function clearBuffer(stream, state2) {
      state2.bufferProcessing = true;
      var entry = state2.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state2.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state2.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
        state2.pendingcb++;
        state2.lastBufferedRequest = null;
        if (holder.next) {
          state2.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state2.corkedRequestsFree = new CorkedRequest(state2);
        }
        state2.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state2.objectMode ? 1 : chunk.length;
          doWrite(stream, state2, false, len, chunk, encoding, cb);
          entry = entry.next;
          state2.bufferedRequestCount--;
          if (state2.writing) {
            break;
          }
        }
        if (entry === null)
          state2.lastBufferedRequest = null;
      }
      state2.bufferedRequest = entry;
      state2.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state2 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state2.corked) {
        state2.corked = 1;
        this.uncork();
      }
      if (!state2.ending)
        endWritable(this, state2, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.length;
      }, "get")
    });
    function needFinish(state2) {
      return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state2) {
      stream._final(function(err2) {
        state2.pendingcb--;
        if (err2) {
          errorOrDestroy(stream, err2);
        }
        state2.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state2);
      });
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state2) {
      if (!state2.prefinished && !state2.finalCalled) {
        if (typeof stream._final === "function" && !state2.destroyed) {
          state2.pendingcb++;
          state2.finalCalled = true;
          process.nextTick(callFinal, stream, state2);
        } else {
          state2.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state2) {
      var need = needFinish(state2);
      if (need) {
        prefinish(stream, state2);
        if (state2.pendingcb === 0) {
          state2.finished = true;
          stream.emit("finish");
          if (state2.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    __name(finishMaybe, "finishMaybe");
    function endWritable(stream, state2, cb) {
      state2.ending = true;
      finishMaybe(stream, state2);
      if (cb) {
        if (state2.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state2.ended = true;
      stream.writable = false;
    }
    __name(endWritable, "endWritable");
    function onCorkedFinish(corkReq, state2, err2) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state2.pendingcb--;
        cb(err2);
        entry = entry.next;
      }
      state2.corkedRequestsFree.next = corkReq;
    }
    __name(onCorkedFinish, "onCorkedFinish");
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }, "set")
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
    return _stream_writable;
  }
  __name(require_stream_writable, "require_stream_writable");
  var _stream_duplex;
  var hasRequired_stream_duplex;
  function require_stream_duplex() {
    if (hasRequired_stream_duplex)
      return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    _stream_duplex = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    inherits_browserExports(Duplex, Readable);
    {
      var keys = objectKeys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    __name(Duplex, "Duplex");
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.length;
      }, "get")
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    __name(onend, "onend");
    function onEndNT(self2) {
      self2.end();
    }
    __name(onEndNT, "onEndNT");
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }, "set")
    });
    return _stream_duplex;
  }
  __name(require_stream_duplex, "require_stream_duplex");
  var endOfStream;
  var hasRequiredEndOfStream;
  function requireEndOfStream() {
    if (hasRequiredEndOfStream)
      return endOfStream;
    hasRequiredEndOfStream = 1;
    var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    __name(once, "once");
    function noop() {
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = /* @__PURE__ */ __name(function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      }, "onlegacyfinish");
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = /* @__PURE__ */ __name(function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      }, "onfinish");
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = /* @__PURE__ */ __name(function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      }, "onend");
      var onerror = /* @__PURE__ */ __name(function onerror2(err2) {
        callback.call(stream, err2);
      }, "onerror");
      var onclose = /* @__PURE__ */ __name(function onclose2() {
        var err2;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err2 = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err2);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err2 = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err2);
        }
      }, "onclose");
      var onrequest = /* @__PURE__ */ __name(function onrequest2() {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    __name(eos, "eos");
    endOfStream = eos;
    return endOfStream;
  }
  __name(requireEndOfStream, "requireEndOfStream");
  var async_iterator;
  var hasRequiredAsync_iterator;
  function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
      return async_iterator;
    hasRequiredAsync_iterator = 1;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var finished = requireEndOfStream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    __name(createIterResult, "createIterResult");
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    __name(readAndResolve, "readAndResolve");
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    __name(onReadable, "onReadable");
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    __name(wrapForNext, "wrapForNext");
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: /* @__PURE__ */ __name(function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }, "next")
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", /* @__PURE__ */ __name(function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err2) {
          if (err2) {
            reject(err2);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }, "_return")), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = /* @__PURE__ */ __name(function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: /* @__PURE__ */ __name(function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        }, "value"),
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err2) {
        if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err2);
          }
          iterator[kError] = err2;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    }, "createReadableStreamAsyncIterator");
    async_iterator = createReadableStreamAsyncIterator;
    return async_iterator;
  }
  __name(requireAsync_iterator, "requireAsync_iterator");
  var fromBrowser;
  var hasRequiredFromBrowser;
  function requireFromBrowser() {
    if (hasRequiredFromBrowser)
      return fromBrowser;
    hasRequiredFromBrowser = 1;
    fromBrowser = /* @__PURE__ */ __name(function() {
      throw new Error("Readable.from is not available in the browser");
    }, "fromBrowser");
    return fromBrowser;
  }
  __name(requireFromBrowser, "requireFromBrowser");
  var _stream_readable;
  var hasRequired_stream_readable;
  function require_stream_readable() {
    if (hasRequired_stream_readable)
      return _stream_readable;
    hasRequired_stream_readable = 1;
    _stream_readable = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    require$$0.EventEmitter;
    var EElistenerCount = /* @__PURE__ */ __name(function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }, "EElistenerCount");
    var Stream2 = requireStreamBrowser();
    var Buffer2 = buffer$2.Buffer;
    var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var debugUtil = require$$0;
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = /* @__PURE__ */ __name(function debug2() {
      }, "debug");
    }
    var BufferList = requireBuffer_list();
    var destroyImpl = requireDestroy();
    var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from;
    inherits_browserExports(Readable, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    __name(prependListener, "prependListener");
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = string_decoder.StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    __name(Readable, "Readable");
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }, "set")
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state2 = this._readableState;
      var skipChunkCheck;
      if (!state2.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state2.defaultEncoding;
          if (encoding !== state2.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state2 = stream._readableState;
      if (chunk === null) {
        state2.reading = false;
        onEofChunk(stream, state2);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state2, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state2.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state2.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state2, chunk, true);
          } else if (state2.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state2.destroyed) {
            return false;
          } else {
            state2.reading = false;
            if (state2.decoder && !encoding) {
              chunk = state2.decoder.write(chunk);
              if (state2.objectMode || chunk.length !== 0)
                addChunk(stream, state2, chunk, false);
              else
                maybeReadMore(stream, state2);
            } else {
              addChunk(stream, state2, chunk, false);
            }
          }
        } else if (!addToFront) {
          state2.reading = false;
          maybeReadMore(stream, state2);
        }
      }
      return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state2, chunk, addToFront) {
      if (state2.flowing && state2.length === 0 && !state2.sync) {
        state2.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state2.length += state2.objectMode ? 1 : chunk.length;
        if (addToFront)
          state2.buffer.unshift(chunk);
        else
          state2.buffer.push(chunk);
        if (state2.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state2);
    }
    __name(addChunk, "addChunk");
    function chunkInvalid(state2, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    __name(chunkInvalid, "chunkInvalid");
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = string_decoder.StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state2) {
      if (n <= 0 || state2.length === 0 && state2.ended)
        return 0;
      if (state2.objectMode)
        return 1;
      if (n !== n) {
        if (state2.flowing && state2.length)
          return state2.buffer.head.data.length;
        else
          return state2.length;
      }
      if (n > state2.highWaterMark)
        state2.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state2.length)
        return n;
      if (!state2.ended) {
        state2.needReadable = true;
        return 0;
      }
      return state2.length;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state2 = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state2.emittedReadable = false;
      if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
        debug("read: emitReadable", state2.length, state2.ended);
        if (state2.length === 0 && state2.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state2);
      if (n === 0 && state2.ended) {
        if (state2.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state2.needReadable;
      debug("need readable", doRead);
      if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state2.ended || state2.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state2.reading = true;
        state2.sync = true;
        if (state2.length === 0)
          state2.needReadable = true;
        this._read(state2.highWaterMark);
        state2.sync = false;
        if (!state2.reading)
          n = howMuchToRead(nOrig, state2);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state2);
      else
        ret = null;
      if (ret === null) {
        state2.needReadable = state2.length <= state2.highWaterMark;
        n = 0;
      } else {
        state2.length -= n;
        state2.awaitDrain = 0;
      }
      if (state2.length === 0) {
        if (!state2.ended)
          state2.needReadable = true;
        if (nOrig !== n && state2.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state2) {
      debug("onEofChunk");
      if (state2.ended)
        return;
      if (state2.decoder) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) {
          state2.buffer.push(chunk);
          state2.length += state2.objectMode ? 1 : chunk.length;
        }
      }
      state2.ended = true;
      if (state2.sync) {
        emitReadable(stream);
      } else {
        state2.needReadable = false;
        if (!state2.emittedReadable) {
          state2.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      var state2 = stream._readableState;
      debug("emitReadable", state2.needReadable, state2.emittedReadable);
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        debug("emitReadable", state2.flowing);
        state2.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      var state2 = stream._readableState;
      debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
      if (!state2.destroyed && (state2.length || state2.ended)) {
        stream.emit("readable");
        state2.emittedReadable = false;
      }
      state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state2) {
      if (!state2.readingMore) {
        state2.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state2);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state2) {
      while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
        var len = state2.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state2.length)
          break;
      }
      state2.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state2 = this._readableState;
      switch (state2.pipesCount) {
        case 0:
          state2.pipes = dest;
          break;
        case 1:
          state2.pipes = [state2.pipes, dest];
          break;
        default:
          state2.pipes.push(dest);
          break;
      }
      state2.pipesCount += 1;
      debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state2.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug("onend");
        dest.end();
      }
      __name(onend, "onend");
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      __name(cleanup, "cleanup");
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state2.awaitDrain);
            state2.awaitDrain++;
          }
          src.pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (!state2.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
        var state2 = src._readableState;
        debug("pipeOnDrain", state2.awaitDrain);
        if (state2.awaitDrain)
          state2.awaitDrain--;
        if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state2.flowing = true;
          flow(src);
        }
      }, "pipeOnDrainFunctionResult");
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      var state2 = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state2.pipesCount === 0)
        return this;
      if (state2.pipesCount === 1) {
        if (dest && dest !== state2.pipes)
          return this;
        if (!dest)
          dest = state2.pipes;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state2.pipes;
        var len = state2.pipesCount;
        state2.pipes = null;
        state2.pipesCount = 0;
        state2.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state2.pipes, dest);
      if (index === -1)
        return this;
      state2.pipes.splice(index, 1);
      state2.pipesCount -= 1;
      if (state2.pipesCount === 1)
        state2.pipes = state2.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state2 = this._readableState;
      if (ev === "data") {
        state2.readableListening = this.listenerCount("readable") > 0;
        if (state2.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state2.endEmitted && !state2.readableListening) {
          state2.readableListening = state2.needReadable = true;
          state2.flowing = false;
          state2.emittedReadable = false;
          debug("on readable", state2.length, state2.reading);
          if (state2.length) {
            emitReadable(this);
          } else if (!state2.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state2 = self2._readableState;
      state2.readableListening = self2.listenerCount("readable") > 0;
      if (state2.resumeScheduled && !state2.paused) {
        state2.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    __name(updateReadableListening, "updateReadableListening");
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      var state2 = this._readableState;
      if (!state2.flowing) {
        debug("resume");
        state2.flowing = !state2.readableListening;
        resume(this, state2);
      }
      state2.paused = false;
      return this;
    };
    function resume(stream, state2) {
      if (!state2.resumeScheduled) {
        state2.resumeScheduled = true;
        process.nextTick(resume_, stream, state2);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state2) {
      debug("resume", state2.reading);
      if (!state2.reading) {
        stream.read(0);
      }
      state2.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state2.flowing && !state2.reading)
        stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state2 = stream._readableState;
      debug("flow", state2.flowing);
      while (state2.flowing && stream.read() !== null)
        ;
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state2 = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state2.decoder && !state2.ended) {
          var chunk = state2.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state2.decoder)
          chunk = state2.decoder.write(chunk);
        if (state2.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state2.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = (/* @__PURE__ */ __name(function methodWrap(method) {
            return /* @__PURE__ */ __name(function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            }, "methodWrapReturnFunction");
          }, "methodWrap"))(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = requireAsync_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState && this._readableState.buffer;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.flowing;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(state2) {
        if (this._readableState) {
          this._readableState.flowing = state2;
        }
      }, "set")
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.length;
      }, "get")
    });
    function fromList(n, state2) {
      if (state2.length === 0)
        return null;
      var ret;
      if (state2.objectMode)
        ret = state2.buffer.shift();
      else if (!n || n >= state2.length) {
        if (state2.decoder)
          ret = state2.buffer.join("");
        else if (state2.buffer.length === 1)
          ret = state2.buffer.first();
        else
          ret = state2.buffer.concat(state2.length);
        state2.buffer.clear();
      } else {
        ret = state2.buffer.consume(n, state2.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function endReadable(stream) {
      var state2 = stream._readableState;
      debug("endReadable", state2.endEmitted);
      if (!state2.endEmitted) {
        state2.ended = true;
        process.nextTick(endReadableNT, state2, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state2, stream) {
      debug("endReadableNT", state2.endEmitted, state2.length);
      if (!state2.endEmitted && state2.length === 0) {
        state2.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state2.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    __name(endReadableNT, "endReadableNT");
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = requireFromBrowser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    return _stream_readable;
  }
  __name(require_stream_readable, "require_stream_readable");
  var _stream_transform;
  var hasRequired_stream_transform;
  function require_stream_transform() {
    if (hasRequired_stream_transform)
      return _stream_transform;
    hasRequired_stream_transform = 1;
    _stream_transform = Transform;
    var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    inherits_browserExports(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    __name(afterTransform, "afterTransform");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err2, cb) {
      Duplex.prototype._destroy.call(this, err2, function(err22) {
        cb(err22);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    __name(done, "done");
    return _stream_transform;
  }
  __name(require_stream_transform, "require_stream_transform");
  var _stream_passthrough;
  var hasRequired_stream_passthrough;
  function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
      return _stream_passthrough;
    hasRequired_stream_passthrough = 1;
    _stream_passthrough = PassThrough;
    var Transform = require_stream_transform();
    inherits_browserExports(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return _stream_passthrough;
  }
  __name(require_stream_passthrough, "require_stream_passthrough");
  var pipeline_1;
  var hasRequiredPipeline;
  function requirePipeline() {
    if (hasRequiredPipeline)
      return pipeline_1;
    hasRequiredPipeline = 1;
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    __name(once, "once");
    var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err2) {
      if (err2)
        throw err2;
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = requireEndOfStream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err2) {
        if (err2)
          return callback(err2);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err2) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    __name(destroyer, "destroyer");
    function call(fn) {
      fn();
    }
    __name(call, "call");
    function pipe(from, to) {
      return from.pipe(to);
    }
    __name(pipe, "pipe");
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    __name(popCallback, "popCallback");
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err2) {
          if (!error)
            error = err2;
          if (err2)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    __name(pipeline, "pipeline");
    pipeline_1 = pipeline;
    return pipeline_1;
  }
  __name(requirePipeline, "requirePipeline");
  var streamBrowserify = Stream;
  var EE = require$$0.EventEmitter;
  var inherits = inherits_browserExports;
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  __name(Stream, "Stream");
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    __name(ondata, "ondata");
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    __name(ondrain, "ondrain");
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    __name(onend, "onend");
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    __name(onclose, "onclose");
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    __name(onerror, "onerror");
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    __name(cleanup, "cleanup");
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  function unescape(stringVal) {
    return stringVal.replace(/%([0-9A-Fa-f]{2})/g, (_match, seq) => String.fromCharCode(parseInt(seq, 16)));
  }
  __name(unescape, "unescape");
  function _escape(regex, s) {
    return String(s).replace(regex, (ch) => {
      const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0");
      return `%${hex}`;
    });
  }
  __name(_escape, "_escape");
  function escape(rawVal) {
    return _escape(/[\n;\r\t=%&,\x00-\x1f\x7f-\xff]/g, rawVal);
  }
  __name(escape, "escape");
  function escapeColumn(rawVal) {
    return _escape(/[\n\r\t%\x00-\x1f\x7f-\xff]/g, rawVal);
  }
  __name(escapeColumn, "escapeColumn");
  function parseAttributes(attrString) {
    if (!(attrString && attrString.length) || attrString === ".")
      return {};
    const attrs = {};
    attrString.replace(/\r?\n$/, "").split(";").forEach((a) => {
      const nv = a.split("=", 2);
      if (!(nv[1] && nv[1].length))
        return;
      nv[0] = nv[0].trim();
      let arec = attrs[nv[0].trim()];
      if (!arec) {
        arec = [];
        attrs[nv[0]] = arec;
      }
      arec.push(...nv[1].split(",").map((s) => s.trim()).map(unescape));
    });
    return attrs;
  }
  __name(parseAttributes, "parseAttributes");
  function parseFeature(line) {
    const f = line.split("	").map((a) => a === "." || a === "" ? null : a);
    const parsed = {
      seq_id: f[0] && unescape(f[0]),
      source: f[1] && unescape(f[1]),
      type: f[2] && unescape(f[2]),
      start: f[3] === null ? null : parseInt(f[3], 10),
      end: f[4] === null ? null : parseInt(f[4], 10),
      score: f[5] === null ? null : parseFloat(f[5]),
      strand: f[6],
      phase: f[7],
      attributes: f[8] === null ? null : parseAttributes(f[8])
    };
    return parsed;
  }
  __name(parseFeature, "parseFeature");
  function parseDirective(line) {
    const match = /^\s*##\s*(\S+)\s*(.*)/.exec(line);
    if (!match)
      return null;
    const [, name] = match;
    let [, , contents] = match;
    const parsed = { directive: name };
    if (contents.length) {
      contents = contents.replace(/\r?\n$/, "");
      parsed.value = contents;
    }
    if (name === "sequence-region") {
      const c = contents.split(/\s+/, 3);
      return __spreadProps(__spreadValues({}, parsed), {
        seq_id: c[0],
        start: c[1] && c[1].replace(/\D/g, ""),
        end: c[2] && c[2].replace(/\D/g, "")
      });
    } else if (name === "genome-build") {
      const [source, buildName] = contents.split(/\s+/, 2);
      return __spreadProps(__spreadValues({}, parsed), {
        source,
        buildName
      });
    }
    return parsed;
  }
  __name(parseDirective, "parseDirective");
  function formatAttributes(attrs) {
    const attrOrder = [];
    Object.entries(attrs).forEach(([tag, val2]) => {
      if (!val2)
        return;
      let valstring;
      if (val2.hasOwnProperty("toString")) {
        valstring = escape(val2.toString());
      } else if (Array.isArray(val2)) {
        valstring = val2.map(escape).join(",");
      } else {
        valstring = escape(val2);
      }
      attrOrder.push(`${escape(tag)}=${valstring}`);
    });
    return attrOrder.length ? attrOrder.join(";") : ".";
  }
  __name(formatAttributes, "formatAttributes");
  function _formatSingleFeature(f, seenFeature) {
    const attrString = f.attributes === null || f.attributes === void 0 ? "." : formatAttributes(f.attributes);
    const fields = [
      f.seq_id === null ? "." : escapeColumn(f.seq_id),
      f.source === null ? "." : escapeColumn(f.source),
      f.type === null ? "." : escapeColumn(f.type),
      f.start === null ? "." : escapeColumn(f.start),
      f.end === null ? "." : escapeColumn(f.end),
      f.score === null ? "." : escapeColumn(f.score),
      f.strand === null ? "." : escapeColumn(f.strand),
      f.phase === null ? "." : escapeColumn(f.phase),
      attrString
    ];
    const formattedString = `${fields.join("	")}
`;
    if (seenFeature[formattedString]) {
      return "";
    }
    seenFeature[formattedString] = true;
    return formattedString;
  }
  __name(_formatSingleFeature, "_formatSingleFeature");
  function _formatFeature(feature, seenFeature) {
    if (Array.isArray(feature)) {
      return feature.map((f) => _formatFeature(f, seenFeature)).join("");
    }
    const strings = [_formatSingleFeature(feature, seenFeature)];
    if (_isFeatureLineWithRefs(feature)) {
      strings.push(...feature.child_features.map((f) => _formatFeature(f, seenFeature)), ...feature.derived_features.map((f) => _formatFeature(f, seenFeature)));
    }
    return strings.join("");
  }
  __name(_formatFeature, "_formatFeature");
  function formatFeature(featureOrFeatures) {
    const seen = {};
    return _formatFeature(featureOrFeatures, seen);
  }
  __name(formatFeature, "formatFeature");
  function formatDirective(directive) {
    let str = `##${directive.directive}`;
    if (directive.value)
      str += ` ${directive.value}`;
    str += "\n";
    return str;
  }
  __name(formatDirective, "formatDirective");
  function formatComment(comment) {
    return `# ${comment.comment}
`;
  }
  __name(formatComment, "formatComment");
  function formatSequence(seq) {
    return `>${seq.id}${seq.description ? ` ${seq.description}` : ""}
${seq.sequence}
`;
  }
  __name(formatSequence, "formatSequence");
  function formatItem(itemOrItems) {
    function formatSingleItem(item) {
      if ("attributes" in item)
        return formatFeature(item);
      if ("directive" in item)
        return formatDirective(item);
      if ("sequence" in item)
        return formatSequence(item);
      if ("comment" in item)
        return formatComment(item);
      return "# (invalid item found during format)\n";
    }
    __name(formatSingleItem, "formatSingleItem");
    if (Array.isArray(itemOrItems)) {
      return itemOrItems.map(formatSingleItem);
    }
    return formatSingleItem(itemOrItems);
  }
  __name(formatItem, "formatItem");
  function _isFeatureLineWithRefs(featureLine) {
    return featureLine.child_features !== void 0 && featureLine.derived_features !== void 0;
  }
  __name(_isFeatureLineWithRefs, "_isFeatureLineWithRefs");
  const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    escape,
    escapeColumn,
    formatAttributes,
    formatComment,
    formatDirective,
    formatFeature,
    formatItem,
    formatSequence,
    parseAttributes,
    parseDirective,
    parseFeature,
    unescape
  }, Symbol.toStringTag, { value: "Module" }));
  const containerAttributes = {
    Parent: "child_features",
    Derives_from: "derived_features"
  };
  const _FASTAParser = class _FASTAParser {
    constructor(seqCallback) {
      this.seqCallback = seqCallback;
      this.currentSequence = void 0;
    }
    addLine(line) {
      const defMatch = /^>\s*(\S+)\s*(.*)/.exec(line);
      if (defMatch) {
        this._flush();
        this.currentSequence = { id: defMatch[1], sequence: "" };
        if (defMatch[2])
          this.currentSequence.description = defMatch[2].trim();
      } else if (this.currentSequence && /\S/.test(line)) {
        this.currentSequence.sequence += line.replace(/\s/g, "");
      }
    }
    _flush() {
      if (this.currentSequence)
        this.seqCallback(this.currentSequence);
    }
    finish() {
      this._flush();
    }
  };
  __name(_FASTAParser, "FASTAParser");
  let FASTAParser = _FASTAParser;
  const _Parser = class _Parser {
    constructor(args) {
      this.fastaParser = void 0;
      this.eof = false;
      this.lineNumber = 0;
      this._underConstructionTopLevel = [];
      this._underConstructionById = {};
      this._completedReferences = {};
      this._underConstructionOrphans = {};
      const nullFunc = /* @__PURE__ */ __name(() => {
      }, "nullFunc");
      this.featureCallback = args.featureCallback || nullFunc;
      this.endCallback = args.endCallback || nullFunc;
      this.commentCallback = args.commentCallback || nullFunc;
      this.errorCallback = args.errorCallback || nullFunc;
      this.directiveCallback = args.directiveCallback || nullFunc;
      this.sequenceCallback = args.sequenceCallback || nullFunc;
      this.disableDerivesFromReferences = args.disableDerivesFromReferences || false;
      this.bufferSize = args.bufferSize === void 0 ? 1e3 : args.bufferSize;
    }
    addLine(line) {
      if (this.fastaParser) {
        this.fastaParser.addLine(line);
        return;
      }
      if (this.eof) {
        return;
      }
      this.lineNumber += 1;
      if (/^\s*[^#\s>]/.test(line)) {
        this._bufferLine(line);
        return;
      }
      const match = /^\s*(#+)(.*)/.exec(line);
      if (match) {
        const [, hashsigns] = match;
        let [, , contents] = match;
        if (hashsigns.length === 3) {
          this._emitAllUnderConstructionFeatures();
        } else if (hashsigns.length === 2) {
          const directive = parseDirective(line);
          if (directive) {
            if (directive.directive === "FASTA") {
              this._emitAllUnderConstructionFeatures();
              this.eof = true;
              this.fastaParser = new FASTAParser(this.sequenceCallback);
            } else {
              this._emitItem(directive);
            }
          }
        } else {
          contents = contents.replace(/\s*/, "");
          this._emitItem({ comment: contents });
        }
      } else if (/^\s*$/.test(line))
        ;
      else if (/^\s*>/.test(line)) {
        this._emitAllUnderConstructionFeatures();
        this.eof = true;
        this.fastaParser = new FASTAParser(this.sequenceCallback);
        this.fastaParser.addLine(line);
      } else {
        const errLine = line.replace(/\r?\n?$/g, "");
        throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`);
      }
    }
    finish() {
      this._emitAllUnderConstructionFeatures();
      if (this.fastaParser)
        this.fastaParser.finish();
      this.endCallback();
    }
    _emitItem(i) {
      if (Array.isArray(i))
        this.featureCallback(i);
      else if ("directive" in i)
        this.directiveCallback(i);
      else if ("comment" in i)
        this.commentCallback(i);
    }
    _enforceBufferSizeLimit(additionalItemCount = 0) {
      const _unbufferItem = /* @__PURE__ */ __name((item) => {
        if (item && Array.isArray(item) && item[0].attributes && item[0].attributes.ID && item[0].attributes.ID[0]) {
          const ids = item[0].attributes.ID;
          ids.forEach((id) => {
            delete this._underConstructionById[id];
            delete this._completedReferences[id];
          });
          item.forEach((i) => {
            if (i.child_features)
              i.child_features.forEach((c) => _unbufferItem(c));
            if (i.derived_features)
              i.derived_features.forEach((d) => _unbufferItem(d));
          });
        }
      }, "_unbufferItem");
      while (this._underConstructionTopLevel.length + additionalItemCount > this.bufferSize) {
        const item = this._underConstructionTopLevel.shift();
        if (item) {
          this._emitItem(item);
          _unbufferItem(item);
        }
      }
    }
    /**
     * return all under-construction features, called when we know
     * there will be no additional data to attach to them
     */
    _emitAllUnderConstructionFeatures() {
      this._underConstructionTopLevel.forEach(this._emitItem.bind(this));
      this._underConstructionTopLevel = [];
      this._underConstructionById = {};
      this._completedReferences = {};
      if (Array.from(Object.values(this._underConstructionOrphans)).length) {
        throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${Object.keys(this._underConstructionOrphans)}`);
      }
    }
    // do the right thing with a newly-parsed feature line
    _bufferLine(line) {
      var _a3, _b3, _c;
      const rawFeatureLine = parseFeature(line);
      const featureLine = __spreadProps(__spreadValues({}, rawFeatureLine), {
        child_features: [],
        derived_features: []
      });
      const ids = ((_a3 = featureLine.attributes) === null || _a3 === void 0 ? void 0 : _a3.ID) || [];
      const parents = ((_b3 = featureLine.attributes) === null || _b3 === void 0 ? void 0 : _b3.Parent) || [];
      const derives = this.disableDerivesFromReferences ? [] : ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];
      if (!ids.length && !parents.length && !derives.length) {
        this._emitItem([featureLine]);
        return;
      }
      let feature = void 0;
      ids.forEach((id) => {
        const existing = this._underConstructionById[id];
        if (existing) {
          if (existing[existing.length - 1].type !== featureLine.type) {
            this._parseError(`multi-line feature "${id}" has inconsistent types: "${featureLine.type}", "${existing[existing.length - 1].type}"`);
          }
          existing.push(featureLine);
          feature = existing;
        } else {
          feature = [featureLine];
          this._enforceBufferSizeLimit(1);
          if (!parents.length && !derives.length) {
            this._underConstructionTopLevel.push(feature);
          }
          this._underConstructionById[id] = feature;
          this._resolveReferencesTo(feature, id);
        }
      });
      this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);
    }
    _resolveReferencesTo(feature, id) {
      const references = this._underConstructionOrphans[id];
      if (!references)
        return;
      feature.forEach((loc) => {
        loc.child_features.push(...references.Parent);
      });
      feature.forEach((loc) => {
        loc.derived_features.push(...references.Derives_from);
      });
      delete this._underConstructionOrphans[id];
    }
    _parseError(message) {
      this.eof = true;
      this.errorCallback(`${this.lineNumber}: ${message}`);
    }
    _resolveReferencesFrom(feature, references, ids) {
      function postSet(obj, slot1, slot2) {
        let subObj = obj[slot1];
        if (!subObj) {
          subObj = {};
          obj[slot1] = subObj;
        }
        const returnVal = subObj[slot2] || false;
        subObj[slot2] = true;
        return returnVal;
      }
      __name(postSet, "postSet");
      references.Parent.forEach((toId) => {
        const otherFeature = this._underConstructionById[toId];
        if (otherFeature) {
          const pname = containerAttributes.Parent;
          if (!ids.filter((id) => postSet(this._completedReferences, id, `Parent,${toId}`)).length) {
            otherFeature.forEach((location) => {
              location[pname].push(feature);
            });
          }
        } else {
          let ref = this._underConstructionOrphans[toId];
          if (!ref) {
            ref = {
              Parent: [],
              Derives_from: []
            };
            this._underConstructionOrphans[toId] = ref;
          }
          ref.Parent.push(feature);
        }
      });
      references.Derives_from.forEach((toId) => {
        const otherFeature = this._underConstructionById[toId];
        if (otherFeature) {
          const pname = containerAttributes.Derives_from;
          if (!ids.filter((id) => postSet(this._completedReferences, id, `Derives_from,${toId}`)).length) {
            otherFeature.forEach((location) => {
              location[pname].push(feature);
            });
          }
        } else {
          let ref = this._underConstructionOrphans[toId];
          if (!ref) {
            ref = {
              Parent: [],
              Derives_from: []
            };
            this._underConstructionOrphans[toId] = ref;
          }
          ref.Derives_from.push(feature);
        }
      });
    }
  };
  __name(_Parser, "Parser");
  let Parser = _Parser;
  function _callback(callback) {
    if (process && process.nextTick)
      process.nextTick(callback);
    else
      callback();
  }
  __name(_callback, "_callback");
  function _processParseOptions(options) {
    const out = __spreadValues({
      encoding: "utf8",
      parseFeatures: true,
      parseDirectives: false,
      parseSequences: true,
      parseComments: false,
      bufferSize: 1e3,
      disableDerivesFromReferences: false
    }, options);
    if (options.parseAll) {
      out.parseFeatures = true;
      out.parseDirectives = true;
      out.parseComments = true;
      out.parseSequences = true;
    }
    return out;
  }
  __name(_processParseOptions, "_processParseOptions");
  const _GFFTransform = class _GFFTransform extends streamBrowserify.Transform {
    constructor(inputOptions = {}) {
      super({ objectMode: true });
      this.textBuffer = "";
      const options = _processParseOptions(inputOptions);
      this.encoding = inputOptions.encoding || "utf8";
      this.decoder = new StringDecoder_1();
      const push = this.push.bind(this);
      this.parser = new Parser({
        featureCallback: options.parseFeatures ? push : void 0,
        directiveCallback: options.parseDirectives ? push : void 0,
        commentCallback: options.parseComments ? push : void 0,
        sequenceCallback: options.parseSequences ? push : void 0,
        errorCallback: (err2) => this.emit("error", err2),
        bufferSize: options.bufferSize,
        disableDerivesFromReferences: options.disableDerivesFromReferences
      });
    }
    _addLine(data) {
      if (data) {
        this.parser.addLine(data);
      }
    }
    _nextText(buffer2) {
      const pieces = (this.textBuffer + buffer2).split(/\r?\n/);
      this.textBuffer = pieces.pop() || "";
      pieces.forEach((piece) => this._addLine(piece));
    }
    _transform(chunk, _encoding, callback) {
      this._nextText(this.decoder.write(chunk));
      _callback(callback);
    }
    _flush(callback) {
      if (this.decoder.end)
        this._nextText(this.decoder.end());
      if (this.textBuffer != null)
        this._addLine(this.textBuffer);
      this.parser.finish();
      _callback(callback);
    }
  };
  __name(_GFFTransform, "GFFTransform");
  let GFFTransform = _GFFTransform;
  function parseStream(options = {}) {
    return new GFFTransform(options);
  }
  __name(parseStream, "parseStream");
  function parseStringSync(str, inputOptions = {}) {
    if (!str)
      return [];
    const options = _processParseOptions(inputOptions);
    const items = [];
    const push = items.push.bind(items);
    const parser = new Parser({
      featureCallback: options.parseFeatures ? push : void 0,
      directiveCallback: options.parseDirectives ? push : void 0,
      commentCallback: options.parseComments ? push : void 0,
      sequenceCallback: options.parseSequences ? push : void 0,
      disableDerivesFromReferences: options.disableDerivesFromReferences || false,
      bufferSize: Infinity,
      errorCallback: (err2) => {
        throw err2;
      }
    });
    str.split(/\r?\n/).forEach(parser.addLine.bind(parser));
    parser.finish();
    return items;
  }
  __name(parseStringSync, "parseStringSync");
  function formatSync(items) {
    const other = [];
    const sequences = [];
    items.forEach((i) => {
      if ("sequence" in i)
        sequences.push(i);
      else
        other.push(i);
    });
    let str = other.map(formatItem).join("");
    if (sequences.length) {
      str += "##FASTA\n";
      str += sequences.map(formatSequence).join("");
    }
    return str;
  }
  __name(formatSync, "formatSync");
  const _FormattingTransform = class _FormattingTransform extends streamBrowserify.Transform {
    constructor(options = {}) {
      super(Object.assign(options, { objectMode: true }));
      this.linesSinceLastSyncMark = 0;
      this.haveWeEmittedData = false;
      this.fastaMode = false;
      this.minLinesBetweenSyncMarks = options.minSyncLines || 100;
      this.insertVersionDirective = options.insertVersionDirective || false;
    }
    _transform(chunk, _encoding, callback) {
      let str;
      if (!this.haveWeEmittedData && this.insertVersionDirective) {
        const thisChunk = Array.isArray(chunk) ? chunk[0] : chunk;
        if ("directive" in thisChunk) {
          if (thisChunk.directive !== "gff-version") {
            this.push("##gff-version 3\n");
          }
        }
      }
      if ("sequence" in chunk && !this.fastaMode) {
        this.push("##FASTA\n");
        this.fastaMode = true;
      }
      if (Array.isArray(chunk))
        str = chunk.map(formatItem).join("");
      else
        str = formatItem(chunk);
      this.push(str);
      if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {
        this.push("###\n");
        this.linesSinceLastSyncMark = 0;
      } else {
        let count = 0;
        for (let i = 0; i < str.length; i += 1) {
          if (str[i] === "\n")
            count += 1;
        }
        this.linesSinceLastSyncMark += count;
      }
      this.haveWeEmittedData = true;
      _callback(callback);
    }
  };
  __name(_FormattingTransform, "FormattingTransform");
  let FormattingTransform = _FormattingTransform;
  function formatStream(options = {}) {
    return new FormattingTransform(options);
  }
  __name(formatStream, "formatStream");
  function formatFile(stream, writeStream, options = {}) {
    const newOptions = __spreadValues({
      insertVersionDirective: true
    }, options);
    return new Promise((resolve, reject) => {
      stream.pipe(new FormattingTransform(newOptions)).on("end", () => resolve(null)).on("error", reject).pipe(writeStream);
    });
  }
  __name(formatFile, "formatFile");
  const gff = {
    parseStream,
    parseStringSync,
    formatSync,
    formatStream,
    formatFile,
    util
  };
  function gffToJson(string) {
    const arrayOfThings = gff.parseStringSync(string);
    const results = [];
    const sequences = [];
    const features = {};
    arrayOfThings.forEach((featureOrSeq) => {
      if (featureOrSeq.sequence) {
        sequences.push(featureOrSeq);
      } else {
        const feature = featureOrSeq[0];
        if (!features[feature.seq_id])
          features[feature.seq_id] = [];
        const attributes = feature.attributes || {};
        const name = lodashExports.get(attributes, "ID[0]");
        features[feature.seq_id].push({
          name,
          start: feature.start,
          end: feature.end,
          strand: feature.strand === "+" ? 1 : -1,
          type: feature.type
        });
      }
    });
    sequences.forEach((sequence) => {
      const sequenceId = sequence.id;
      const result = {
        messages: [],
        success: true,
        parsedSequence: {
          name: sequenceId,
          sequence: sequence.sequence,
          circular: false,
          features: features[sequence.id]
        }
      };
      results.push(result);
    });
    return results;
  }
  __name(gffToJson, "gffToJson");
  function geneiousXmlToJson(string, options) {
    return __async(this, null, function* () {
      options = options || {};
      const onFileParsed = /* @__PURE__ */ __name(function(sequences) {
        return validateSequenceArray(sequences, options);
      }, "onFileParsed");
      try {
        const result = new fxp.XMLParser({
          isArray: () => true
        }).parse(string);
        const geneiousJsonMatches = searchWholeObjByNameSimpleArray(
          "geneiousDocument",
          result
        );
        const resultArray = [];
        if (!(geneiousJsonMatches == null ? void 0 : geneiousJsonMatches.length)) {
          return onFileParsed({
            success: false,
            messages: ["Error: XML is not valid geneious format"]
          });
        }
        lodashExports.forEach(geneiousJsonMatches, (geneiousJson) => {
          const response = {
            parsedSequence: null,
            messages: [],
            success: true
          };
          try {
            response.parsedSequence = parseGeneiousJson(geneiousJson, options);
            resultArray.push(response);
          } catch (e) {
            console.error("error:", e);
            console.error("error.stack: ", e.stack);
            resultArray.push({
              success: false,
              messages: ["Error while parsing Geneious format"]
            });
          }
        });
        const toRet = lodashExports.filter(resultArray, (r) => {
          var _a3, _b3;
          return (_b3 = (_a3 = r == null ? void 0 : r.parsedSequence) == null ? void 0 : _a3.sequence) == null ? void 0 : _b3.length;
        });
        if (toRet.length)
          return toRet;
        return onFileParsed(resultArray);
      } catch (e) {
        console.error(`e:`, e);
        return onFileParsed({
          success: false,
          messages: ["Error parsing geneious to JSON"]
        });
      }
    });
  }
  __name(geneiousXmlToJson, "geneiousXmlToJson");
  function parseGeneiousJson(geneiousJson) {
    const circular = searchWholeObjByNameSimple("isCircular", geneiousJson);
    let geneiousJsonInner = searchWholeObjByNameSimple(
      "originalElement",
      geneiousJson
    );
    geneiousJsonInner = searchWholeObjByNameSimple(
      "XMLSerialisableRootElement",
      geneiousJsonInner
    );
    const sequence = searchWholeObjByNameSimple(
      "charSequence",
      geneiousJsonInner
    );
    const features = lodashExports.flatMap(
      searchWholeObjByNameSimpleArray("annotation", geneiousJsonInner),
      function(feature) {
        if (feature) {
          const name2 = (searchWholeObjByNameSimple("description", feature) || "").substring(0, 255);
          const intervals = searchWholeObjByNameSimpleArray("interval", feature);
          const type = searchWholeObjByNameSimple("type", feature);
          const firstInterval = intervals[0];
          const lastInterval = intervals[intervals.length - 1];
          const start = searchWholeObjByNameSimple("minimumIndex", firstInterval) - 1;
          const end = searchWholeObjByNameSimple("maximumIndex", lastInterval) - 1;
          let locations;
          if (intervals.length > 1) {
            locations = intervals.map((i) => {
              const start2 = searchWholeObjByNameSimple("minimumIndex", i) - 1;
              const end2 = searchWholeObjByNameSimple("maximumIndex", i) - 1;
              return {
                start: start2,
                end: end2
              };
            });
          }
          const strand = searchWholeObjByNameSimple("direction", firstInterval) === "leftToRight" ? 1 : -1;
          const arrowheadType = searchWholeObjByNameSimple("direction", firstInterval) === "none" ? "NONE" : void 0;
          return {
            name: name2,
            type,
            locations,
            arrowheadType,
            start,
            end,
            strand
          };
        }
      }
    );
    const name = searchWholeObjByNameSimple("name", geneiousJsonInner);
    return {
      sequence,
      circular,
      name,
      features
    };
  }
  __name(parseGeneiousJson, "parseGeneiousJson");
  function jbeiXmlToJson(string, options) {
    return __async(this, null, function* () {
      options = options || {};
      const onFileParsed = /* @__PURE__ */ __name(function(sequences) {
        return validateSequenceArray(sequences, options);
      }, "onFileParsed");
      try {
        const res = new fxp.XMLParser({}).parse(string);
        const jbeiSeq = res["seq:seq"];
        const resultArray = [];
        if (!jbeiSeq) {
          return onFileParsed({
            success: false,
            messages: ["Error: XML is not valid jbei format"]
          });
        }
        const response = {
          parsedSequence: null,
          messages: [],
          success: true
        };
        try {
          response.parsedSequence = parseJbeiXml(jbeiSeq, options);
          resultArray.push(response);
        } catch (e) {
          console.error("error:", e);
          console.error("error.stack: ", e.stack);
          resultArray.push({
            success: false,
            messages: ["Error while parsing JBEI format"]
          });
        }
        const toRet = lodashExports.filter(resultArray, (r) => {
          var _a3, _b3;
          return (_b3 = (_a3 = r == null ? void 0 : r.parsedSequence) == null ? void 0 : _a3.sequence) == null ? void 0 : _b3.length;
        });
        if (toRet.length)
          return toRet;
        return onFileParsed(resultArray);
      } catch (e) {
        console.error(`e:`, e);
        return onFileParsed({
          success: false,
          messages: ["Error parsing jbei to JSON"]
        });
      }
    });
  }
  __name(jbeiXmlToJson, "jbeiXmlToJson");
  function parseJbeiXml(jbeiJson) {
    const {
      "seq:sequence": sequence,
      "seq:name": name,
      "seq:circular": circular,
      "seq:features": { "seq:feature": features }
    } = jbeiJson;
    return {
      sequence,
      circular,
      name,
      features: (Array.isArray(features) ? features : [features]).map(
        ({
          "seq:complement": complement,
          "seq:label": label,
          "seq:type": type,
          "seq:location": jbeiLocations
        }) => {
          let start, end;
          const locs = Array.isArray(jbeiLocations) ? jbeiLocations : [jbeiLocations];
          const locations = locs.map(
            ({ "seq:genbankStart": gbStart, "seq:end": normEnd }, i) => {
              if (i === 0)
                start = gbStart - 1;
              if (i === locs.length - 1)
                end = normEnd - 1;
              return {
                start: gbStart - 1,
                end: normEnd - 1
              };
            }
          );
          return {
            start,
            end,
            locations: locations.length > 1 ? locations : void 0,
            name: label,
            type,
            strand: complement ? -1 : 1
          };
        }
      )
    };
  }
  __name(parseJbeiXml, "parseJbeiXml");
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = /* @__PURE__ */ __name(function(eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
      for (var j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  }, "freb");
  var _a2 = freb(fleb, 2), fl = _a2.b, revfl = _a2.r;
  fl[28] = 258, revfl[258] = 28;
  var _b2 = freb(fdeb, 0), fd = _b2.b;
  var rev = new u16(32768);
  for (var i = 0; i < 32768; ++i) {
    var x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var hMap = /* @__PURE__ */ __name(function(cd, mb, r) {
    var s = cd.length;
    var i = 0;
    var l = new u16(mb);
    for (; i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          var sv = i << 4 | cd[i];
          var r_1 = mb - cd[i];
          var v = le[cd[i] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  }, "hMap");
  var flt = new u8(288);
  for (var i = 0; i < 144; ++i)
    flt[i] = 8;
  for (var i = 144; i < 256; ++i)
    flt[i] = 9;
  for (var i = 256; i < 280; ++i)
    flt[i] = 7;
  for (var i = 280; i < 288; ++i)
    flt[i] = 8;
  var fdt = new u8(32);
  for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = /* @__PURE__ */ __name(function(a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
      if (a[i] > m)
        m = a[i];
    }
    return m;
  }, "max");
  var bits = /* @__PURE__ */ __name(function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  }, "bits");
  var bits16 = /* @__PURE__ */ __name(function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  }, "bits16");
  var shft = /* @__PURE__ */ __name(function(p) {
    return (p + 7) / 8 | 0;
  }, "shft");
  var slc = /* @__PURE__ */ __name(function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    var n = new u8(e - s);
    n.set(v.subarray(s, e));
    return n;
  }, "slc");
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = /* @__PURE__ */ __name(function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  }, "err");
  var inflt = /* @__PURE__ */ __name(function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf || st.i != 2;
    var noSt = st.i;
    if (!buf)
      buf = new u8(sl * 3);
    var cbuf = /* @__PURE__ */ __name(function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    }, "cbuf");
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i = 0; i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i = 0; i < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (noBuf)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i = sym - 257, b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }
          bt = end;
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
  }, "inflt");
  var et = /* @__PURE__ */ new u8(0);
  var b2 = /* @__PURE__ */ __name(function(d, b) {
    return d[b] | d[b + 1] << 8;
  }, "b2");
  var b4 = /* @__PURE__ */ __name(function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
  }, "b4");
  var b8 = /* @__PURE__ */ __name(function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
  }, "b8");
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  __name(inflateSync, "inflateSync");
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
  var dutf8 = /* @__PURE__ */ __name(function(d) {
    for (var r = "", i = 0; ; ) {
      var c = d[i++];
      var eb = (c > 127) + (c > 223) + (c > 239);
      if (i + eb > d.length)
        return { s: r, r: slc(d, i - 1) };
      if (!eb)
        r += String.fromCharCode(c);
      else if (eb == 3) {
        c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
      } else if (eb & 1)
        r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
      else
        r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
  }, "dutf8");
  function strFromU8(dat, latin1) {
    if (latin1) {
      var r = "";
      for (var i = 0; i < dat.length; i += 16384)
        r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
      return r;
    } else if (td) {
      return td.decode(dat);
    } else {
      var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
      if (r.length)
        err(8);
      return s;
    }
  }
  __name(strFromU8, "strFromU8");
  var slzh = /* @__PURE__ */ __name(function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
  }, "slzh");
  var zh = /* @__PURE__ */ __name(function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a3 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a3[0], su = _a3[1], off = _a3[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
  }, "zh");
  var z64e = /* @__PURE__ */ __name(function(d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
      ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
  }, "z64e");
  function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558)
        err(13);
    }
    var c = b2(data, e + 8);
    if (!c)
      return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
      var ze = b4(data, e - 12);
      z = b4(data, ze) == 101075792;
      if (z) {
        c = b4(data, ze + 32);
        o = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    for (var i = 0; i < c; ++i) {
      var _a3 = zh(data, o, z), c_2 = _a3[0], sc = _a3[1], su = _a3[2], fn = _a3[3], no = _a3[4], off = _a3[5], b = slzh(data, off);
      o = no;
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_2
      })) {
        if (!c_2)
          files[fn] = slc(data, b, b + sc);
        else if (c_2 == 8)
          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
        else
          err(14, "unknown compression type " + c_2);
      }
    }
    return files;
  }
  __name(unzipSync, "unzipSync");
  function anyToJson(fileContentStringOrFileObj, options) {
    return __async(this, null, function* () {
      let fileContentString;
      options = options || {};
      let fileName = options.fileName || "";
      if (!fileName && typeof fileContentStringOrFileObj !== "string") {
        fileName = fileContentStringOrFileObj.name;
        options.fileName = fileName;
      }
      const ext = extractFileExtension(fileName);
      if (typeof fileContentStringOrFileObj === "string") {
        fileContentString = fileContentStringOrFileObj;
      } else {
        if (/^(ab1)$/.test(ext)) {
          return ab1ToJson(fileContentStringOrFileObj, options);
        } else if (/^(prot)$/.test(ext)) {
          return snapgeneToJson(fileContentStringOrFileObj, options);
        } else if (/^(dna)$/.test(ext)) {
          return snapgeneToJson(fileContentStringOrFileObj, options);
        } else if (/^(geneious)$/.test(ext)) {
          const a = yield getUint8ArrayFromFile(fileContentStringOrFileObj);
          let d;
          try {
            d = new TextDecoder().decode(a, { stream: false });
            if (!d.includes("<geneious")) {
              throw new Error("not geneious");
            }
          } catch (e) {
            const b = unzipSync(a);
            const c = Object.values(b)[0];
            d = new TextDecoder().decode(c, { stream: false });
          }
          return geneiousXmlToJson(d, options);
        } else {
          fileContentString = yield getUtf8StringFromFile(
            fileContentStringOrFileObj,
            options
          );
        }
      }
      if (/^(fasta|fas|fa|fna|ffn|faa)$/.test(ext)) {
        return fastaToJson(fileContentString, options);
      } else if (/^(gb|gbk)$/.test(ext)) {
        return genbankToJson(fileContentString, options);
      } else if (/^(seq)$/.test(ext) || /^(xml)$/.test(ext) && fileContentString.includes("seq:seq") && fileContentString.includes("jbei")) {
        return jbeiXmlToJson(fileContentString, options);
      } else if (/^(json)$/.test(ext)) {
        const failure = {
          messages: [`Unable to parse JSON file ${fileName}`],
          success: false
        };
        try {
          const cleaned = tidyUpSequenceData(
            JSON.parse(fileContentString),
            options
          );
          if (!cleaned.sequence.length)
            return [failure];
          return [{ parsedSequence: cleaned, success: true }];
        } catch (error) {
          console.error(`error:`, error);
          return [failure];
        }
      } else if (/^(gp|genpep)$/.test(ext)) {
        return genbankToJson(fileContentString, __spreadProps(__spreadValues({}, options), { isProtein: true }));
      } else if (/^(xml|rdf)$/.test(ext)) {
        return sbolXmlToJson(
          fileContentString || fileContentStringOrFileObj,
          options
        );
      } else if (/^(gff|gff3)$/.test(ext)) {
        return gffToJson(fileContentStringOrFileObj);
      } else {
        let parsersToTry = [
          {
            fn: genbankToJson,
            name: "Genbank Parser"
          },
          {
            fn: fastaToJson,
            name: "Fasta Parser"
          }
        ];
        const firstChar = fileContentString[fileContentString.search(/\S|$/)];
        if (firstChar === ">") {
          parsersToTry = parsersToTry.sort((a) => {
            if (a.name === "Fasta Parser")
              return -1;
            return 1;
          });
        } else if (firstChar === "L") {
          parsersToTry = parsersToTry.sort((a) => {
            if (a.name === "Genbank Parser")
              return -1;
            return 1;
          });
        }
        for (const parser of parsersToTry) {
          const toReturn = yield parser.fn(fileContentString, options);
          if (successfulParsing(toReturn)) {
            toReturn.forEach(function(result) {
              result.messages.push("Parsed using " + parser.name + ".");
            });
            return toReturn;
          }
        }
        return [
          {
            messages: [
              "Unable to parse file as FASTA, genbank, JBEI, or SBOL formats"
            ],
            success: false
          }
        ];
      }
      function successfulParsing(resultArray) {
        return resultArray.some(function(result) {
          return result.success;
        });
      }
      __name(successfulParsing, "successfulParsing");
    });
  }
  __name(anyToJson, "anyToJson");
  function getUtf8StringFromFile(file, { emulateBrowser } = {}) {
    if (!isBrowser && !emulateBrowser) {
      return Buffer.isBuffer(file) ? file.toString("utf-8") : Buffer.isBuffer(file.buffer) ? file.buffer.toString("utf-8") : file;
    }
    const reader = new window.FileReader();
    reader.readAsText(file, "UTF-8");
    return new Promise((resolve, reject) => {
      reader.onload = (evt) => {
        resolve(evt.target.result);
      };
      reader.onerror = (err2) => {
        console.error("err:", err2);
        reject(err2);
      };
    });
  }
  __name(getUtf8StringFromFile, "getUtf8StringFromFile");
  function getUint8ArrayFromFile(file, { emulateBrowser } = {}) {
    if (!isBrowser && !emulateBrowser) {
      return Buffer.isBuffer(file) ? new Uint8Array(file) : Buffer.isBuffer(file.buffer) ? new Uint8Array(file.buffer) : file;
    }
    const reader = new window.FileReader();
    reader.readAsArrayBuffer(file);
    return new Promise((resolve, reject) => {
      reader.onload = (evt) => {
        const arrayBuffer = evt.target.result;
        const bytes = new Uint8Array(arrayBuffer);
        resolve(bytes);
      };
      reader.onerror = (err2) => {
        console.error("err:", err2);
        reject(err2);
      };
    });
  }
  __name(getUint8ArrayFromFile, "getUint8ArrayFromFile");
  var colorString$1 = { exports: {} };
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  var simpleSwizzle = { exports: {} };
  var isArrayish$1 = /* @__PURE__ */ __name(function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  }, "isArrayish");
  var isArrayish2 = isArrayish$1;
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle$1 = simpleSwizzle.exports = /* @__PURE__ */ __name(function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (isArrayish2(arg)) {
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  }, "swizzle");
  swizzle$1.wrap = function(fn) {
    return function() {
      return fn(swizzle$1(arguments));
    };
  };
  var simpleSwizzleExports = simpleSwizzle.exports;
  var colorNames = colorName;
  var swizzle2 = simpleSwizzleExports;
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = /* @__PURE__ */ Object.create(null);
  for (var name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var cs = colorString$1.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val2;
    var model;
    switch (prefix) {
      case "hsl":
        val2 = cs.get.hsl(string);
        model = "hsl";
        break;
      case "hwb":
        val2 = cs.get.hwb(string);
        model = "hwb";
        break;
      default:
        val2 = cs.get.rgb(string);
        model = "rgb";
        break;
    }
    if (!val2) {
      return null;
    }
    return { model, value: val2 };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0; i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle2(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle2(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle2(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle2(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle2(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num, min, max2) {
    return Math.min(Math.max(min, num), max2);
  }
  __name(clamp, "clamp");
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }
  __name(hexDouble, "hexDouble");
  var colorStringExports = colorString$1.exports;
  const cssKeywords = colorName;
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert$2 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var conversions$2 = convert$2;
  for (const model of Object.keys(convert$2)) {
    if (!("channels" in convert$2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$2[model].labels.length !== convert$2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert$2[model];
    delete convert$2[model].channels;
    delete convert$2[model].labels;
    Object.defineProperty(convert$2[model], "channels", { value: channels });
    Object.defineProperty(convert$2[model], "labels", { value: labels });
  }
  convert$2.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max2 = Math.max(r, g, b);
    const delta = max2 - min;
    let h;
    let s;
    if (max2 === min) {
      h = 0;
    } else if (r === max2) {
      h = (g - b) / delta;
    } else if (g === max2) {
      h = 2 + (b - r) / delta;
    } else if (b === max2) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max2) / 2;
    if (max2 === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max2 + min);
    } else {
      s = delta / (2 - max2 - min);
    }
    return [h, s * 100, l * 100];
  };
  convert$2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = /* @__PURE__ */ __name(function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    }, "diffc");
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert$2.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert$2.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert$2.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return __pow(x[0] - y[0], 2) + __pow(x[1] - y[1], 2) + __pow(x[2] - y[2], 2);
  }
  __name(comparativeDistance, "comparativeDistance");
  convert$2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert$2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert$2.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? __pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? __pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? __pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert$2.rgb.lab = function(rgb) {
    const xyz = convert$2.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$2.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val2;
    if (s === 0) {
      val2 = l * 255;
      return [val2, val2, val2];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val2 = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val2 = t2;
      } else if (3 * t3 < 2) {
        val2 = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val2 = t1;
      }
      rgb[i] = val2 * 255;
    }
    return rgb;
  };
  convert$2.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert$2.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert$2.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert$2.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert$2.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert$2.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * __pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * __pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * __pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert$2.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? __pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? __pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? __pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert$2.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = __pow(y, 3);
    const x2 = __pow(x, 3);
    const z2 = __pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert$2.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert$2.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert$2.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert$2.hsv.ansi16 = function(args) {
    return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
  };
  convert$2.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert$2.ansi16.rgb = function(args) {
    let color2 = args % 10;
    if (color2 === 0 || color2 === 7) {
      if (args > 50) {
        color2 += 3.5;
      }
      color2 = color2 / 10.5 * 255;
      return [color2, color2, color2];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color2 & 1) * mult * 255;
    const g = (color2 >> 1 & 1) * mult * 255;
    const b = (color2 >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert$2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert$2.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$2.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString2 = match[0];
    if (match[0].length === 3) {
      colorString2 = colorString2.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString2, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert$2.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max2 = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max2 - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max2 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert$2.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert$2.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert$2.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert$2.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert$2.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert$2.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert$2.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert$2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert$2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert$2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert$2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert$2.gray.hsv = convert$2.gray.hsl;
  convert$2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert$2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert$2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert$2.gray.hex = function(gray) {
    const val2 = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val2 << 16) + (val2 << 8) + val2;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert$2.rgb.gray = function(rgb) {
    const val2 = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val2 / 255 * 100];
  };
  const conversions$1 = conversions$2;
  function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions$1);
    for (let len = models2.length, i = 0; i < len; i++) {
      graph[models2[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  __name(buildGraph, "buildGraph");
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions$1[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  __name(deriveBFS, "deriveBFS");
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  __name(link, "link");
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions$1[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions$1[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  __name(wrapConversion, "wrapConversion");
  var route$1 = /* @__PURE__ */ __name(function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for (let len = models2.length, i = 0; i < len; i++) {
      const toModel = models2[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  }, "route$1");
  const conversions = conversions$2;
  const route = route$1;
  const convert$1 = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = /* @__PURE__ */ __name(function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    }, "wrappedFn");
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  __name(wrapRaw, "wrapRaw");
  function wrapRounded(fn) {
    const wrappedFn = /* @__PURE__ */ __name(function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    }, "wrappedFn");
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  __name(wrapRounded, "wrapRounded");
  models.forEach((fromModel) => {
    convert$1[fromModel] = {};
    Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert$1[fromModel][toModel] = wrapRounded(fn);
      convert$1[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert$1;
  const colorString = colorStringExports;
  const convert = colorConvert;
  const skippedModels = [
    // To be honest, I don't really feel like keyword belongs in color convert, but eh.
    "keyword",
    // Gray conflicts with some method names, and has its own method defined.
    "gray",
    // Shouldn't really be in color-convert either...
    "hex"
  ];
  const hashedModelKeys = {};
  for (const model of Object.keys(convert)) {
    hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
  }
  const limiters = {};
  function Color(object, model) {
    if (!(this instanceof Color)) {
      return new Color(object, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === "string") {
      const result = colorString.get(object);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || "rgb";
      channels = convert[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
    } else if (typeof object === "number") {
      this.model = "rgb";
      this.color = [
        object >> 16 & 255,
        object >> 8 & 255,
        object & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object);
      if ("alpha" in object) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
      }
      const hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = convert[this.model];
      const color2 = [];
      for (i = 0; i < labels.length; i++) {
        color2.push(object[labels[i]]);
      }
      this.color = zeroArray(color2);
    }
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0; i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  __name(Color, "Color");
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to[self2.model](args);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = convert[this.model];
      const { labels } = convert[this.model];
      for (let i = 0; i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== void 0) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    // Rgb
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value) {
      if (value !== void 0) {
        return new Color(value);
      }
      return convert[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== void 0) {
        return new Color(value);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value) {
      if (value !== void 0) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : __pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0; i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === void 0 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(
        w1 * color1.red() + w2 * color2.red(),
        w1 * color1.green() + w2 * color2.green(),
        w1 * color1.blue() + w2 * color2.blue(),
        color1.alpha() * p + color2.alpha() * (1 - p)
      );
    }
  };
  for (const model of Object.keys(convert)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = convert[model];
    Color.prototype[model] = function(...args) {
      if (this.model === model) {
        return new Color(this);
      }
      if (args.length > 0) {
        return new Color(args, model);
      }
      return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color[model] = function(...args) {
      let color2 = args[0];
      if (typeof color2 === "number") {
        color2 = zeroArray(args, channels);
      }
      return new Color(color2, model);
    };
  }
  function roundTo(number, places) {
    return Number(number.toFixed(places));
  }
  __name(roundTo, "roundTo");
  function roundToPlace(places) {
    return function(number) {
      return roundTo(number, places);
    };
  }
  __name(roundToPlace, "roundToPlace");
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    }
    model = model[0];
    return function(value) {
      let result;
      if (value !== void 0) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  __name(getset, "getset");
  function maxfn(max2) {
    return function(v) {
      return Math.max(0, Math.min(max2, v));
    };
  }
  __name(maxfn, "maxfn");
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  __name(assertArray, "assertArray");
  function zeroArray(array, length) {
    for (let i = 0; i < length; i++) {
      if (typeof array[i] !== "number") {
        array[i] = 0;
      }
    }
    return array;
  }
  __name(zeroArray, "zeroArray");
  var color = Color;
  const color$1 = /* @__PURE__ */ getDefaultExportFromCjs(color);
  const StringUtil = {
    /** Trims white space at beginning and end of string
     * @param {string} line
     * @returns {string} line
     */
    trim: function(line) {
      return line.replace(/^\s+|\s+$/g, "");
    },
    /** Trims white space at beginning string
     * @param {string} line
     * @returns {string} line
     */
    ltrim: function(line) {
      return line.replace(/^\s+/, "");
    },
    /** Trims white space at end of string
     * @param {string} line
     * @returns {string} line
     */
    rtrim: function(line) {
      return line.replace(/\s+$/, "");
    },
    /** Pads white space at beginning of string
     * @param {string} line
     * @returns {string} line
     */
    lpad: function(line, padString, length) {
      let str = line;
      while (str.length < length)
        str = padString + str;
      return str;
    },
    /** Pads white space at end of string
     * @param {string} line
     * @returns {string} line
     */
    rpad: function(line, padString, length) {
      let str = line;
      while (str.length < length)
        str = str + padString;
      return str;
    }
  };
  const DIGEST_PART_EXPORT_FIELD_MAP = {
    isDigestPart: "isDigestPart",
    isDigestValid: "isDigestValid",
    "re5Prime.name": "re5PrimeName",
    "re5Prime.recognitionRegex": "re5PrimePattern",
    re5PrimeOverhang: "re5PrimeOverhang",
    re5PrimeOverhangStrand: "re5PrimeOverhangStrand",
    re5PrimeRecognitionTypeCode: "re5PrimeRecognitionTypeCode",
    "re3Prime.name": "re3PrimeName",
    "re3Prime.recognitionRegex": "re3PrimePattern",
    re3PrimeOverhang: "re3PrimeOverhang",
    re3PrimeOverhangStrand: "re3PrimeOverhangStrand",
    re3PrimeRecognitionTypeCode: "re3PrimeRecognitionTypeCode"
  };
  function cutUpArray(val2, start, end) {
    return val2.slice(start, end).join("");
  }
  __name(cutUpArray, "cutUpArray");
  function cutUpStr(val2, start, end) {
    return val2.slice(start, end);
  }
  __name(cutUpStr, "cutUpStr");
  function jsonToGenbank(_serSeq, options) {
    options = options || {};
    options.reformatSeqName = options.reformatSeqName !== false;
    const serSeq = lodashExports.cloneDeep(_serSeq);
    if (!serSeq)
      return false;
    try {
      if (serSeq.isProtein || serSeq.type === "protein" || serSeq.type === "AA") {
        serSeq.isProtein = true;
        serSeq.sequence = serSeq.proteinSequence || serSeq.sequence;
        options.isProtein = true;
      }
      let content = null;
      const cutUp = typeof serSeq.sequence === "string" ? cutUpStr : cutUpArray;
      if (!serSeq.sequence)
        serSeq.sequence = "";
      let lines = [];
      lines.push(createGenbankLocus(serSeq, options));
      if (serSeq.definition || serSeq.description) {
        lines.push(
          "DEFINITION  " + mangleOrStripUrls(serSeq.definition || serSeq.description, options)
        );
      }
      if (serSeq.accession) {
        lines.push("ACCESSION  " + serSeq.accession);
      }
      if (serSeq.version) {
        lines.push("VERSION  " + serSeq.version);
      }
      if (serSeq.extraLines) {
        lines = lines.concat(serSeq.extraLines);
      }
      if (serSeq.comments) {
        serSeq.comments.forEach(function(comment) {
          lines.push("COMMENT             " + comment);
        });
      }
      if (serSeq.teselagen_unique_id) {
        lines.push(
          "COMMENT             teselagen_unique_id: " + serSeq.teselagen_unique_id
        );
      }
      if (serSeq.library) {
        lines.push("COMMENT             library: " + serSeq.library);
      }
      let longestFeatureTypeLength = 15;
      serSeq.features = lodashExports.map(serSeq.features).concat(
        lodashExports.flatMap(pragmasAndTypes, ({ pragma, type }) => {
          return lodashExports.flatMap(serSeq[type], (ann) => {
            if (!lodashExports.isObject(ann)) {
              return [];
            }
            if (type === "primers") {
              ann.type = "primer_bind";
            }
            if (type === "parts" && ann.isDigestPart) {
              addDigestPartFieldsToNotes(ann);
            }
            ann.notes = pragma ? __spreadProps(__spreadValues({}, ann.notes), {
              pragma: [pragma]
            }) : ann.notes;
            return ann;
          });
        })
      );
      serSeq.features.forEach(({ type }) => {
        if (type && type.length > longestFeatureTypeLength) {
          longestFeatureTypeLength = type.length;
        }
      });
      let printedFeatureHeader;
      lodashExports.each(serSeq.features, function(feat) {
        if (!printedFeatureHeader) {
          printedFeatureHeader = true;
          lines.push("FEATURES             Location/Qualifiers");
        }
        lines.push(
          featureToGenbankString(feat, __spreadProps(__spreadValues({}, options), {
            featurePadLength: longestFeatureTypeLength + 1
          }))
        );
      });
      lines.push("ORIGIN      ");
      for (let i = 0; i < serSeq.sequence.length; i = i + 60) {
        const line = [];
        const ind = StringUtil.lpad("" + (i + 1), " ", 9);
        line.push(ind);
        for (let j = i; j < i + 60; j = j + 10) {
          line.push(cutUp(serSeq.sequence, j, j + 10));
        }
        lines.push(line.join(" "));
      }
      lines.push("//");
      content = lines.join("\r\n");
      return content;
    } catch (e) {
      console.warn("Error processing sequence << Check jsonToGenbank.js");
      console.warn(serSeq);
      console.warn(e.stack);
      return false;
    }
  }
  __name(jsonToGenbank, "jsonToGenbank");
  function createGenbankLocus(serSeq, options) {
    var _a3, _b3;
    if (serSeq.sequence.symbols) {
      serSeq.sequence = serSeq.sequence.symbols.split("");
    }
    let dnaType;
    if (serSeq.isProtein) {
      dnaType = "";
    } else if (serSeq.type === "RNA") {
      dnaType = (serSeq == null ? void 0 : serSeq.doubleStranded) ? "RNA" : (_a3 = serSeq == null ? void 0 : serSeq.sequenceTypeFromLocus) != null ? _a3 : "ss-RNA";
    } else {
      dnaType = (serSeq == null ? void 0 : serSeq.doubleStranded) ? "DNA" : (_b3 = serSeq == null ? void 0 : serSeq.sequenceTypeFromLocus) != null ? _b3 : "DNA";
    }
    const date = getCurrentDateString();
    let line = StringUtil.rpad("LOCUS", " ", 12);
    let nameToUse = serSeq.name || "Untitled_Sequence";
    nameToUse = options.reformatSeqName ? reformatName(nameToUse) : nameToUse;
    line += StringUtil.rpad(nameToUse, " ", 16);
    line += " ";
    line += StringUtil.lpad(String(serSeq.sequence.length), " ", 11);
    line += serSeq.isProtein ? " aa " : " bp ";
    const tmp = "";
    line += StringUtil.lpad(tmp, " ", 3);
    line += StringUtil.rpad(dnaType, " ", 6);
    line += "  ";
    if (!serSeq.circular || serSeq.circular === "0") {
      line += "linear  ";
    } else {
      line += "circular";
    }
    line += " ";
    line += StringUtil.rpad(serSeq.gbDivision || "SYN", " ", 1);
    line += " ";
    line += date;
    return line;
  }
  __name(createGenbankLocus, "createGenbankLocus");
  function getCurrentDateString() {
    let date = /* @__PURE__ */ new Date();
    date = date.toString().split(" ");
    const day = date[2];
    const month = date[1].toUpperCase();
    const year = date[3];
    return day + "-" + month + "-" + year;
  }
  __name(getCurrentDateString, "getCurrentDateString");
  function featureNoteInDataToGenbankString(name, value, options) {
    return StringUtil.lpad("/", " ", 22) + name + '="' + mangleOrStripUrls(value, options) + '"';
  }
  __name(featureNoteInDataToGenbankString, "featureNoteInDataToGenbankString");
  function featureToGenbankString(feat, options) {
    const lines = [];
    if (feat.type === "primer") {
      feat.type = "primer_bind";
    }
    const line = "     " + StringUtil.rpad(feat.type || "misc_feature", " ", options.featurePadLength);
    let locStr = "";
    if (feat.locations && feat.locations.length > 1) {
      feat.locations.forEach((loc, i) => {
        locStr += getProteinStart(
          parseInt(loc.start, 10) + (options.inclusive1BasedStart ? 0 : 1),
          options.isProtein
        ) + ".." + getProteinEnd(
          parseInt(loc.end, 10) + (options.inclusive1BasedEnd ? 0 : 1),
          options.isProtein
        );
        if (i !== feat.locations.length - 1) {
          locStr += ",";
        }
      });
      locStr = "join(" + locStr + ")";
    } else {
      locStr += getProteinStart(
        parseInt(feat.start, 10) + (options.inclusive1BasedStart ? 0 : 1),
        options.isProtein
      ) + ".." + getProteinEnd(
        parseInt(feat.end, 10) + (options.inclusive1BasedEnd ? 0 : 1),
        options.isProtein
      );
    }
    if (feat.strand === -1) {
      locStr = "complement(" + locStr + ")";
    }
    lines.push(line + locStr);
    lines.push(
      featureNoteInDataToGenbankString(
        "label",
        feat.name || "Untitled Feature",
        options
      )
    );
    if (feat.bases && feat.bases.length && feat.type === "primer_bind") {
      addToNotes(feat, "note", `sequence: ${feat.bases}`);
    }
    if (feat.primerBindsOn && feat.type === "primer_bind") {
      addToNotes(feat, "primerBindsOn", feat.primerBindsOn);
    }
    if (feat.overlapsSelf) {
      addToNotes(feat, "pragma", "overlapsSelf");
    }
    if (feat.arrowheadType) {
      const valToAdd = feat.arrowheadType.toUpperCase() === "BOTH" ? "BOTH" : feat.arrowheadType.toUpperCase() === "NONE" ? "NONE" : void 0;
      if (valToAdd)
        addToNotes(feat, "direction", valToAdd);
    }
    let notes = feat.notes;
    if (notes) {
      try {
        if (typeof notes === "string") {
          try {
            notes = JSON.parse(notes);
          } catch (e) {
            console.warn("Warning: Note incorrectly sent as a string.");
            notes = {};
          }
        }
        Object.keys(notes).forEach(function(key) {
          if (key === "color" || key === "labelColor")
            return;
          if (notes[key] instanceof Array) {
            notes[key].forEach(function(value) {
              lines.push(featureNoteInDataToGenbankString(key, value, options));
            });
          } else {
            console.warn("Warning: Note object expected array values");
            console.warn(notes);
          }
        });
      } catch (e) {
        console.warn("Warning: Note cannot be processed");
      }
    }
    feat.color = feat.notes && feat.notes.color || feat.color;
    feat.labelColor = feat.notes && feat.notes.labelColor || feat.labelColor;
    if (feat.color && color$1.rgb(feat.color).string() !== color$1.rgb(getFeatureToColorMap({ includeHidden: true })[feat.type]).string()) {
      lines.push(featureNoteInDataToGenbankString("color", feat.color, options));
    }
    if (feat.labelColor) {
      lines.push(
        featureNoteInDataToGenbankString("labelColor", feat.labelColor, options)
      );
    }
    return lines.join("\r\n");
  }
  __name(featureToGenbankString, "featureToGenbankString");
  function getProteinStart(val2, isProtein) {
    if (!isProtein)
      return val2;
    return Math.floor((val2 + 2) / 3);
  }
  __name(getProteinStart, "getProteinStart");
  function getProteinEnd(val2, isProtein) {
    if (!isProtein)
      return val2;
    return Math.floor(val2 / 3);
  }
  __name(getProteinEnd, "getProteinEnd");
  function addToNotes(ann, key, val2) {
    if (!ann.notes) {
      ann.notes = {};
    }
    if (!ann.notes[key]) {
      ann.notes[key] = [];
    }
    ann.notes[key].push(val2);
  }
  __name(addToNotes, "addToNotes");
  function addDigestPartFieldsToNotes(ann) {
    Object.entries(DIGEST_PART_EXPORT_FIELD_MAP).forEach(
      ([digestFieldPath, digestFieldName]) => {
        addToNotes(ann, digestFieldName, String(lodashExports.get(ann, digestFieldPath)));
      }
    );
  }
  __name(addDigestPartFieldsToNotes, "addDigestPartFieldsToNotes");
  function jsonToFasta(jsonSequence, options) {
    const cleanedData = tidyUpSequenceData(jsonSequence);
    const {
      name,
      circular,
      description,
      size,
      sequence,
      isProtein,
      proteinSize,
      proteinSequence
    } = cleanedData;
    options = options || {};
    let seqToUse = sequence;
    let sizeToUse = size;
    if (isProtein && proteinSequence) {
      seqToUse = proteinSequence;
      sizeToUse = proteinSize;
    }
    let fastaString = "";
    fastaString += `>${name || "Untitled Sequence"}|`;
    fastaString += "|" + sizeToUse;
    fastaString += description ? "|" + mangleOrStripUrls(description, options) : "";
    fastaString += "|" + (circular ? "circular" : "linear");
    fastaString += "\n";
    fastaString += (seqToUse.match(/.{1,80}/g) || []).join("\n");
    return fastaString;
  }
  __name(jsonToFasta, "jsonToFasta");
  function jsonToBed(jsonSequence, options = {}) {
    const sequenceInfo = options.featuresOnly ? jsonSequence : tidyUpSequenceData(jsonSequence);
    const { name, features, size, description, circular } = sequenceInfo;
    let sequenceNameToMatchFasta = "";
    sequenceNameToMatchFasta += `${name || "Untitled Sequence"}|`;
    sequenceNameToMatchFasta += "|" + size;
    sequenceNameToMatchFasta += description ? "|" + description : "";
    sequenceNameToMatchFasta += "|" + (circular ? "circular" : "linear");
    const sequenceNameToUse = options.sequenceName || sequenceNameToMatchFasta;
    let outString = "";
    outString += `track name="${sequenceNameToUse}" description="${name} Annotations" itemRgb="On"
`;
    features.forEach(function(feat) {
      const { start, end, name: name2, type, forward, strand } = feat;
      const label = name2 ? name2 : type;
      let orientation;
      if (forward || strand === 1) {
        orientation = "+";
      } else if (!forward || strand === -1) {
        orientation = "-";
      } else {
        orientation = ".";
      }
      const color2 = type === "CDS" ? "230,88,0" : "";
      outString += `${sequenceNameToUse}	${start}	${end + 1}	${label}		${orientation}			${color2}
`;
    });
    return outString;
  }
  __name(jsonToBed, "jsonToBed");
  function cleanUpTeselagenJsonForExport(tgJson) {
    const seqData = lodashExports.cloneDeep(tgJson);
    if (!seqData)
      return seqData;
    delete seqData.cutsites;
    delete seqData.orfs;
    lodashExports.forEach(seqData.translations, (t) => {
      delete t.aminoAcids;
    });
    return seqData;
  }
  __name(cleanUpTeselagenJsonForExport, "cleanUpTeselagenJsonForExport");
  function parseUracilFeatures(sequenceBps, featureList = []) {
    const cleanedBps = sequenceBps.replace(/u/gi, (u, index) => {
      featureList.push({
        type: "misc_feature",
        name: "tg_uracil",
        strand: 1,
        start: index,
        end: index
      });
      return u === "U" ? "T" : "t";
    });
    return cleanedBps;
  }
  __name(parseUracilFeatures, "parseUracilFeatures");
  function jsonToJsonString(incomingJson) {
    return JSON.stringify(
      lodashExports.omit(
        cleanUpTeselagenJsonForExport(
          tidyUpSequenceData(incomingJson, { annotationsAsObjects: false })
        ),
        [
          "sequenceFragments",
          "sequenceFeatures",
          "cutsites",
          "orfs",
          "filteredParts",
          "filteredFeatures"
        ]
      )
    );
  }
  __name(jsonToJsonString, "jsonToJsonString");

  CGVParse.anyToTeselagen = anyToJson;


  CGVParse.SequenceFile = SequenceFile;

  return CGVParse;

})();
