var CGParse=function(){"use strict";class e{constructor(e={}){this.options=e,this.logToConsole=void 0===e.logToConsole||e.logToConsole,this.showTimestamps=void 0===e.showTimestamps||e.showTimestamps,this.showIcons=void 0!==e.showIcons&&e.showIcons,this.maxLogCount=void 0!==e.maxLogCount&&e.maxLogCount,this.logs=[]}get count(){return this.logs.length}log(e,t={}){this._log(e,"log",t)}info(e,t={}){this._log(e,"info",t)}warn(e,t={}){this._log(e,"warn",t)}error(e,t={}){this._log(e,"error",t)}break(e="\n"){const t={type:"break",break:e};this.logs.push(t)}history(e={}){let t="";for(const s of this.logs)"message"===s.type?t+=`${this._formatMessage(s,e)}\n`:"break"===s.type&&(t+=s.break);return t}_log(e,t,s={}){const i=this._formatTime(new Date);e=Array.isArray(e)?e:[e];const n=this._optionFor("maxLogCount",s);let r;for(const[o,a]of e.entries()){if(n&&o>=n&&o!==e.length-1){r=`${e[0].match(/^\s*/)[0]}- Only showing first ${n}: ${e.length-n} more not shown (${e.length.toLocaleString()} total)`}const l={type:"message",message:r||a,level:t,timestamp:i,icon:s.icon};if(this.logs.push(l),this._consoleMessage(l,s),r)break}}_consoleMessage(e,t={}){this._optionFor("logToConsole",t)&&console[e.level](this._formatMessage(e,t))}_formatMessage(e,t={}){let s="";if(this._optionFor("showIcons",t)){const t=e.icon||e.level;s+=this._icon(t)+""}return this._optionFor("showTimestamps",t)&&(s+=`[${e.timestamp}] `),s+=e.message,s}_formatTime(e){return e.toLocaleTimeString("en-US",{hour:"2-digit",minute:"2-digit",second:"2-digit",timeZone:"UTC",hour12:!1})}_icon(e){const t={log:"ðŸ“",info:"â„¹ï¸",warn:"âš ï¸",error:"ðŸ›‘",success:"âœ…",fail:"ðŸ›‘",none:" "};return e?t[e]||e:t.none}_optionFor(e,t={}){return void 0!==t[e]?t[e]:this[e]}}const t=["allele","altitude","anticodon","artificial_location","bio_material","bound_moiety","cell_line","cell_type","chromosome","circular_RNA","citation","clone","clone_lib","codon_start","collected_by","collection_date","compare","country","cultivar","culture_collection","db_xref","dev_stage","direction","EC_number","ecotype","environmental_sample","estimated_length","exception","experiment","focus","frequency","function","gap_type","gene","gene_synonym","germline","haplogroup","haplotype","host","identified_by","inference","isolate","isolation_source","lab_host","lat_lon","linkage_evidence","locus_tag","macronuclear","map","mating_type","metagenome_source","mobile_element_type","mod_base","mol_type","ncRNA_class","note","number","old_locus_tag","operon","organelle","organism","partial","PCR_conditions","PCR_primers","phenotype","plasmid","pop_variant","product","protein_id","proviral","pseudo","pseudogene","rearranged","ination_class","tory_class","replace","ribosomal_slippage","rpt_family","rpt_type","rpt_unit_range","rpt_unit_seq","satellite","segment","serotype","serovar","sex","specimen_voucher","standard_name","strain","sub_clone","submitter_seqid","sub_species","sub_strain","tag_peptide","tissue_lib","tissue_type","transgenic","translation","transl_except","transl_table","trans_splicing","type_material","variety"],s={"SO:0000704":"gene","SO:0000234":"mRNA","SO:0000147":"exon","SO:0000316":"CDS","SO:0000188":"intron","SO:0000610":"polyA_sequence","SO:0000553":"polyA_site","SO:0000204":"five_prime_UTR","SO:0000205":"three_prime_UTR"};function i(e){return e.replace(/\s+/g,"")}function n(e){return e.replace(/\d+/g,"")}function r(e){return e.replace(/\r\n?/g,"\n")}function o(e){let t="";for(let s=e.length-1;s>=0;s--)t+=e[s];return t}function a(e){let t=!1;const s=e.slice(0,512);let i=0,n=0;if(s.length>=3&&239===s.charCodeAt(0)&&187===s.charCodeAt(1)&&191===s.charCodeAt(2))t=!1;else{for(let e=0;e<s.length;e++){const t=s.charCodeAt(e);t>=32&&t<=126||9===t||10===t||13===t?i++:t<32&&9!==t&&10!==t&&13!==t&&n++}(i/0<.8||n/0>.1)&&(t=!0)}return t}function l(e){const t={A:"T",C:"G",G:"C",T:"A",U:"A",R:"Y",Y:"R",S:"S",W:"W",K:"M",M:"K",B:"V",D:"H",H:"D",V:"B",N:"N",a:"t",c:"g",g:"c",t:"a",u:"a",r:"y",y:"r",s:"s",w:"w",k:"m",m:"k",b:"v",d:"h",h:"d",v:"b",n:"n"};return e.split("").map((e=>t[e]||e)).join("")}function c(e){let t;const s=e.length;if(h(e,"ATGC")/s>.9)t="dna";else{t=h(e,"ACDEFGHIKLMNPQRSTVWY")/s>.9?"protein":"unknown"}return t}function u(e,t){const s=t.toLowerCase();let i;if("dna"===s){const t=e.replace(/[AGCTURYSWKMBDHVN\-\.]/gi,"");t.length>0&&(i=Array.from(new Set([...t])).join(","))}else if("protein"===s){const t=e.replace(/[ARNDCQEGHILKMFPOSUTWYVBZJ\-\.\*]/gi,"");t.length>0&&(i=Array.from(new Set([...t])).join(","))}return i}function h(e,t){const s=e.toUpperCase(),i=new Set(t.split(""));let n=0;for(let e=0,t=s.length;e<t;e++)i.has(s[e])&&n++;return n}class g{constructor(t,s={}){this.version="1.6.0",this.options=s,this.logger=s.logger||new e,s.maxLogCount&&(this.logger.maxLogCount=s.maxLogCount),this._success=!0,this._status="success",this.includeFeatures=void 0===s.includeFeatures||s.includeFeatures,this.excludeFeatures=s.excludeFeatures||["gene","source","exon"],this.includeQualifiers=s.includeQualifiers||!1,this.excludeQualifiers=s.excludeQualifiers||[],this.includeCaption=void 0===s.includeCaption||s.includeCaption,this.seqFile=this._parseInput(t),this.inputType=this.seqFile.inputType,this.sequenceType=this.seqFile.sequenceType,!0===this.seqFile.success?this._json=this._convert(this.seqFile.records):this._fail("*** Cannot convert to CGView JSON because parsing sequence file failed ***")}get status(){return this._status}get success(){return"success"===this.status}get passed(){return"success"===this.status||"warnings"===this.status}_fail(e){this.logger.error(e),this._status="fail"}_warn(e){this.logger.warn(e),"fail"!==this.status&&(this._status="warnings")}_parseInput(e){return"string"==typeof e?new f(e,{logger:this.logger}):e instanceof f?e:void this._fail("Invalid input: must be a string (from GenBank, EMBL, FASTA, Raw) or SequenceFile object")}_convert(e){if(this._skippedFeaturesByType={},this._skippedComplexFeatures=[],this._complexFeatures=[],this._skippedLocationlessFeatures=[],this.logger.info(`Date: ${(new Date).toUTCString()}`),this.logger.info("Converting to CGView JSON..."),this.logger.info(`- CGView JSON version ${this.version}`),this.logger.info(`- Input Sequence Count: ${e.length}`),this.logger.info(`- Input File Type: ${this.inputType||"Unknown"}`),this.logger.info(`- Input Sequence Type: ${this.sequenceType||"Unknown"}`),!e||e.length<1)return void this._fail("Conversion Failed: No sequence records provided");if("dna"!==this.sequenceType?.toLowerCase())return void this._fail(`Conversion Failed: Input type is not DNA: '${this.sequenceType}'`);let t=this._addConfigToJSON({},this.options.config);return t.version=this.version,this._adjustContigNames(e),t.captions=this._getCaptions(t,e),t.settings.format=g.determineFormat(e),t=this._extractSequenceAndFeatures(t,e),this._summarizeSkippedFeatures(),this._adjustFeatureGeneticCode(t),this._qualifiersSetup(),this._complexFeatures.length>0&&this.logger.info(`- Complex Features Found: ${this._complexFeatures.length.toLocaleString()}`),t.name=e[0]?.definition||e[0]?.name||e[0]?.seqID||"Untitled",t=this._removeUnusedLegends(t),t.tracks=this._buildTracks(t,this.inputType),this._convertSummary(t),{cgview:t}}_getCaptions(e,t){const s=e.captions?[...e.captions]:[];if(this.includeCaption){this.logger.info("- Adding caption...");const e={name:t[0]?.definition||t[0].seqID||"Untitled",textAlignment:"center",font:"sans-serif,plain,24",fontColor:"darkblue",position:"bottom-center"};s.push(e)}return s}_convertSummary(e){const t=e.sequence?.contigs||[],s=t.length||0,i=e.features?.length||0,n=e.tracks?.length||0,r=e.legend?.items?.length||0,o=t.map((e=>e.length)).reduce(((e,t)=>e+t),0);let a=Object.values(this._skippedFeaturesByType).reduce(((e,t)=>e+t),0);a+=this._skippedComplexFeatures.length,a+=this._skippedLocationlessFeatures.length,this.logger.break("--------------------------------------------\n"),this.logger.info("CGView JSON Summary:"),this.logger.info(`- Map Name: ${e.name.padStart(19)}`),this.logger.info(`- Contig Count: ${s.toLocaleString().padStart(15)}`),this.logger.info("- Total Length (bp): "+`${o.toLocaleString()}`.padStart(10)),this.logger.info(`- Track Count: ${n.toLocaleString().padStart(16)}`),this.logger.info(`- Legend Count: ${r.toLocaleString().padStart(15)}`),this.logger.info(`- Features Included: ${i.toLocaleString().padStart(10)}`),this.logger.info(`- Features Skipped: ${a.toLocaleString().padStart(11)}`),this.success?this.logger.info("- Status: "+"Success".padStart(21),{icon:"success"}):"warnings"===this.status?this.logger.warn("- Status: "+"Warnings".padStart(21),{icon:"warn"}):this.logger.error("- Status: "+"FAILED".padStart(21),{icon:"fail"}),this.logger.break("--------------------------------------------\n")}_summarizeSkippedFeatures(){const e=this._skippedFeaturesByType,t=Object.values(this._skippedFeaturesByType).reduce(((e,t)=>e+t),0);if(Object.keys(e).length>0){this.logger.info(`- Skipped features (${t}) by type:`);for(const[t,s]of Object.entries(e))this.logger.info(`  - ${t}: ${s.toLocaleString().padStart(15-t.length)}`)}const s=this._skippedComplexFeatures,i=s.length;if(i>0){this.logger.info(`- Skipped features (${i}) with complex locations:`);const e=s.map((e=>`  - ${e.type} '${e.name}': ${e.locationText}`));this.logger.info(e)}const n=this._skippedLocationlessFeatures,r=n.length;if(r>0){this._warn(`- Skipped features (${r}) with missing locations:`);const e=n.map((e=>`  - ${e.type} '${e.name}': ${e.locationText}`));this._warn(e)}}_addConfigToJSON(e,t){const s=t?Object.keys(t):["none"];return this.logger.info(`- Config properties provided: ${s.join(", ")}`),e.settings=t&&t.settings?t.settings:{},e.backbone=t&&t.backbone?t.backbone:{},e.ruler=t&&t.ruler?t.ruler:{},e.dividers=t&&t.dividers?t.dividers:{},e.annotation=t&&t.annotation?t.annotation:{},e.sequence=t&&t.sequence?t.sequence:{},e.legend=t&&t.legend?t.legend:{},e.tracks=t&&t.tracks?t.tracks:[],e}_adjustContigNames(e){const t=e.map((e=>e.name)),s=g.adjustContigNames(t),i=s.names,n=s.reasons;this.logger.info("- Checking contig names...");const r=Object.keys(n);if(r.length>0){e.forEach(((e,t)=>{e.name=i[t]})),this._warn(`The following contig names (${r.length}) were adjusted:`),this._warn("Reasons: DUP (duplicate), LONG (>34), REPLACE (nonstandard characters), BLANK (empty)");const t=[];r.forEach((e=>{const s=n[e];t.push(`- [${s.index+1}] ${s.origName} -> ${s.newName} (${s.reason.join(", ")})`)})),this._warn(t)}}_adjustFeatureGeneticCode(e){const t=e.features;if(!t||t.length<1)return;const s=t.filter((e=>"CDS"===e.type));if(!s||s.length<1)return;const i=s.map((e=>e.geneticCode)),n={};i.forEach((e=>{n[e]=n[e]?n[e]+1:1}));let r=Object.keys(n).reduce(((e,t)=>n[e]>n[t]?e:t));this.logger.info(`- Most common genetic code (transl_table): ${r} (Count: ${n[r]}/${s.length} CDS features}`),Object.keys(n).length>1&&this._warn(`- Additional genetic codes found: ${Object.keys(n).join(", ")}`),e.settings.geneticCode=parseInt(r),e.features.forEach((e=>{"CDS"===e.type&&e.geneticCode===parseInt(r)&&delete e.geneticCode}))}static determineFormat(e=[]){return e.length>1?"circular":"linear"===e[0]?.topology?"linear":"circular"}static adjustContigNames(e=[]){const t={};let s=e.map((e=>e.replace(/[^a-zA-Z0-9\*\_\-]+/g,"_")));e.forEach(((e,i)=>{e!==s[i]&&(t[i]={index:i,origName:e,newName:s[i],reason:["REPLACE"]})})),s.forEach(((e,i)=>{const n="Unknown";""===e&&(s[i]=n,t[i]={index:i,origName:e,newName:n,reason:["BLANK"]})})),s.forEach(((e,i)=>{e.length>34&&(s[i]=e.slice(0,34),t[i]?(t[i].newName=s[i],t[i].reason.push("LONG")):t[i]={index:i,origName:e,newName:s[i],reason:["LONG"]})}));const i=[];return s.forEach(((e,s)=>{const n=function(e,t){return t.includes(e)?function(e,t,s){let i;do{i=e+t,t++}while(s.indexOf(i)>-1);return i}(`${e}-`,2,t):e}(e,i);i.push(n),n!==e&&(t[s]?(t[s].newName=n,t[s].reason.push("DUP")):t[s]={index:s,origName:e,newName:n,reason:["DUP"]})})),{names:i,reasons:Object.values(t)}}_extractSequenceAndFeatures(e,t){const s=[],i=[];return this._featureTypesSetup(),t.forEach((e=>{s.push({name:e.name,length:e.sequence.length,seq:e.sequence});const t=this._extractFeatures(e,e.name,e.inputType);i.push(...t)})),e.sequence={contigs:s},e.features=i,e}_featureTypesSetup(){const e=this._setupInExcludeItems("Feature types",this.includeFeatures,this.excludeFeatures);this.featuresToInclude=e.itemsToInclude,this.featuresToExclude=e.itemsToExclude}_qualifiersSetup(){const e=this._setupInExcludeItems("Qualifier",this.includeQualifiers,this.excludeQualifiers);this.includeQualifiers=e.itemsToInclude,this.excludeQualifiers=e.itemsToExclude}_setupInExcludeItems(e,t,s){let i=[],n=[];return!0===t?(i=!0,Array.isArray(s)?(n=s,n.length>0?this.logger.info(`- ${e} to exclude: ${n.join(", ")}`):this.logger.info(`- ${e} to include: All`)):this.logger.info(`- ${e} to include: All`)):Array.isArray(t)?(i=t,i.length>0?this.logger.info(`- ${e} to include: ${i.join(", ")}`):this.logger.info(`- ${e} to include: None`)):(i=[],this.logger.info(`- ${e} to include: None`)),{itemsToInclude:i,itemsToExclude:n}}_buildTracks(e,t){const s=e.tracks||[];return e.features&&e.features.length>0&&s.push({name:"Features",separateFeaturesBy:"strand",position:"both",dataType:"feature",dataMethod:"source",dataKeys:`${t}-features`}),s}_removeUnusedLegends(e){const t=e.legend?.items||[];if(0===t.length)return e;const s=e.features?.map((e=>e.legend))||[],i=[...new Set(s)],n=t.filter((e=>i.includes(e.name)));return e.legend.items=n,e}_extractFeatures(e,t,s){const i=[],n=s?`${s}-features`:"features";for(const s of e.features){if(this.featuresToExclude.includes(s.type)){this._skippedFeaturesByType[s.type]=this._skippedFeaturesByType[s.type]?this._skippedFeaturesByType[s.type]+1:1;continue}if(Array.isArray(this.featuresToInclude)&&!this.featuresToInclude.includes(s.type)){this._skippedFeaturesByType[s.type]=this._skippedFeaturesByType[s.type]?this._skippedFeaturesByType[s.type]+1:1;continue}if(s.locations.length<1){this._skippedLocationlessFeatures.push(s);continue}const e={start:s.start,stop:s.stop,strand:s.strand,name:s.name,type:s.type,contig:t,source:n,legend:s.type};if(s.locations.length>1&&(e.locations=s.locations,this._complexFeatures.push(s)),s.qualifiers&&s.qualifiers.codon_start&&1!==parseInt(s.qualifiers.codon_start[0])&&(e.codonStart=parseInt(s.qualifiers.codon_start[0])),"CDS"===e.type){const t=s.qualifiers&&s.qualifiers.transl_table&&parseInt(s.qualifiers.transl_table[0]);e.geneticCode=t||1}const r=g.extractQualifiers(s.qualifiers,this.includeQualifiers,this.excludeQualifiers);r&&(e.qualifiers=r),i.push(e)}return i}static extractQualifiers(e,t,s){let i={};if(!0===t&&e)if(Array.isArray(s)&&s.length>0){const t={...e};s.forEach((e=>{delete t[e]})),i=t}else i=e;else Array.isArray(t)&&t.forEach((t=>{void 0!==e[t]&&(i[t]=e[t])}));if(Object.keys(i).length>0)return i}toJSON(){return this._json}static fromSequenceText(t,s){const i=new e({logToConsole:!1,showIcons:!0}),n=new g(t,{logger:i,...s});return{json:n.toJSON(),log:n.logger.history()}}}class p{static toCGViewJSON(t,s={}){const i=new e({logToConsole:!1});return new p(t,{logger:i,...s}).toCGViewJSON()}constructor(t,s={}){const i=r(t);this.logger=s.logger||new e,s.logger=this.logger,s.maxLogCount&&(this.logger.maxLogCount=s.maxLogCount),this.nameKeys=s.nameKeys||["gene","locus_tag","product","note","db_xref"],this.logger.info(`Date: ${(new Date).toUTCString()}`),this._success=!0,this._status="success",this._records=[],this._errorCodes=new Set,i&&""!==i?a(i)?this._fail("Parsing Failed: Input contains non-text characters. Is this binary data?","binary"):(this._records=this._parse(i,s),s.addFeatureSequences&&this._addFeatureSequence(this._records),this._determineSequenceTypes(this._records),this._determineOverallInputAndSequenceType(this._records),this.logger.info("- done parsing sequence file"),this._validateRecords(this._records),this.parseSummary()):this._fail("Parsing Failed: No input text provided.","empty"),this.logger.break()}get status(){return this._status}get success(){return"success"==this.status}get inputType(){return this._inputType}get sequenceType(){return this._sequenceType}get summary(){return this._summary}get errorCodes(){return Array.from(this._errorCodes)}toCGViewJSON(e={}){if(this.success){e.logger=e.logger||this.logger;return new g(this,e).toJSON()}this.logger.error("*** Cannot convert to CGView JSON because parsing failed ***")}get records(){return this._records}parseSummary(){const e=this.records,t=e.map((e=>e.features)).flat(),s=e.map((e=>e.length)).reduce(((e,t)=>e+t),0);this.logger.break("--------------------------------------------\n"),this.logger.info("Parsing Summary:"),this.logger.info(`- Input file type: ${this.inputType.padStart(12)}`),this.logger.info(`- Sequence Type: ${this.sequenceType.padStart(14)}`),this.logger.info(`- Sequence Count: ${e.length.toLocaleString().padStart(13)}`),this.logger.info(`- Feature Count: ${t.length.toLocaleString().padStart(14)}`),this.logger.info("- Total Length (bp): "+`${s.toLocaleString()}`.padStart(10)),this.success?this.logger.info("- Status: "+"Success".padStart(21),{icon:"success"}):this.logger.error("- Status: "+"FAILED".padStart(21),{icon:"fail"}),this.logger.break("--------------------------------------------\n"),this._summary={inputType:this.inputType,sequenceType:this.sequenceType,sequenceCount:e.length,featureCount:t.length,totalLength:s,status:this.status,success:this.success}}_parse(e,t={}){this.logger.info("Parsing sequence file...");let s=this._parseGenbankOrEmbl(e,t);return(0===s.length||""===s[0].name&&0===s[0].length&&""===s[0].sequence)&&(this.logger.info("- empty results"),/^\s*>/.test(e)?(this.logger.info("- attempting as FASTA..."),s=this._parseFasta(e,t)):(this.logger.info("- attempting as raw..."),s=this._parseRaw(e,t))),s}_parseGenbankOrEmbl(e,t={}){const s=[];return this.logger.info("- attempting as GenBank or EMBL..."),this.logger.info("- name extraction keys: "+this.nameKeys.join(", ")),e.split(/^\/\//m).filter(this._isSeqRecord).forEach((e=>{const t={inputType:"unknown"};/^\s*LOCUS|^\s*FEATURES/m.test(e)?t.inputType="genbank":/^\s*ID|^\s*SQ/m.test(e)&&(t.inputType="embl"),t.name=this._getSeqName(e),t.seqID=this._getSeqID(e),t.definition=this._getSeqDefinition(e),t.length=this._getSeqLength(e),t.topology=this._getSeqTopology(e),t.comments=this._getSeqComments(e),t.sequence=this._getSequence(e),t.length||(t.length=t.sequence.length),t.features=this._getFeatures(e),s.push(t)})),s}_parseFasta(e,t={}){const s=[];return e.split(/^\s*>/m).filter(this._isSeqRecord).forEach((e=>{const t={inputType:"fasta",name:"",length:0,sequence:""},r=e.match(/^([^\n\r]*)(.*)/s);if(r&&(t.name=r[1].trim(),t.sequence=i(n(r[2])),t.length=t.sequence.length,t.features=[],""!==t.name)){const e=t.name.match(/^(\S+)\s*(.*)/);e&&(t.seqID=e[1],t.definition=e[2])}s.push(t)})),s}_parseRaw(e,t={}){const s={inputType:"raw",name:"",features:[]};return s.sequence=i(n(e)),s.length=s.sequence.length,[s]}_isSeqRecord(e){return!/^\s*\/\/\s*$/.test(e)&&!/^\s*$/.test(e)}_getSeqName(e){const t=e.match(/^\s*(?:LOCUS|ID)\s*(\S+)/);if(t){let e=t[1];return e=e.replace(/;$/,""),e}return""}_getSeqID(e){let t=e.match(/^\s*(?:VERSION)\s*(\S+)/m);if(t){return t[1]}if(t=e.match(/^\s*AC\s*(\S+);/m),t){let s,i=t[1];return t=e.match(/^\s*ID\s*(\S+);\s*SV\s*(\d+);/),t&&(s=t[2]),s?`${i}.${s}`:i}return""}_getSeqDefinition(e){const t=e.match(/^\s*(?:DEFINITION|DE)\s+(.+)$/m);if(t){return t[1]}return""}_getSeqLength(e){const t=e.match(/^\s*(?:LOCUS|ID).*?(\d+)\s[Bb][Pp]/);return t?parseInt(t[1]):0}_getSeqTopology(e){const t=e.match(/^\s*(?:LOCUS|ID)\s*\S+\s+.*(linear|circular)/);return t?this.topology=t[1]:"unknown"}_getSeqComments(e){let t=e.match(/^\s*COMMENT\s+(.*)\nFEATURES/ms),s="";return t?(s=t[1],s=s.replace(/^\s*/gm,"")):(t=e.match(/^\s*CC\s+(.*)\nXX/ms),t&&(s=t[1],s=s.replace(/^\s*CC\s*/gm,""))),s}_getSequence(e){const t=e.match(/^(?:ORIGIN|SQ\s{3}).*?$([^\/]*)(^\s*$|^\s*LOCUS)?/m);return t?n(i(t[1])):""}_getFeatures(e){const t=[],s=e.match(/^(?:FEATURES.*?$|FH.*?^FH.*?$)(.*)^(?:ORIGIN|SQ\s{3}).*?$/ms);if(s){let e=s[1];e=e.replaceAll(/^FT/gm,"  "),e.split(/(?=^\s{5}\S+)/m).filter(this._isFeatureRecord).forEach((e=>{const s={};s.type=this._getFeatureType(e),s.strand=this._getFeatureStrand(e),s.locationText=this._getFeatureLocationText(e),s.locations=this._getFeatureLocations(s.locationText),s.start=s.locations.map((e=>e[0])).sort(((e,t)=>e-t))[0],s.stop=s.locations.map((e=>e[1])).sort(((e,t)=>t-e))[0],s.qualifiers=this._getFeatureQualifiers(e),s.name=this._getFeatureName(s.qualifiers),s.type&&t.push(s)}))}return t}_isFeatureRecord(e){return!/^\s*\/\s*$/.test(e)&&!/^\s*$/.test(e)}_getFeatureType(e){const t=e.match(/^\s{5}(\S+)/);return t?t[1]:null}_getFeatureStrand(e){return e.match(/^\s{5}\S+\s+complement/)?-1:1}_getFeatureLocationText(e){const t=e.match(/^\s{5}\S+\s+([^\/]+)/s);return t?i(t[1]):""}_getFeatureLocations(e){const t=[],s=e.split(/(?=,)/).filter(this._isParsableFeatureRange);for(const e of s){let s=e.match(/(\d+)\D*\.\.\D*(\d+)/);if(s){const e=parseInt(s[1]),i=parseInt(s[2]);t.push([e,i])}else if(s=e.match(/(\d+)/),s){const e=parseInt(s[1]),i=e;t.push([e,i])}}return t}_isParsableFeatureRange(e){return!/\d\.\d/.test(e)&&(!/\^/.test(e)&&(!/:/.test(e)&&!/^\s*$/.test(e)))}_isFeatureQualifier(e){return!/^\s*\/\s*$/.test(e)&&!/^\s*$/.test(e)}_formatFeatureQualifier(e){return/\S\s\S/.test(e)?e.replace(/[\s]+/g," "):e.replace(/[\s]+/g,"")}_getFeatureQualifiers(e){const t={};let s=e.match(/(\/.*)/s);if(s){s[1].split(/(?=^\s*\/)/m).filter(this._isFeatureQualifier).forEach((e=>{let n,r;s=e.match(/\/([^\"\s]+)\s*=\s*\"?([^\"]*)\"?(?=^\s*\/|$)/ms),s?(n=s[1],r=this._formatFeatureQualifier(s[2])):(n=i(e).replace(/^\//,""),r=!0),t[n]?t[n]instanceof Array?t[n].push(r):t[n]=[t[n],r]:t[n]=!0===r||r}))}return t}_getFirstQualifierValueForName(e,t){const s=t[e];return s instanceof Array?s[0]:void 0!==s?s:void 0}_getFeatureName(e){const t=this.nameKeys.find((t=>this._getFirstQualifierValueForName(t,e)));return t?this._getFirstQualifierValueForName(t,e):""}_addFeatureSequence(e){for(const t of e)for(const e of t.features){const s=[];for(const i of e.locations){const e=i[0],n=i[1];s.push(t.sequence.slice(e-1,n))}-1===e.strand?e.sequence=o(l(s.join(""))):e.sequence=s.join("")}}_determineSequenceTypes(e){for(const t of e){const e=t.sequence;t.type=c(e);const s=u(e,t.type);s&&(t.hasUnexpectedCharacters=s)}}_determineOverallInputAndSequenceType(e){const t=e.map((e=>e.inputType)),s=[...new Set(t)];this._inputType=s.length>1?"multiple":s[0];const i=e.map((e=>e.type)),n=[...new Set(i)];this._sequenceType=n.length>1?"multiple":n[0]}_fail(e,t="unknown"){this.logger.error(e),this._status="failed",this._errorCodes.add(t)}_validateRecords(e){if(this.logger.info("Validating..."),"multiple"===this.inputType){const t=e.map((e=>e.inputType)),s=[...new Set(t)];this._fail(`Input file contains multiple input types: ${s.join(", ")}`)}if("multiple"===this.sequenceType){const t=e.map((e=>e.type)),s=[...new Set(t)];this._fail(`Input file contains multiple sequence types: ${s.join(", ")}`)}"unknown"===this.sequenceType&&this._fail("Input file contains an unknown sequence type (i.e. not dna or protein).");const t=e.filter((e=>0===e.length));if(t.length>0){const e=t.length.toLocaleString();this._fail(`The following sequences (${e}) have zero length:`),this._fail(`- ${t.map((e=>e.name)).join(", ")}`)}const s=e.filter((e=>e.length!==e.sequence.length));if(s.length>0){const e=s.length.toLocaleString();this._fail(`The following sequences (${e}) have mismatched lengths (length attribute vs sequence length):`);const t=s.map((e=>`- ${e.name}: ${e.length.toLocaleString()} bp vs ${e.sequence.length.toLocaleString()} bp`));this.logger.error(t)}const i=e.filter((e=>e.hasUnexpectedCharacters));if(i.length>0){const e=i.length.toLocaleString();this._fail(`The following sequences (${e}) contain unexpected characters:`);const t=i.map((e=>`- ${e.name}: ${e.hasUnexpectedCharacters}`));this.logger.error(t)}const n=[],r=[];for(const t of e)for(const e of t.features)(e.start>t.length||e.stop>t.length)&&n.push(`- ${t.name} [${t.length.toLocaleString()} bp]: '${e.name}' [${e.start}..${e.stop}]`),e.start>e.stop&&r.push(`- ${t.name}: '${e.name}' [${e.start}..${e.stop}]`);if(n.length>0){const e=n.length.toLocaleString();this._fail(`The following features (${e}) have start or end greater than the sequence length:`),this.logger.error(n)}if(r.length>0){const e=r.length.toLocaleString();this._fail(`The following features (${e}) have a start greater than the end:`),this.logger.error(r)}this.success?this.logger.info("- validations passed",{icon:"success"}):this.logger.error("- validations failed",{icon:"fail"})}}var f=p;class d{constructor(t,s={}){this._file=t,this._options=s,this.logger=s.logger||new e,this._lineCount=0}get file(){return this._file}get options(){return this._options}get fileFormat(){return"gff3"}get displayFileFormat(){return"GFF3"}get lineCount(){return this._lineCount}get nameKeys(){return this.options.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"]}_fail(e,t="unknown"){this.file._fail(e,t)}static lineMatches(e){const t=e.split("\t").map((e=>e.trim()));return 9===t.length&&(!isNaN(t[3])&&!isNaN(t[4]))}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("##"));else if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}this.logger.info("- Note: Records with the same 'ID' will be joined into a single record."),this.logger.info(`- Parsed Feature Lines: ${s.length.toLocaleString().padStart(7)}`);const r=this._joinRecords(s);return this.logger.info(`- Total Features: ${r.length.toLocaleString().padStart(13)}`),r}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<9)return this._fail(`- Line does not have 9 fields: ${e}`),null;const s={contig:t[0],source:t[1],type:this._parseType(t[2]),start:parseInt(t[3]),stop:parseInt(t[4]),score:t[5],strand:t[6],phase:t[7],attributes:this._parseAttributes(t[8]),qualifiers:{}},i=this._extractQualifiers(s);return Object.keys(i).length>0&&(s.qualifiers=i),s.name=this._extractName(s,this.nameKeys),s}_parseType(e){return s[e]||e}_parseAttributes(e){const t={},s=e.split(";");let i;for(i of s){const[e,s]=i.split("=");t[e]=s.trim()}return t}_extractQualifiers(e){const s=e.attributes||{},i={},n=Object.keys(s);let r;for(r of n)t.includes(r)?i[r]=s[r]:"Dbxref"===r?i.db_xref=s[r]:"Note"===r?this._addQualifierNote(i,s[r]):"codons"===r&&this._addQualifierNote(i,`codon recognized: ${s[r]}`);return i}_addQualifierNote(e,t){e.note?e.note+=`; ${t}`:e.note=t}_extractName(e,t){const s=e.attributes||{};let i;for(i of t)if(s[i])return s[i];return null}_joinRecords(e){const t=[],s={};let i;for(i of e)if(i.attributes.ID){const e=i.attributes.ID;s[e]?s[e].push(i):s[e]=[i]}else t.push(i);const n=Object.keys(s);for(let e of n){const i=s[e];if(1===i.length)t.push(i[0]);else{const e=this._joinRecordGroup(i);t.push(e)}}return t}_joinRecordGroup(e){if(1===e.length)return e[0];e.sort(((e,t)=>e.start-t.start));const t={...e[0]},s=[];for(let t of e)s.push([t.start,t.stop]);t.locations=s,t.stop=e[e.length-1][1];for(let s of e)t.qualifiers={...t.qualifiers,...s.qualifiers},t.attributes={...t.attributes,...s.attributes};return t}validateRecords(e){this.errors}}class m{constructor(t,s={}){this._file=t,this._options=s,this.logger=s.logger||new e,this._lineCount=0}get file(){return this._file}get options(){return this._options}get fileFormat(){return"gtf"}get displayFileFormat(){return"GTF"}get lineCount(){return this._lineCount}get nameKeys(){return this.options.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"]}_fail(e,t="unknown"){this.file._fail(e,t)}static lineMatches(e){const t=e.replace(/\s+#[^"]+$/,"").split("\t").map((e=>e.trim())),s=t[8]?.split("; ")||[];return 9===t.length&&(!isNaN(t[3])&&!isNaN(t[4])&&(!(s.length<2)&&!!s[0].startsWith("gene_id")))}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("##"));else if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}this.logger.info("- Note: Records with the same 'transcript_id' will be joined into a single record."),this.logger.info(`- Parsed Feature Lines: ${s.length.toLocaleString().padStart(7)}`);const r=this._joinRecords(s);return this.logger.info(`- Total Features: ${r.length.toLocaleString().padStart(13)}`),r}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<9)return this._fail(`- Line does not have 9 fields: ${e}`),null;const s={contig:t[0],source:t[1],type:this._parseType(t[2]),start:parseInt(t[3]),stop:parseInt(t[4]),score:t[5],strand:t[6],phase:t[7],attributes:this._parseGTFAttributes(t[8]),qualifiers:{}},i=this._extractQualifiers(s);return Object.keys(i).length>0&&(s.qualifiers=i),s.name=this._extractName(s,this.nameKeys),s}_parseType(e){return s[e]||e}_parseGTFAttributes(e){const t={},s=e.split("; ");for(let e of s){let s=e.match(/\s*(\S+)\s+"([^"]+)"/);if(s){const e=s[1],i=s[2];t[e]?Array.isArray(t[e])?t[e].push(i):t[e]=[t[e],i]:t[e]=i}}return t}_extractQualifiers(e){const s=e.attributes||{},i={},n=Object.keys(s);let r;for(r of n)t.includes(r)?i[r]=s[r]:"Dbxref"===r?i.db_xref=s[r]:"Note"===r?this._addQualifierNote(i,s[r]):"codons"===r&&this._addQualifierNote(i,`codon recognized: ${s[r]}`);return i}_addQualifierNote(e,t){e.note?e.note+=`; ${t}`:e.note=t}_extractName(e,t){const s=e.attributes||{};let i;for(i of t)if(s[i])return s[i];return null}_joinRecords(e){const t=[],s={};let i;for(i of e)if(i.attributes.transcript_id){const e=i.attributes.transcript_id;s[e]?s[e].push(i):s[e]=[i]}else t.push(i);const n=Object.keys(s);for(let e of n){const i=s[e];if(1===i.length)t.push(i[0]);else{const e=this._joinRecordGroup(i);t.push(e)}}return t}_joinRecordGroup(e){if(1===e.length)return e[0];e.sort(((e,t)=>e.start-t.start));const t={...e[0]},s=[];for(let t of e)s.push([t.start,t.stop]);t.locations=s,t.stop=e[e.length-1][1];for(let s of e)t.qualifiers={...t.qualifiers,...s.qualifiers},t.attributes={...t.attributes,...s.attributes};return t}validateRecords(e){this.errors}}class _{constructor(t,s={}){this._file=t,this._errors={},this._options=s,this.logger=s.logger||new e,this._lineCount=0}get file(){return this._file}get options(){return this._options}get fileFormat(){return"bed"}get displayFileFormat(){return"BED"}get lineCount(){return this._lineCount}get errors(){return this._errors||{}}_warn(e,t="unknown"){this.file._warn(e,t)}_fail(e,t="unknown"){this.file._fail(e,t)}static lineMatches(e){const t=e.split("\t").map((e=>e.trim()));return!(t.length<3)&&(10!==t.length&&11!==t.length&&(!isNaN(t[1])&&!isNaN(t[2])&&(!(t.length>=5&&isNaN(t[4]))&&(!(t.length>=7&&isNaN(t[6]))&&(!(t.length>=8&&isNaN(t[7]))&&!(t.length>=10&&isNaN(t[9])))))))}addError(e,t){const s=this.errors;s[e]?s[e].push(t):s[e]=[t]}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}return this.logger.info(`- Parsed ${s.length} record`),s}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<3)return this._fail(`- Line does not have at least 3 fields: ${e}`),null;const s={contig:t[0],start:parseInt(t[1])+1,stop:parseInt(t[2]),name:t[3]||"Uknown"},i=parseFloat(t[4]);if(isNaN(i)||(s.score=i),t[5]&&(s.strand=t[5]),t[6]){parseInt(t[6])+1!==s.start&&this.addError("thickStartNotMatchingStart",`- thickStart is not the same as start: ${e}`)}if(t[7]){parseInt(t[7])!==s.stop&&this.addError("thickEndNotMatchingEnd",`- thickEnd is not the same as stop: ${e}`)}if(t[11]){const i=parseInt(t[9]);if(i>1){const n=t[10].replace(/,$/,"").split(",").map((e=>parseInt(e))),r=t[11].replace(/,$/,"").split(",").map((e=>parseInt(e)+1));if(i!==n.length||i!==r.length)this.logger.warn(`- Block count does not match block sizes and starts: ${e}`),console.log(i,n,r);else if(1!==r[0])this.logger.warn(`- Block start does not match start: ${e}`);else if(r[r.length-1]+n[r.length-1]+s.start-2!==s.stop)this.logger.warn(`- Block end does not match stop: ${e}`);else{s.locations=[];for(let e=0;e<i;e++)s.locations.push([s.start+r[e]-1,s.start+r[e]+n[e]-2])}}}return s}validateRecords(e){const t=this.errors,s=t.thickStartNotMatchingStart||[];s.length&&this._warn(`- Features where thickStart != start: ${s.length}`);const i=t.thickEndNotMatchingEnd||[];i.length&&this._warn(`- Features where thickEnd != stop: ${s.length}`),(s.length||i.length)&&this._warn("- NOTE: thickStart and thickEnd are ignored by this parser");const n=e.filter((e=>isNaN(e.start)));n.length&&this._fail(`- Records missing Starts: ${n.length.toLocaleString().padStart(5)}`);const r=e.filter((e=>isNaN(e.stop)));r.length&&this._fail(`- Records missing Stops: ${r.length.toLocaleString().padStart(6)}`)}}class y{static FORMATS=["auto","gff3","bed","csv","gtf"];static FILE_FORMAT_DELEGATES={gff3:d,gtf:m,bed:_};constructor(t,s={}){this.options=s;const i=r(t);this.logger=s.logger||new e,s.logger=this.logger;let n=s.format||"auto";if(s.maxLogCount&&(this.logger.maxLogCount=s.maxLogCount),this.logger.info(`Date: ${(new Date).toUTCString()}`),this._success=!0,this._status="success",this._records=[],this._errorCodes=new Set,this.nameKeys=s.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"],i&&""!==i)if(a(i))this._fail("Parsing Failed: Input contains non-text characters. Is this binary data?","binary");else{this.logger.info("Checking File Format..."),this.logger.info("- Format Provided: "+n.padStart(12));const e=this.detectFormat(i);this.logger.info("- Format Detected: "+e.padStart(12)),this.inputFormat=this.chooseFormat(n,e),["gtf","gff3"].includes(this.inputFormat)&&this.logger.info("- Name extraction keys (GFF3/GTF): "+this.nameKeys.join(", ")),this._records=this.parseWrapper(i,s),this.validateRecordsWrapper(this._records,s),this.parseSummary()}else this._fail("Parsing Failed: No input text provided.","empty");this.logger.break()}get status(){return this._status}get success(){return"success"==this.status}get passed(){return"success"===this.status||"warnings"===this.status}_warn(e){this.logger.warn(e),"fail"!==this.status&&(this._status="warnings")}_fail(e,t="unknown"){this.logger.error(e),this._status="failed",this._errorCodes.add(t)}get errorCodes(){return Array.from(this._errorCodes)}get inputFormat(){return this.delegate.fileFormat}set inputFormat(e){const t=Object.keys(y.formatDelegateMap);if(!t.includes(e))throw`File format '${e}' must be one of the following: ${t.join(", ")}`;this._delegate=new y.formatDelegateMap[e](this,this.options)}detectFormat(e){let t;const s=e.split("\n").filter((e=>""!==e.trim()&&!e.startsWith("#")))[0];return t=e.match(/^##gff-version 3/)?"gff3":m.lineMatches(s)?"gtf":_.lineMatches(s)?"bed":"unknown",t}chooseFormat(e,t){return y.FORMATS.includes(e)&&"auto"!==e?(e!==t&&this._warn(`- Using Provided format '${e}'; Does not match detected format '${t}'`),e):("unknown"===t?this._fail("- File Format Unknown: AutoDection Failed. Try explicitly setting the format."):"auto"!==e&&this.logger.warn(`- Unknown format '${e}' -> Using '${t}'`),t)}toCGViewFeaturesJSON(e={}){}get records(){return this._records}get summary(){return this._summary}parseSummary(){const e=this.records,t=this.displayFileFormat||this.inputFormat.toUpperCase();this.logger.break("--------------------------------------------\n"),this.logger.info("Parsing Summary:"),this.logger.info(`- Input File Format: ${t.padStart(10)}`),this.logger.info(`- Feature Lines: ${this.lineCount.toLocaleString().padStart(14)}`),this.logger.info(`- Feature Count: ${e.length.toLocaleString().padStart(14)}`),this.success?this.logger.info("- Status: "+"Success".padStart(21),{icon:"success"}):"warnings"===this.status?this.logger.warn("- Status: "+"Warnings".padStart(21),{icon:"warn"}):this.logger.error("- Status: "+"FAILED".padStart(21),{icon:"fail"}),this.logger.break("--------------------------------------------\n"),this._summary={inputFormat:this.inputFormat,featureCount:e.length,status:this.status,success:this.success}}get delegate(){return this._delegate}static get formatDelegateMap(){return y.FILE_FORMAT_DELEGATES}get fileFormat(){return this.delegate.fileFormat}get displayFileFormat(){return this.delegate.displayFileFormat}get lineCount(){return this.delegate.lineCount}parse(e,t){return this.delegate.parse(e,t)}validateRecords(e,t){this.delegate.validateRecords(e,t)}parseWrapper(e,t={}){let s=[];this.logger.info(`Parsing ${this.displayFileFormat} Feature File...`);try{s=this.parse(e,t);const i=s.filter((e=>Array.isArray(e.locations))).length;this.logger.info(`- Features with >1 location: ${i.toLocaleString().padStart(2)}`),this.logger.info("- Done parsing feature file")}catch(e){this._fail("- Failed: An error occurred while parsing the file.","parsing"),this.logger.error(`- ERROR: ${e.message}`)}return s}validateRecordsWrapper(e,t={}){this.logger.info("Validating Records ...");try{this.validateRecords(e,t),this.success?this.logger.info("- Validations Passed",{icon:"success"}):this.logger.error("- Validations Failed")}catch(e){this._fail("- Failed: An error occurred while validating the records.","validating"),this.logger.error(`- ERROR: ${e.message}`)}}}const S={};return S.Logger=e,S.SequenceFile=f,S.CGViewBuilder=g,S.FeatureFile=y,S}();
