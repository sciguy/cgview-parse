var CGParse=function(){"use strict";class e{constructor(e={}){this.options=e,this.logToConsole=void 0===e.logToConsole||e.logToConsole,this.showTimestamps=void 0===e.showTimestamps||e.showTimestamps,this.showIcons=void 0!==e.showIcons&&e.showIcons,this.maxLogCount=void 0!==e.maxLogCount&&e.maxLogCount,this.lineLength=e.lineLength||48,this.logs=[]}get count(){return this.logs.length}log(e,t={}){this._log(e,"log",t)}info(e,t={}){this._log(e,"info",t)}warn(e,t={}){this._log(e,"warn",t)}error(e,t={}){this._log(e,"error",t)}divider(e="-"){const t={type:"break",break:e.repeat(this.lineLength)+"\n"};this.logs.push(t)}break(e="\n"){const t={type:"break",break:e};this.logs.push(t)}title(e,t="-"){const s=this.lineLength;let i=e+"\n";if(e.length<s){const n=s-e.length,r=Math.floor(n/2),o=n-r;i=t.repeat(r)+e+t.repeat(o)+"\n"}this.break(i)}history(e={}){let t="";for(const s of this.logs)"message"===s.type?t+=`${this._formatMessage(s,e)}\n`:"break"===s.type&&(t+=s.break);return t}_log(e,t,s={}){const i=this._formatTime(new Date);e=Array.isArray(e)?e:[e];const n=this._optionFor("maxLogCount",s);let r;for(const[o,a]of e.entries()){if(n&&o>=n&&o!==e.length-1){r=`${e[0].match(/^\s*/)[0]}- Only showing first ${n}: ${e.length-n} more not shown (${e.length.toLocaleString()} total)`}const l={type:"message",message:r||a,level:t,timestamp:i,icon:s.icon,padded:s.padded};if(this.logs.push(l),this._consoleMessage(l,s),r)break}}_consoleMessage(e,t={}){this._optionFor("logToConsole",t)&&console[e.level](this._formatMessage(e,t))}_formatMessage(e,t={}){let s="";const i=this._optionFor("showTimestamps",t),n=this._optionFor("showIcons",t);if(n){const t=e.icon||e.level;s+=this._icon(t)+(i?"":" ")}if(i&&(s+=`[${e.timestamp}] `),s+=e.message,void 0!==e.padded){let i=this._optionFor("lineLength",t)-s.length;n&&"success"==e.icon&&(i-=1);s+=`${e.padded.toLocaleString().padStart(i)}`}return s}_formatTime(e){return e.toLocaleTimeString("en-US",{hour:"2-digit",minute:"2-digit",second:"2-digit",timeZone:"UTC",hour12:!1})}_icon(e){const t={log:"📝",info:"ℹ️",warn:"⚠️",error:"🛑",success:"✅",fail:"🛑",none:" "};return e?t[e]||e:t.none}_optionFor(e,t={}){return void 0!==t[e]?t[e]:this[e]}}const t="1.0.0",s=["allele","altitude","anticodon","artificial_location","bio_material","bound_moiety","cell_line","cell_type","chromosome","circular_RNA","citation","clone","clone_lib","codon_start","collected_by","collection_date","compare","country","cultivar","culture_collection","db_xref","dev_stage","direction","EC_number","ecotype","environmental_sample","estimated_length","exception","experiment","focus","frequency","function","gap_type","gene","gene_synonym","germline","haplogroup","haplotype","host","identified_by","inference","isolate","isolation_source","lab_host","lat_lon","linkage_evidence","locus_tag","macronuclear","map","mating_type","metagenome_source","mobile_element_type","mod_base","mol_type","ncRNA_class","note","number","old_locus_tag","operon","organelle","organism","partial","PCR_conditions","PCR_primers","phenotype","plasmid","pop_variant","product","protein_id","proviral","pseudo","pseudogene","rearranged","ination_class","tory_class","replace","ribosomal_slippage","rpt_family","rpt_type","rpt_unit_range","rpt_unit_seq","satellite","segment","serotype","serovar","sex","specimen_voucher","standard_name","strain","sub_clone","submitter_seqid","sub_species","sub_strain","tag_peptide","tissue_lib","tissue_type","transgenic","translation","transl_except","transl_table","trans_splicing","type_material","variety"],i={"SO:0000704":"gene","SO:0000234":"mRNA","SO:0000147":"exon","SO:0000316":"CDS","SO:0000188":"intron","SO:0000610":"polyA_sequence","SO:0000553":"polyA_site","SO:0000204":"five_prime_UTR","SO:0000205":"three_prime_UTR"};function n(e){return e.replace(/\s+/g,"")}function r(e){return e.replace(/\d+/g,"")}function o(e){return e.replace(/\r\n?/g,"\n")}function a(e,t){return t.includes(e)?l(`${e}-`,2,t):e}function l(e,t,s){let i;do{i=e+t,t++}while(s.indexOf(i)>-1);return i}function c(e){let t=!1;const s=e.slice(0,512);let i=0,n=0;if(s.length>=3&&239===s.charCodeAt(0)&&187===s.charCodeAt(1)&&191===s.charCodeAt(2))t=!1;else{for(let e=0;e<s.length;e++){const t=s.charCodeAt(e);t>=32&&t<=126||9===t||10===t||13===t?i++:t<32&&9!==t&&10!==t&&13!==t&&n++}(i/0<.8||n/0>.1)&&(t=!0)}return t}function u(e,t={}){const s=e.split(/\r\n|\r|\n/).filter((e=>!e.startsWith("#")&&""!==e.trim()));return t.maxLines?s.slice(0,t.maxLines):s}function h(e){let t="";for(let s=e.length-1;s>=0;s--)t+=e[s];return t}function d(e){const t={A:"T",C:"G",G:"C",T:"A",U:"A",R:"Y",Y:"R",S:"S",W:"W",K:"M",M:"K",B:"V",D:"H",H:"D",V:"B",N:"N",a:"t",c:"g",g:"c",t:"a",u:"a",r:"y",y:"r",s:"s",w:"w",k:"m",m:"k",b:"v",d:"h",h:"d",v:"b",n:"n"};return e.split("").map((e=>t[e]||e)).join("")}function g(e){let t;const s=e.length;if(f(e,"ATGC")/s>.9)t="dna";else{t=f(e,"ACDEFGHIKLMNPQRSTVWY")/s>.9?"protein":"unknown"}return t}function p(e,t){const s=t.toLowerCase();let i;if("dna"===s){const t=e.replace(/[AGCTURYSWKMBDHVN\-\.]/gi,"");t.length>0&&(i=Array.from(new Set([...t])).join(","))}else if("protein"===s){const t=e.replace(/[ARNDCQEGHILKMFPOSUTWYVBZJ\-\.\*]/gi,"");t.length>0&&(i=Array.from(new Set([...t])).join(","))}return i}function f(e,t){const s=e.toUpperCase(),i=new Set(t.split(""));let n=0;for(let e=0,t=s.length;e<t;e++)i.has(s[e])&&n++;return n}var m=Object.freeze({__proto__:null,CGPARSE_VERSION:t,FEATURE_TYPES:["assembly_gap","C_region","CDS","centromere","D-loop","D_segment","exon","gap","gene","iDNA","intron","J_segment","mat_peptide","misc_binding","misc_difference","misc_feature","misc_recomb","misc_RNA","misc_structure","mobile_element","modified_base","mRNA","ncRNA","N_region","old_sequence","operon","oriT","polyA_site","precursor_RNA","prim_transcript","primer_bind","propeptide","protein_bind","regulatory","repeat_region","rep_origin","rRNA","S_region","sig_peptide","source","stem_loop","STS","telomere","tmRNA","transit_peptide","tRNA","unsure","V_region","V_segment","variation","3'UTR","5'UTR"],QUALIFIERS:s,SO_TERMS:i,complement:d,convertLineEndingsToLF:o,countCharactersInSequence:f,determineSeqMolType:g,findNonIUPACCharacters:p,getLines:u,isBinary:c,removeDigits:r,removeNewlines:function(e){return e.replace(/[\n\r]+/g,"")},removeWhiteSpace:n,reverse:h,uniqueId:l,uniqueName:a});class _{constructor(t={},s){this._options=t,this.logger=t.logger||new e,t.logger=this.logger,t.maxLogCount&&(this.logger.maxLogCount=t.maxLogCount),s?this.logger.title(` ${s} `):this.logger.divider(),this._info(`Date: ${(new Date).toUTCString()}`),this._status="success",this._errorCodes=new Set}static get ERROR_CODES(){return["unknown","binary","empty","unknown_format","parsing","validating"]}get options(){return this._options}get version(){return t}get status(){return this._status}get passed(){return"success"===this.status||"warnings"===this.status}get errorCodes(){return Array.from(this._errorCodes)}addErrorCode(e){_.ERROR_CODES.includes(e)?this._errorCodes.add(e):this._fail(`Invalid error code: ${e}`)}hasErrorCode(e){return this._errorCodes.has(e)}_info(e,t={}){this.logger.info(e,t)}_fail(e,t={}){this.logger.error(e,t),this._status="failed";const s=t.errorCode||"unknown";this.addErrorCode(s)}_warn(e,t={}){this.logger.warn(e,t),"fail"!==this.status&&(this._status="warnings")}logStatusLine(){"success"===this.status?this.logger.info("- Status: ",{padded:"Success",icon:"success"}):"warnings"===this.status?this.logger.warn("- Status: ",{padded:"Warnings",icon:"warn"}):this.logger.error("- Status: ",{padded:"FAILED",icon:"fail"})}}class y extends _{constructor(e,t={}){super(t,"BUILDING CGVIEW JSON"),this.cgvJSONVersion="1.6.0",this.includeFeatures=void 0===t.includeFeatures||t.includeFeatures,this.excludeFeatures=t.excludeFeatures||["gene","source","exon"],this.includeQualifiers=t.includeQualifiers||!1,this.excludeQualifiers=t.excludeQualifiers||[],this.includeCaption=void 0===t.includeCaption||t.includeCaption,this.seqFile=this._parseInput(e),this.inputType=this.seqFile.inputType,this.sequenceType=this.seqFile.sequenceType,!0===this.seqFile.passed?this._json=this._build(this.seqFile.records):this._fail("*** Cannot convert to CGView JSON because parsing sequence file failed ***")}_parseInput(e){return"string"==typeof e?new S(e,{logger:this.logger}):e instanceof S?e:void this._fail("Invalid input: must be a string (from GenBank, EMBL, FASTA, Raw) or SequenceFile object")}_build(e){if(this._skippedFeaturesByType={},this._skippedComplexFeatures=[],this._complexFeatures=[],this._skippedLocationlessFeatures=[],this.logger.info("CGViewBuilder: ",{padded:this.version}),this.logger.info("Converting to CGView JSON..."),this.logger.info("- CGView JSON version: ",{padded:this.cgvJSONVersion}),this.logger.info("- Input Sequence Count: ",{padded:e.length}),this.logger.info("- Input File Type: ",{padded:this.inputType||"Unknown"}),this.logger.info("- Input Sequence Type: ",{padded:this.sequenceType||"Unknown"}),!e||e.length<1)return void this._fail("Conversion Failed: No sequence records provided");if("dna"!==this.sequenceType?.toLowerCase())return void this._fail(`Conversion Failed: Input type is not DNA: '${this.sequenceType}'`);let t=this._addConfigToJSON({},this.options.config);return t.version=this.cgvJSONVersion,this._adjustContigNames(e),t.captions=this._getCaptions(t,e),t.settings.format=y.determineFormat(e),t=this._extractSequenceAndFeatures(t,e),this._summarizeSkippedFeatures(),this._adjustFeatureGeneticCode(t),this._qualifiersSetup(),this._complexFeatures.length>0&&this.logger.info("- Complex Features Found: ",{padded:this._complexFeatures.length}),t.name=e[0]?.definition||e[0]?.name||e[0]?.seqID||"Untitled",t=this._removeUnusedLegends(t),t.tracks=this._buildTracks(t,this.inputType),this._buildSummary(t),{cgview:t}}_getCaptions(e,t){const s=e.captions?[...e.captions]:[];if(this.includeCaption){this.logger.info("- Adding caption...");const e={name:t[0]?.definition||t[0].seqID||"Untitled",textAlignment:"center",font:"sans-serif,plain,24",fontColor:"darkblue",position:"bottom-center"};s.push(e)}return s}_buildSummary(e){const t=e.sequence?.contigs||[],s=t.length||0,i=e.features?.length||0,n=e.tracks?.length||0,r=e.legend?.items?.length||0,o=t.map((e=>e.length)).reduce(((e,t)=>e+t),0);let a=Object.values(this._skippedFeaturesByType).reduce(((e,t)=>e+t),0);a+=this._skippedComplexFeatures.length,a+=this._skippedLocationlessFeatures.length,this.logger.divider(),this.logger.info("CGView JSON Summary:"),this.logger.info("- Map Name: ",{padded:e.name}),this.logger.info("- Contig Count: ",{padded:s}),this.logger.info("- Total Length (bp): ",{padded:o.toLocaleString()}),this.logger.info("- Track Count: ",{padded:n}),this.logger.info("- Legend Count: ",{padded:r}),this.logger.info("- Features Included: ",{padded:i}),this.logger.info("- Features Skipped: ",{padded:a}),this.logStatusLine(),this.logger.divider()}_summarizeSkippedFeatures(){const e=this._skippedFeaturesByType,t=Object.values(this._skippedFeaturesByType).reduce(((e,t)=>e+t),0);if(Object.keys(e).length>0){this.logger.info(`- Skipped features (${t}) by type:`);for(const[t,s]of Object.entries(e))this.logger.info(`  - ${t}: `,{padded:s})}const s=this._skippedComplexFeatures,i=s.length;if(i>0){this.logger.info(`- Skipped features (${i}) with complex locations:`);const e=s.map((e=>`  - ${e.type} '${e.name}': ${e.locationText}`));this.logger.info(e)}const n=this._skippedLocationlessFeatures,r=n.length;if(r>0){this._warn(`- Skipped features (${r}) with missing locations:`);const e=n.map((e=>`  - ${e.type} '${e.name}': ${e.locationText}`));this._warn(e)}}_addConfigToJSON(e,t){const s=t?Object.keys(t):["none"];return this.logger.info(`- Config properties provided: ${s.join(", ")}`),e.settings=t&&t.settings?t.settings:{},e.backbone=t&&t.backbone?t.backbone:{},e.ruler=t&&t.ruler?t.ruler:{},e.dividers=t&&t.dividers?t.dividers:{},e.annotation=t&&t.annotation?t.annotation:{},e.sequence=t&&t.sequence?t.sequence:{},e.legend=t&&t.legend?t.legend:{},e.tracks=t&&t.tracks?t.tracks:[],e}_adjustContigNames(e){const t=e.map((e=>e.name)),s=y.adjustContigNames(t),i=s.names,n=s.reasons;this.logger.info("- Checking contig names...");const r=Object.keys(n);if(r.length>0){e.forEach(((e,t)=>{e.name=i[t]})),this._warn(`The following contig names (${r.length}) were adjusted:`),this._warn("Reasons: DUP (duplicate), LONG (>34), REPLACE (nonstandard characters), BLANK (empty)");const t=[];r.forEach((e=>{const s=n[e];t.push(`- [${s.index+1}] ${s.origName} -> ${s.newName} (${s.reason.join(", ")})`)})),this._warn(t)}}_adjustFeatureGeneticCode(e){const t=e.features;if(!t||t.length<1)return;const s=t.filter((e=>"CDS"===e.type));if(!s||s.length<1)return;const i=s.map((e=>e.geneticCode)),n={};i.forEach((e=>{n[e]=n[e]?n[e]+1:1}));let r=Object.keys(n).reduce(((e,t)=>n[e]>n[t]?e:t));this.logger.info(`- Most common genetic code (transl_table): ${r} (Count: ${n[r]}/${s.length} CDS features}`),Object.keys(n).length>1&&this._warn(`- Additional genetic codes found: ${Object.keys(n).join(", ")}`),e.settings.geneticCode=parseInt(r),e.features.forEach((e=>{"CDS"===e.type&&e.geneticCode===parseInt(r)&&delete e.geneticCode}))}static determineFormat(e=[]){return e.length>1?"circular":"linear"===e[0]?.topology?"linear":"circular"}static adjustContigNames(e=[]){const t={};let s=e.map((e=>e.replace(/[^a-zA-Z0-9\*\_\-]+/g,"_")));e.forEach(((e,i)=>{e!==s[i]&&(t[i]={index:i,origName:e,newName:s[i],reason:["REPLACE"]})})),s.forEach(((e,i)=>{const n="Unknown";""===e&&(s[i]=n,t[i]={index:i,origName:e,newName:n,reason:["BLANK"]})})),s.forEach(((e,i)=>{e.length>34&&(s[i]=e.slice(0,34),t[i]?(t[i].newName=s[i],t[i].reason.push("LONG")):t[i]={index:i,origName:e,newName:s[i],reason:["LONG"]})}));const i=[];return s.forEach(((e,s)=>{const n=a(e,i);i.push(n),n!==e&&(t[s]?(t[s].newName=n,t[s].reason.push("DUP")):t[s]={index:s,origName:e,newName:n,reason:["DUP"]})})),{names:i,reasons:Object.values(t)}}_extractSequenceAndFeatures(e,t){const s=[],i=[];return this._featureTypesSetup(),t.forEach((e=>{s.push({name:e.name,length:e.sequence.length,seq:e.sequence});const t=this._extractFeatures(e,e.name,e.inputType);i.push(...t)})),e.sequence={contigs:s},e.features=i,e}_featureTypesSetup(){const e=this._setupInExcludeItems("Feature types",this.includeFeatures,this.excludeFeatures);this.featuresToInclude=e.itemsToInclude,this.featuresToExclude=e.itemsToExclude}_qualifiersSetup(){const e=this._setupInExcludeItems("Qualifier",this.includeQualifiers,this.excludeQualifiers);this.includeQualifiers=e.itemsToInclude,this.excludeQualifiers=e.itemsToExclude}_setupInExcludeItems(e,t,s){let i=[],n=[],r={inexclude:"EMPTY",items:"EMPTY"};return!0===t?(i=!0,Array.isArray(s)?(n=s,r=n.length>0?{inexclude:"exclude",items:n.join(", ")}:{inexclude:"include",items:"All"}):r={inexclude:"include",items:"All"}):Array.isArray(t)?(i=t,r=i.length>0?{inexclude:"include",items:i.join(", ")}:{inexclude:"include",items:"None"}):(i=[],r={inexclude:"include",items:"None"}),this.logger.info(`- ${e} to ${r.inexclude}: `,{padded:r.items}),{itemsToInclude:i,itemsToExclude:n}}_buildTracks(e,t){const s=e.tracks||[];return e.features&&e.features.length>0&&s.push({name:"Features",separateFeaturesBy:"strand",position:"both",dataType:"feature",dataMethod:"source",dataKeys:`${t}-features`}),s}_removeUnusedLegends(e){const t=e.legend?.items||[];if(0===t.length)return e;const s=e.features?.map((e=>e.legend))||[],i=[...new Set(s)],n=t.filter((e=>i.includes(e.name)));return e.legend.items=n,e}_extractFeatures(e,t,s){const i=[],n=s?`${s}-features`:"features";for(const s of e.features){if(this.featuresToExclude.includes(s.type)){this._skippedFeaturesByType[s.type]=this._skippedFeaturesByType[s.type]?this._skippedFeaturesByType[s.type]+1:1;continue}if(Array.isArray(this.featuresToInclude)&&!this.featuresToInclude.includes(s.type)){this._skippedFeaturesByType[s.type]=this._skippedFeaturesByType[s.type]?this._skippedFeaturesByType[s.type]+1:1;continue}if(s.locations.length<1){this._skippedLocationlessFeatures.push(s);continue}const e={start:s.start,stop:s.stop,strand:s.strand,name:s.name,type:s.type,contig:t,source:n,legend:s.type};if(s.locations.length>1&&(e.locations=s.locations,this._complexFeatures.push(s)),s.qualifiers&&s.qualifiers.codon_start&&1!==parseInt(s.qualifiers.codon_start[0])&&(e.codonStart=parseInt(s.qualifiers.codon_start[0])),"CDS"===e.type){const t=s.qualifiers&&s.qualifiers.transl_table&&parseInt(s.qualifiers.transl_table[0]);e.geneticCode=t||1}const r=y.extractQualifiers(s.qualifiers,this.includeQualifiers,this.excludeQualifiers);r&&(e.qualifiers=r),i.push(e)}return i}static extractQualifiers(e,t,s){let i={};if(!0===t&&e)if(Array.isArray(s)&&s.length>0){const t={...e};s.forEach((e=>{delete t[e]})),i=t}else i=e;else Array.isArray(t)&&t.forEach((t=>{void 0!==e[t]&&(i[t]=e[t])}));if(Object.keys(i).length>0)return i}toJSON(){return this._json}static fromSequenceText(t,s){const i=new e({logToConsole:!1,showIcons:!0}),n=new y(t,{logger:i,...s});return{json:n.toJSON(),log:n.logger.history()}}}class F extends _{static toCGViewJSON(t,s={}){const i=new e({logToConsole:!1});return new F(t,{logger:i,...s}).toCGViewJSON()}constructor(e,t={}){super(t,"PARSING SEQUENCE FILE");const s=o(e);this.nameKeys=t.nameKeys||["gene","locus_tag","product","note","db_xref"],this._records=[],s&&""!==s?c(s)?this._fail("Parsing Failed: Input contains non-text characters. Is this binary data?","binary"):(this._records=this._parse(s,t),t.addFeatureSequences&&this._addFeatureSequence(this._records),this._determineSequenceTypes(this._records),this._determineOverallInputAndSequenceType(this._records),this.logger.info("- done parsing sequence file"),this._validateRecords(this._records),this.parseSummary()):this._fail("Parsing Failed: No input text provided.","empty"),this.logger.break()}get inputType(){return this._inputType}get sequenceType(){return this._sequenceType}get summary(){return this._summary}toCGViewJSON(e={}){if(this.passed){e.logger=e.logger||this.logger;return new y(this,e).toJSON()}this.logger.error("*** Cannot convert to CGView JSON because parsing failed ***")}get records(){return this._records}parseSummary(){const e=this.records,t=e.map((e=>e.features)).flat(),s=e.map((e=>e.length)).reduce(((e,t)=>e+t),0);this.logger.divider(),this.logger.info("Parsing Summary:"),this.logger.info("- Input file type: ",{padded:this.inputType}),this.logger.info("- Sequence Type: ",{padded:this.sequenceType}),this.logger.info("- Sequence Count: ",{padded:e.length}),this.logger.info("- Feature Count: ",{padded:t.length}),this.logger.info("- Total Length (bp): ",{padded:s.toLocaleString()}),this.logStatusLine(),this.logger.divider(),this._summary={inputType:this.inputType,sequenceType:this.sequenceType,sequenceCount:e.length,featureCount:t.length,totalLength:s,status:this.status}}_parse(e,t={}){this.logger.info("Parsing sequence file...");let s=this._parseGenbankOrEmbl(e,t);return(0===s.length||""===s[0].name&&0===s[0].length&&""===s[0].sequence)&&(this.logger.info("- empty results"),/^\s*>/.test(e)?(this.logger.info("- attempting as FASTA..."),s=this._parseFasta(e,t)):(this.logger.info("- attempting as raw..."),s=this._parseRaw(e,t))),s}_parseGenbankOrEmbl(e,t={}){const s=[];return this.logger.info("- attempting as GenBank or EMBL..."),this.logger.info("- name extraction keys: "+this.nameKeys.join(", ")),e.split(/^\/\//m).filter(this._isSeqRecord).forEach((e=>{const t={inputType:"unknown"};/^\s*LOCUS|^\s*FEATURES/m.test(e)?t.inputType="genbank":/^\s*ID|^\s*SQ/m.test(e)&&(t.inputType="embl"),t.name=this._getSeqName(e),t.seqID=this._getSeqID(e),t.definition=this._getSeqDefinition(e),t.length=this._getSeqLength(e),t.topology=this._getSeqTopology(e),t.comments=this._getSeqComments(e),t.sequence=this._getSequence(e),t.length||(t.length=t.sequence.length),t.features=this._getFeatures(e),s.push(t)})),s}_parseFasta(e,t={}){const s=[];return e.split(/^\s*>/m).filter(this._isSeqRecord).forEach((e=>{const t={inputType:"fasta",name:"",length:0,sequence:""},i=e.match(/^([^\n\r]*)(.*)/s);if(i&&(t.name=i[1].trim(),t.sequence=n(r(i[2])),t.length=t.sequence.length,t.features=[],""!==t.name)){const e=t.name.match(/^(\S+)\s*(.*)/);e&&(t.seqID=e[1],t.definition=e[2])}s.push(t)})),s}_parseRaw(e,t={}){const s={inputType:"raw",name:"",features:[]};return s.sequence=n(r(e)),s.length=s.sequence.length,[s]}_isSeqRecord(e){return!/^\s*\/\/\s*$/.test(e)&&!/^\s*$/.test(e)}_getSeqName(e){const t=e.match(/^\s*(?:LOCUS|ID)\s*(\S+)/);if(t){let e=t[1];return e=e.replace(/;$/,""),e}return""}_getSeqID(e){let t=e.match(/^\s*(?:VERSION)\s*(\S+)/m);if(t){return t[1]}if(t=e.match(/^\s*AC\s*(\S+);/m),t){let s,i=t[1];return t=e.match(/^\s*ID\s*(\S+);\s*SV\s*(\d+);/),t&&(s=t[2]),s?`${i}.${s}`:i}return""}_getSeqDefinition(e){const t=e.match(/^\s*(?:DEFINITION|DE)\s+(.+)$/m);if(t){return t[1]}return""}_getSeqLength(e){const t=e.match(/^\s*(?:LOCUS|ID).*?(\d+)\s[Bb][Pp]/);return t?parseInt(t[1]):0}_getSeqTopology(e){const t=e.match(/^\s*(?:LOCUS|ID)\s*\S+\s+.*(linear|circular)/);return t?this.topology=t[1]:"unknown"}_getSeqComments(e){let t=e.match(/^\s*COMMENT\s+(.*)\nFEATURES/ms),s="";return t?(s=t[1],s=s.replace(/^\s*/gm,"")):(t=e.match(/^\s*CC\s+(.*)\nXX/ms),t&&(s=t[1],s=s.replace(/^\s*CC\s*/gm,""))),s}_getSequence(e){const t=e.match(/^(?:ORIGIN|SQ\s{3}).*?$([^\/]*)(^\s*$|^\s*LOCUS)?/m);return t?r(n(t[1])):""}_getFeatures(e){const t=[],s=e.match(/^(?:FEATURES.*?$|FH.*?^FH.*?$)(.*)^(?:ORIGIN|SQ\s{3}).*?$/ms);if(s){let e=s[1];e=e.replaceAll(/^FT/gm,"  "),e.split(/(?=^\s{5}\S+)/m).filter(this._isFeatureRecord).forEach((e=>{const s={};s.type=this._getFeatureType(e),s.strand=this._getFeatureStrand(e),s.locationText=this._getFeatureLocationText(e),s.locations=this._getFeatureLocations(s.locationText),s.start=s.locations.map((e=>e[0])).sort(((e,t)=>e-t))[0],s.stop=s.locations.map((e=>e[1])).sort(((e,t)=>t-e))[0],s.qualifiers=this._getFeatureQualifiers(e),s.name=this._getFeatureName(s.qualifiers),s.type&&t.push(s)}))}return t}_isFeatureRecord(e){return!/^\s*\/\s*$/.test(e)&&!/^\s*$/.test(e)}_getFeatureType(e){const t=e.match(/^\s{5}(\S+)/);return t?t[1]:null}_getFeatureStrand(e){return e.match(/^\s{5}\S+\s+complement/)?-1:1}_getFeatureLocationText(e){const t=e.match(/^\s{5}\S+\s+([^\/]+)/s);return t?n(t[1]):""}_getFeatureLocations(e){const t=[],s=e.split(/(?=,)/).filter(this._isParsableFeatureRange);for(const e of s){let s=e.match(/(\d+)\D*\.\.\D*(\d+)/);if(s){const e=parseInt(s[1]),i=parseInt(s[2]);t.push([e,i])}else if(s=e.match(/(\d+)/),s){const e=parseInt(s[1]),i=e;t.push([e,i])}}return t}_isParsableFeatureRange(e){return!/\d\.\d/.test(e)&&(!/\^/.test(e)&&(!/:/.test(e)&&!/^\s*$/.test(e)))}_isFeatureQualifier(e){return!/^\s*\/\s*$/.test(e)&&!/^\s*$/.test(e)}_formatFeatureQualifier(e){return/\S\s\S/.test(e)?e.replace(/[\s]+/g," "):e.replace(/[\s]+/g,"")}_getFeatureQualifiers(e){const t={};let s=e.match(/(\/.*)/s);if(s){s[1].split(/(?=^\s*\/)/m).filter(this._isFeatureQualifier).forEach((e=>{let i,r;s=e.match(/\/([^\"\s]+)\s*=\s*\"?([^\"]*)\"?(?=^\s*\/|$)/ms),s?(i=s[1],r=this._formatFeatureQualifier(s[2])):(i=n(e).replace(/^\//,""),r=!0),t[i]?t[i]instanceof Array?t[i].push(r):t[i]=[t[i],r]:t[i]=!0===r||r}))}return t}_getFirstQualifierValueForName(e,t){const s=t[e];return s instanceof Array?s[0]:void 0!==s?s:void 0}_getFeatureName(e){const t=this.nameKeys.find((t=>this._getFirstQualifierValueForName(t,e)));return t?this._getFirstQualifierValueForName(t,e):""}_addFeatureSequence(e){for(const t of e)for(const e of t.features){const s=[];for(const i of e.locations){const e=i[0],n=i[1];s.push(t.sequence.slice(e-1,n))}-1===e.strand?e.sequence=h(d(s.join(""))):e.sequence=s.join("")}}_determineSequenceTypes(e){for(const t of e){const e=t.sequence;t.type=g(e);const s=p(e,t.type);s&&(t.hasUnexpectedCharacters=s)}}_determineOverallInputAndSequenceType(e){const t=e.map((e=>e.inputType)),s=[...new Set(t)];this._inputType=s.length>1?"multiple":s[0];const i=e.map((e=>e.type)),n=[...new Set(i)];this._sequenceType=n.length>1?"multiple":n[0]}_validateRecords(e){if(this.logger.info("Validating..."),"multiple"===this.inputType){const t=e.map((e=>e.inputType)),s=[...new Set(t)];this._fail(`Input file contains multiple input types: ${s.join(", ")}`)}if("multiple"===this.sequenceType){const t=e.map((e=>e.type)),s=[...new Set(t)];this._fail(`Input file contains multiple sequence types: ${s.join(", ")}`)}"unknown"===this.sequenceType&&this._fail("Input file contains an unknown sequence type (i.e. not dna or protein).");const t=e.filter((e=>0===e.length));if(t.length>0){const e=t.length.toLocaleString();this._fail(`The following sequences (${e}) have zero length:`),this._fail(`- ${t.map((e=>e.name)).join(", ")}`)}const s=e.filter((e=>e.length!==e.sequence.length));if(s.length>0){const e=s.length.toLocaleString();this._fail(`The following sequences (${e}) have mismatched lengths (length attribute vs sequence length):`);const t=s.map((e=>`- ${e.name}: ${e.length.toLocaleString()} bp vs ${e.sequence.length.toLocaleString()} bp`));this.logger.error(t)}const i=e.filter((e=>e.hasUnexpectedCharacters));if(i.length>0){const e=i.length.toLocaleString();this._fail(`The following sequences (${e}) contain unexpected characters:`);const t=i.map((e=>`- ${e.name}: ${e.hasUnexpectedCharacters}`));this.logger.error(t)}const n=[],r=[];for(const t of e)for(const e of t.features)(e.start>t.length||e.stop>t.length)&&n.push(`- ${t.name} [${t.length.toLocaleString()} bp]: '${e.name}' [${e.start}..${e.stop}]`),e.start>e.stop&&r.push(`- ${t.name}: '${e.name}' [${e.start}..${e.stop}]`);if(n.length>0){const e=n.length.toLocaleString();this._fail(`The following features (${e}) have start or end greater than the sequence length:`),this.logger.error(n)}if(r.length>0){const e=r.length.toLocaleString();this._fail(`The following features (${e}) have a start greater than the end:`),this.logger.error(r)}this.passed?this.logger.info("- validations passed",{icon:"success"}):this.logger.error("- validations failed",{icon:"fail"})}}var S=F;class C{constructor(t,s={}){this._file=t,this._options=s,this.logger=s.logger||new e,this._lineCount=0}get file(){return this._file}get options(){return this._options}get fileFormat(){return"gff3"}get displayFileFormat(){return"GFF3"}get lineCount(){return this._lineCount}get nameKeys(){return this.options.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"]}_fail(e,t={}){this.file._fail(e,t)}static lineMatches(e){const t=e.split("\t").map((e=>e.trim()));return 9===t.length&&(!isNaN(t[3])&&!isNaN(t[4]))}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("##"));else if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}this.logger.info("- Note: Records with the same 'ID' will be joined into a single record."),this.logger.info("- Parsed Feature Lines: ",{padded:s.length});const r=this._joinRecords(s);return this.logger.info("- Total Features: ",{padded:r.length}),r}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<9)return this._fail(`- Line does not have 9 fields: ${e}`),null;const s={contig:t[0],source:t[1],type:this._parseType(t[2]),start:parseInt(t[3]),stop:parseInt(t[4]),score:t[5],strand:t[6],phase:t[7],attributes:this._parseAttributes(t[8]),qualifiers:{}},i=this._extractQualifiers(s);return Object.keys(i).length>0&&(s.qualifiers=i),s.name=this._extractName(s,this.nameKeys),s}_parseType(e){return i[e]||e}_parseAttributes(e){const t={},s=e.split(";");let i;for(i of s){const[e,s]=i.split("=");t[e]=s.trim()}return t}_extractQualifiers(e){const t=e.attributes||{},i={},n=Object.keys(t);let r;for(r of n)s.includes(r)?i[r]=t[r]:"Dbxref"===r?i.db_xref=t[r]:"Note"===r?this._addQualifierNote(i,t[r]):"codons"===r&&this._addQualifierNote(i,`codon recognized: ${t[r]}`);return i}_addQualifierNote(e,t){e.note?e.note+=`; ${t}`:e.note=t}_extractName(e,t){const s=e.attributes||{};let i;for(i of t)if(s[i])return s[i];return null}_joinRecords(e){const t=[],s={};let i;for(i of e)if(i.attributes.ID){const e=i.attributes.ID;s[e]?s[e].push(i):s[e]=[i]}else t.push(i);const n=Object.keys(s);for(let e of n){const i=s[e];if(1===i.length)t.push(i[0]);else{const e=this._joinRecordGroup(i);t.push(e)}}return t}_joinRecordGroup(e){if(1===e.length)return e[0];e.sort(((e,t)=>e.start-t.start));const t={...e[0]},s=[];for(let t of e)s.push([t.start,t.stop]);t.locations=s,t.stop=s[s.length-1][1];for(let s of e)t.qualifiers={...t.qualifiers,...s.qualifiers},t.attributes={...t.attributes,...s.attributes};return t}validateRecords(e){this.errors}}class N{constructor(t,s={}){this._file=t,this._options=s,this.logger=s.logger||new e,this._lineCount=0}get file(){return this._file}get options(){return this._options}get fileFormat(){return"gtf"}get displayFileFormat(){return"GTF"}get lineCount(){return this._lineCount}get nameKeys(){return this.options.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"]}_fail(e,t={}){this.file._fail(e,t)}static lineMatches(e){const t=e.replace(/\s+#[^"]+$/,"").split("\t").map((e=>e.trim())),s=t[8]?.split("; ")||[];return 9===t.length&&(!isNaN(t[3])&&!isNaN(t[4])&&(!(s.length<2)&&!!s[0].startsWith("gene_id")))}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("##"));else if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}this.logger.info("- Note: Records (CDS, start/stop_codon) with the same 'transcript_id' will be joined into a single CDS record."),this.logger.info("- Parsed Feature Lines: ",{padded:s.length});const r=this._joinRecords(s);return this.logger.info("- Total Features: ",{padded:r.length}),r}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<9)return this._fail(`- Line does not have 9 fields: ${e}`),null;const s={contig:t[0],source:t[1],type:this._parseType(t[2]),start:parseInt(t[3]),stop:parseInt(t[4]),score:t[5],strand:t[6],phase:t[7],attributes:this._parseGTFAttributes(t[8]),qualifiers:{},valid:!0},i=this._extractQualifiers(s);return Object.keys(i).length>0&&(s.qualifiers=i),s.name=this._extractName(s,this.nameKeys),s}_parseType(e){return i[e]||e}_parseGTFAttributes(e){const t={},s=e.split("; ");for(let e of s){let s=e.match(/\s*(\S+)\s+"([^"]+)"/);if(s){const e=s[1],i=s[2];t[e]?Array.isArray(t[e])?t[e].push(i):t[e]=[t[e],i]:t[e]=i}}return t}_extractQualifiers(e){const t=e.attributes||{},i={},n=Object.keys(t);let r;for(r of n)s.includes(r)?i[r]=t[r]:"Dbxref"===r?i.db_xref=t[r]:"Note"===r?this._addQualifierNote(i,t[r]):"codons"===r&&this._addQualifierNote(i,`codon recognized: ${t[r]}`);return i}_addQualifierNote(e,t){e.note?e.note+=`; ${t}`:e.note=t}_extractName(e,t){const s=e.attributes||{};let i;for(i of t)if(s[i])return s[i];return null}_joinRecords(e){const t=[],s={},i=["CDS","start_codon","stop_codon"];let n;for(n of e){const e=n.attributes.transcript_id;e&&i.includes(n.type)?s[e]?s[e].push(n):s[e]=[n]:t.push(n)}const r=Object.keys(s);for(let e of r){const i=s[e];if(1===i.length)t.push(i[0]);else{const e=this._joinRecordGroup(i);t.push(e)}}return t}_joinRecordGroup(e){if(1===e.length)return e[0];e.sort(((e,t)=>e.start-t.start));const t={...(e=e.filter((e=>"start_codon"!==e.type)))[0]};"CDS"!==t.type&&(e.some((e=>"CDS"===e.type))?t.type="CDS":this.logger.warn(`- No CDS records for this group: ${e}`));const s=[];for(let t of e)s.push([t.start,t.stop]);t.locations=s,t.stop=s[s.length-1][1];for(let s of e)t.qualifiers={...t.qualifiers,...s.qualifiers},t.attributes={...t.attributes,...s.attributes};return t}validateRecords(e){this.errors}}class T{constructor(t,s={}){this._file=t,this._validationIssues={},this._options=s,this.logger=s.logger||new e,this._lineCount=0}static get VALIDATION_ISSUE_CODES(){return["thickStartNotMatchingStart","thickEndNotMatchingEnd","missingStart","missingStop"]}get file(){return this._file}get options(){return this._options}get fileFormat(){return"bed"}get displayFileFormat(){return"BED"}get lineCount(){return this._lineCount}get validationIssues(){return this._validationIssues||{}}_warn(e,t={}){this.file._warn(e,t)}_fail(e,t={}){this.file._fail(e,t)}static lineMatches(e){const t=e.split("\t").map((e=>e.trim()));return!(t.length<3)&&(10!==t.length&&11!==t.length&&(!isNaN(t[1])&&!isNaN(t[2])&&(!(t.length>=5&&isNaN(t[4]))&&(!(t.length>=7&&isNaN(t[6]))&&(!(t.length>=8&&isNaN(t[7]))&&!(t.length>=10&&isNaN(t[9])))))))}addValidationIssue(e,t){if(!T.VALIDATION_ISSUE_CODES.includes(e))return void this._fail("ERROR: Invalid validiation issue code: "+e);const s=this.validationIssues;s[e]?s[e].push(t):s[e]=[t]}parse(e,t={}){const s=[],i=e.split("\n");let n;for(n of i)if(n.startsWith("#"));else if(""===n.trim());else{const e=this._parseLine(n);e&&s.push(e)}return this.logger.info(`- Parsed ${s.length} records`),s}_parseLine(e){this._lineCount++;const t=e.split("\t").map((e=>e.trim()));if(t.length<3)return this._fail(`- Line does not have at least 3 fields: ${e}`),null;const s={contig:t[0],start:parseInt(t[1])+1,stop:parseInt(t[2]),name:t[3]||"Uknown",valid:!0};isNaN(s.start)&&(this.addValidationIssue("missingStart"),s.valid=!1),isNaN(s.stop)&&(this.addValidationIssue("missingStop"),s.valid=!1);const i=parseFloat(t[4]);if(isNaN(i)||(s.score=i),t[5]&&(s.strand=t[5]),t[6]){parseInt(t[6])+1!==s.start&&this.addValidationIssue("thickStartNotMatchingStart",`- thickStart is not the same as start: ${e}`)}if(t[7]){parseInt(t[7])!==s.stop&&this.addValidationIssue("thickEndNotMatchingEnd",`- thickEnd is not the same as stop: ${e}`)}if(t[11]){const i=parseInt(t[9]);if(i>1){const n=t[10].replace(/,$/,"").split(",").map((e=>parseInt(e))),r=t[11].replace(/,$/,"").split(",").map((e=>parseInt(e)+1));if(i!==n.length||i!==r.length)this.logger.warn(`- Block count does not match block sizes and starts: ${e}`),console.log(i,n,r);else if(1!==r[0])this.logger.warn(`- Block start does not match start: ${e}`);else if(r[r.length-1]+n[r.length-1]+s.start-2!==s.stop)this.logger.warn(`- Block end does not match stop: ${e}`);else{s.locations=[];for(let e=0;e<i;e++)s.locations.push([s.start+r[e]-1,s.start+r[e]+n[e]-2])}}}return s}validateRecords(e){const t=this.validationIssues,s=t.thickStartNotMatchingStart||[];s.length&&this._warn(`- Features where thickStart != start: ${s.length}`);const i=t.thickEndNotMatchingEnd||[];i.length&&this._warn(`- Features where thickEnd != stop: ${s.length}`),(s.length||i.length)&&this._warn("- NOTE: thickStart and thickEnd are ignored by this parser");const n=t.missingStart||[];n.length&&this._fail("- Records missing Starts: ",{padded:n.length});const r=t.missingStart||[];r.length&&this._fail("- Records missing Stops: ",{padded:r.length})}}class w{constructor(t,s={}){this._file=t,this._separator=[",","\t"].includes(s.separator)?s.separator:",",this._options=s,this.logger=s.logger||new e,this._lineCount=0,this._hasHeader=void 0===s.hasHeader||s.hasHeader,this.onlyColumns=s.onlyColumns||[],this.columnMap=this.createColumnMap(s.columnMap),this.hasHeader||Object.values(this.columnMap).some((e=>isNaN(e)))&&this._fail("- ColumnMap values must be integers when there is no header")}get defaultColumnMap(){return{contig:"contig",start:"start",stop:"stop",name:"name",score:"score",strand:"strand",type:"type",legend:"legend",codonStart:"codonStart"}}get file(){return this._file}get options(){return this._options}get fileFormat(){return","===this.separator?"csv":"tsv"}get displayFileFormat(){return","===this.separator?"CSV":"TSV"}get lineCount(){return this._lineCount}get separator(){return this._separator}get hasHeader(){return this._hasHeader}_warn(e,t="unknown"){this.file._warn(e,t)}_fail(e,t="unknown"){this.file._fail(e,t)}createColumnMap(e={}){const t=Object.keys(this.defaultColumnMap),s=Object.keys(e);for(const e of s)t.includes(e)||this._fail(`- Invalid column key: ${e}`);const i=["start","stop"];for(const e of i)s.includes(e)||this._fail(`- Missing required column: ${e}`);const n={...this.defaultColumnMap,...e};if(this.onlyColumns.length){const e=Object.keys(n);for(const t of e)this.onlyColumns.includes(t)||delete n[t]}return n}static detectSeparator(e){const t=u(e,{maxLines:10});let s,i;for(const e of t){const t=(e.match(/,/g)||[]).length,n=(e.match(/\t/g)||[]).length;void 0===s?s=t:s!==t&&(s=-1),void 0===i?i=n:i!==n&&(i=-1)}if(![0,-1].includes(s)||![0,-1].includes(i))return-1===s?"\t":-1===i||s>i?",":"\t"}addError(e,t){const s=this.errors;s[e]?s[e].push(t):s[e]=[t]}parse(e,t={}){const s=[],i=!1,n=e.split("\n");let r;for(r of n)if(r.startsWith("#"));else if(""===r.trim());else if(this.hasHeader&&!i)i=!0,this._parseHeader(r);else{const e=this._parseLine(r);e&&s.push(e)}return this.logger.info(`- Parsed ${s.length} records`),s}_parseHeader(e){}_parseLine(e){this._lineCount++;const t=e.split(this.separator).map((e=>e.trim()));if(t.length<2)return this._fail(`- Line does not have at least 2 fields: ${e}`),null;t[this.columnMap.contig],this.addFieldToRecord(s,"contig",t,"integer");const s={contig:t[0],start:parseInt(t[1])+1,stop:parseInt(t[2]),name:t[3]||"Uknown"},i=parseFloat(t[4]);if(isNaN(i)||(s.score=i),t[5]&&(s.strand=t[5]),t[6]){parseInt(t[6])+1!==s.start&&this.addError("thickStartNotMatchingStart",`- thickStart is not the same as start: ${e}`)}if(t[7]){parseInt(t[7])!==s.stop&&this.addError("thickEndNotMatchingEnd",`- thickEnd is not the same as stop: ${e}`)}return s}addFieldToRecord(e,t,s,i="string"){if(!["string","integer","float"].includes(i))throw new Error(`Invalid parseAs value: ${i}`);const n=this.columnIndexMap;if(void 0!==n[t]){const r=n[t];void 0!==s[r]&&(e[t]="integer"===i?parseInt(s[r]):"float"===i?parseFloat(s[r]):s[r])}}validateRecords(e){const t=this.errors,s=t.thickStartNotMatchingStart||[];s.length&&this._warn(`- Features where thickStart != start: ${s.length}`);const i=t.thickEndNotMatchingEnd||[];i.length&&this._warn(`- Features where thickEnd != stop: ${s.length}`),(s.length||i.length)&&this._warn("- NOTE: thickStart and thickEnd are ignored by this parser");const n=e.filter((e=>isNaN(e.start)));n.length&&this._fail("- Records missing Starts: ",{padded:n.length});const r=e.filter((e=>isNaN(e.stop)));r.length&&this._fail("- Records missing Stops: ",{padded:r.length})}}class b extends _{static FORMATS=["auto","gff3","bed","csv","gtf"];static FILE_FORMAT_DELEGATES={gff3:C,gtf:N,bed:T,csv:w,tsv:w};constructor(e,t={}){super(t,"PARSING FEATURE FILE");const s=o(e);let i=t.format||"auto";if(this._records=[],this.nameKeys=t.nameKeys||["Name","Alias","gene","locus_tag","product","note","db_xref","ID"],s&&""!==s)if(c(s))this._fail("Parsing Failed: Input contains non-text characters. Is this binary data?",{errorCode:"binary"});else{this._info("Checking File Format..."),this._info("- Format Provided: ",{padded:i});const e=this.detectFormat(s);if(this._info("- Format Detected: ",{padded:e}),this.inputFormat=this.chooseFormat(i,e),!this.passed)return;["gtf","gff3"].includes(this.inputFormat)&&this._info("- Name extraction keys (GFF3/GTF): "+this.nameKeys.join(", ")),this._records=this.parseWrapper(s,t),this.validateRecordsWrapper(this._records,t),this.parseSummary()}else this._fail("Parsing Failed: No input text provided.",{errorCode:"empty"});this.logger.break()}get inputFormat(){return this.delegate.fileFormat}set inputFormat(e){const t=Object.keys(b.formatDelegateMap);t.includes(e)?(["csv","tsv"].includes(e)&&(this.options.separator="csv"===e?",":"\t"),this._delegate=new b.formatDelegateMap[e](this,this.options)):this._fail(`File format '${e}' must be one of the following: ${t.join(", ")}`)}detectFormat(e){let t;const s=e.split("\n").filter((e=>""!==e.trim()&&!e.startsWith("#")))[0];if(e.match(/^##gff-version 3/))t="gff3";else if(N.lineMatches(s))t="gtf";else if(T.lineMatches(s))t="bed";else{const s=w.detectSeparator(e);t=","===s?"csv":"\t"===s?"tsv":"unknown"}return t}chooseFormat(e,t){return b.FORMATS.includes(e)&&"auto"!==e?(e!==t&&this._warn(`- Using Provided format '${e}'; Does not match detected format '${t}'`),e):("unknown"===t?this._fail("- File Format Unknown: AutoDection Failed. Try explicitly setting the format.",{errorCode:"unknown_format"}):"auto"!==e&&this._warn(`- Unknown format '${e}' -> Using '${t}'`),t)}toCGViewFeaturesJSON(e={}){}get records(){return this._records}get summary(){return this._summary}parseSummary(){const e=this.records,t=this.displayFileFormat||this.inputFormat.toUpperCase();this.logger.divider(),this._info("Parsing Summary:"),this._info("- Input File Format:",{padded:t}),this._info("- Data Lines:",{padded:this.lineCount}),this._info("- Feature Count:",{padded:e.length});const s=e.filter((e=>!e.valid)).length;s>0&&this._fail("- Features Failed:",{padded:s}),this.logStatusLine(),this.logger.divider(),this._summary={inputFormat:this.inputFormat,featureCount:e.length,status:this.status}}get delegate(){return this._delegate}static get formatDelegateMap(){return b.FILE_FORMAT_DELEGATES}get fileFormat(){return this.delegate?.fileFormat||"unknown"}get displayFileFormat(){return this.delegate?.displayFileFormat||"Unknown"}get lineCount(){return this.delegate.lineCount}parse(e,t){return this.delegate.parse(e,t)}validateRecords(e,t){this.delegate.validateRecords(e,t)}parseWrapper(e,t={}){let s=[];this._info(`Parsing ${this.displayFileFormat} Feature File...`);try{s=this.parse(e,t);const i=s.filter((e=>Array.isArray(e.locations))).length;console.log("recordsWithLocationsCount",i),this._info("- Features with >1 location: ",{padded:i}),this._info("- Done parsing feature file")}catch(e){this._fail("- Failed: An error occurred while parsing the file.",{errorCode:"parsing"}),this._fail(`- ERROR: ${e.message}`)}return s}validateRecordsWrapper(e,t={}){this.logger.info("Validating Records ...");try{this.validateRecords(e,t),console.log("HERE HERHERHERHEHR"),console.log(e),0===e.length&&this._fail("- Failed: No records found in the file."),this.passed?this._info("- Validations Passed",{icon:"success"}):this._fail("- Validations Failed")}catch(e){this._fail("- Failed: An error occurred while validating the records.",{errorCode:"validating"}),this._fail(`- ERROR: ${e.message}`)}}}const v={};return v.version=t,v.Logger=e,v.helpers=m,v.SequenceFile=S,v.CGViewBuilder=y,v.FeatureFile=b,v.FeatureBuilder=class extends _{constructor(e,t={}){super(t,"BUILDING FEATURES"),this.includeFeatures=void 0===t.includeFeatures||t.includeFeatures,this.excludeFeatures=t.excludeFeatures||["gene","source","exon"],this.includeQualifiers=t.includeQualifiers||!1,this.excludeQualifiers=t.excludeQualifiers||[],this.featureFile=this._parseInput(e),this.inputDisplayFormat=this.featureFile.displayFileFormat,this.featureFile.passed?this._json=this._build(this.featureFile.records):this._fail("*** Cannot convert to CGView Feature JSON because feature file parsing failed ***")}toJSON(){return this._json}_parseInput(e){return"string"==typeof e?new b(e,{logger:this.logger}):e instanceof b?e:void this._fail("Invalid input: must be a string (from GFF3, GTF, BED, CSV) or FeatureFile object")}_build(e){const t=[];if(this._skippedFeaturesByType={},this._complexFeatures=[],this._skippedLocationlessFeatures=[],this.logger.info("FeatureBuilder: ",{padded:this.version}),this.logger.info("Converting to CGView Feature JSON..."),this.logger.info("- Input File Format: ",{padded:this.inputDisplayFormat||"Unknown"}),this.logger.info("- Input Feature Count: ",{padded:e.length}),e&&!(e.length<1)){for(const s of e){const e=this._buildFeature(s);e&&t.push(e)}return this._adjustFeatureContigNames(t),this._buildSummary(t),t}this._fail("Conversion Failed: No feature records provided")}_buildFeature(e){const t={};return e.name&&(t.name=e.name),t.contig=e.contig,t.start=e.start,t.stop=e.stop,t.strand=["-1","-",-1].includes(e.strand)?-1:1,t.type=e.type,isNaN(Number(e.score))||(t.score=Number(e.score)),e.source&&(t.source=e.source),e.qualifiers&&(t.qualifiers=e.qualifiers),e.locations&&(t.locations=e.locations),t}_buildSummary(e){this.logger.divider(),this.logger.info("CGView Feature JSON Summary:"),this.logger.info("- Feature Count: ",{padded:e.length}),this.logStatusLine(),this.logger.divider()}_adjustFeatureContigNames(e){this.logger.info("- Checking feature contig names...");const t=e.map((e=>e.contig)),s=[...new Set(t)],i=y.adjustContigNames(s),n={};i.reasons.forEach((e=>{n[e.origName]=e.newName}));const r=[];let o=0;if(i.reasons.length>0){for(const t of e)n[t.contig]&&(t.contig=n[t.contig],o++);this.logger.warn(`The following contig names (${i.reasons.length}) were adjusted:`),this.logger.warn("Reasons: DUP (duplicate), LONG (>34), REPLACE (nonstandard characters), BLANK (empty)");for(const e of i.reasons)r.push(`- ${e.origName} -> ${e.newName} (${e.reason.join(", ")})`);this._warn(r),this._warn(`- Features with adjusted contig names: ${o}`)}}},v}();
